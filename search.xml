<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubbo基础环境准备</title>
      <link href="2021/03/26/microservice/dubbo/dubbo-basic-env-prepare/"/>
      <url>2021/03/26/microservice/dubbo/dubbo-basic-env-prepare/</url>
      
        <content type="html"><![CDATA[<p>在开发基于<code>Dubbo</code>的微服务应用之前，我们需要准备以下基础环境：</p><ul><li><code>Zookeeper</code>：用作注册中心。</li><li><code>Dubbo Admin</code>：微服务管理运维控制台。</li></ul><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><code>Zookeeper</code></h2><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>本地环境选择安装单机版的<code>Zookeeper</code>，简便快捷。</p><p>首先去 <a href="https://zookeeper.apache.org/releases.html#download"><code>Zookeeper</code>官网</a> 下载安装包，注意是下载<code>bin</code>二进制安装包而不是<code>source</code>源码包。</p><p>无论<code>Windows</code>还是<code>Mac</code>系统，下载后均需执行以下三步：</p><ul><li>解压：<code>tar -zxvf apache-zookeeper-3.6.2-bin.tar.gz</code></li><li>进入配置目录：<code>cd ./apache-zookeeper-3.6.2-bin/conf</code></li><li>重命名配置文件：<code>mv ./zoo_sample.cfg ./zoo.cfg</code></li></ul><p>然后进入<code>/apache-zookeeper-3.6.2-bin/bin</code>目录启动<code>Zookeeper</code>服务。</p><ul><li><code>Windows</code>系统：文件夹下双击<code>zkServer.cmd</code>即可。</li><li><code>Mac</code>系统：终端中进入<code>bin</code>目录执行<code>./zkServer.sh start</code>命令。</li></ul><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a><code>Docker</code>安装</h3><p>建议在虚拟机中或云服务器上使用<code>Docker</code>安装。我们使用<code>docker-compose</code>工具来编排服务。</p><p>具体可参考：<a href="https://lilu.org.cn/2021/03/25/ops/docker/docker-compose/zk/">使用<code>Docker Compose</code>编排<code>Zookeeper</code>服务</a></p><h2 id="Dubbo-Admin"><a href="#Dubbo-Admin" class="headerlink" title="Dubbo Admin"></a><code>Dubbo Admin</code></h2><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><p>首先下载工程源码：</p><ul><li><code>GitHub</code>：<code>git clone https://github.com/apache/dubbo-admin.git</code></li><li><code>Gitee</code>：<code>git clone https://gitee.com/sunchaser-lilu/dubbo-admin.git</code>（速度快）</li></ul><p>工程的启动方式参考<code>/dubbo-admin/README_ZH.md</code>中的说明。</p><p>我们可以修改<code>/dubbo-admin/dubbo-admin-server/src/main/resources/application.properties</code>中的配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">admin.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="meta">admin.config-center</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="meta">admin.metadata-report.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><p>目前<code>Dubbo</code>主要版本有两个：<code>Dubbo 2.7.x</code>和<code>Dubbo 2.6.x</code>。它们的不同之处在于配置管理中心，<code>Dubbo 2.6.x</code>版本所有数据都存储在注册中心上；而<code>Dubbo 2.7.x</code>版本分成了注册中心、配置中心和元数据中心。</p><p>如果项目中集成的<code>Dubbo</code>版本是<code>2.6.x</code>，则只需配置<code>admin.registry.address</code>注册中心的地址；</p><p>如果<code>Dubbo</code>版本是<code>2.7.x</code>，则需要配置<code>admin.config-center</code>配置中心的地址，然后在配置中心去配置注册中心和元数据中心地址。例如使用<code>Zookeeper</code>作为配置中心，则需要在<code>Zookeeper</code>中创建<code>path</code>为<code>/dubbo/config/dubbo/dubbo.properties</code>的节点，节点的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br><span class="line">dubbo.metadata-report.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br></pre></td></tr></table></figure><blockquote><p>如果使用了本地启动的<code>Zookeeper</code>服务，直接启动<code>dubbo-admin-server</code>会出现一个错误，具体请看 <a href="https://www.jianshu.com/p/9f3f8b0d6a08"><code>zookeeper 3.5.5</code>启动后<code>dubbo-admin-server</code>项目报<code>8080</code>端口被占用错误</a></p></blockquote><h3 id="Docker安装-1"><a href="#Docker安装-1" class="headerlink" title="Docker安装"></a><code>Docker</code>安装</h3><p><code>Zookeeper</code>和<code>Dubbo Admin</code>服务可同时部署至云端，使用<code>docker-compose</code>进行编排。</p><p>具体可参考：<a href="https://lilu.org.cn/2021/03/26/ops/docker/docker-compose/dubbo-admin/">使用<code>Docker Compose</code>编排<code>Dubbo Admin</code>服务</a></p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker Compose编排Dubbo Admin服务</title>
      <link href="2021/03/26/ops/docker/docker-compose/dubbo-admin/"/>
      <url>2021/03/26/ops/docker/docker-compose/dubbo-admin/</url>
      
        <content type="html"><![CDATA[<p>使用<code>Docker Compose</code>编排<code>Dubbo Admin</code>服务。</p><p>端口规划：</p><ul><li><code>Dubbo Admin</code>：<code>6001</code></li></ul><p>在工作目录创建<code>docker-compose</code>的<code>yml</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /opt/sunchaser</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> touch dubbo-admin.yml</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vim dubbo-admin.yml</span></span><br></pre></td></tr></table></figure><p><code>dubbo-admin.yml</code>文件编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">dubbo-admin:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sunchaserlilu/dubbo-admin:2021.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dubbo-admin</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6001</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.config-center=zookeeper://$&#123;ip&#125;:$&#123;port&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.registry.address=zookeeper://$&#123;ip&#125;:$&#123;port&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.metadata-report.address=zookeeper://$&#123;ip&#125;:$&#123;port&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.root.user.name=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin.root.user.password=root</span></span><br></pre></td></tr></table></figure><blockquote><p>注意需要将<code>yml</code>文件中的<code>$&#123;ip&#125;:$&#123;port&#125;</code>替换成自己的<code>ip:port</code>。</p></blockquote><p>保存退出后执行<code>docker-compose -f dubbo-admin.yml up -d</code>命令启动服务。</p><p>浏览器中访问<code>http://$&#123;ip&#125;:6001</code>即可看到<code>Dubbo Admin</code>控制台。</p><blockquote><p>关于<code>Dubbo Admin</code>镜像的选择：</p><p>目前<code>dockerhub</code>仓库中<code>Apache</code>官方提供的镜像只有<code>2</code>个<code>tag</code>：<code>0.1.0</code>和<code>latest</code>，在我尝试的过程中发现这两个官方镜像都存在问题，运行环境是：<code>Spring Boot 2.2.0 + Dubbo 2.7.3</code>，即使按照 <a href="https://github.com/apache/dubbo-admin/issues/342">https://github.com/apache/dubbo-admin/issues/342</a> 进行配置还是无法获取服务的元数据。于是我制作了自己的镜像，具体可参考 <a href="https://lilu.org.cn/2021/03/26/ops/docker/build-dubbo-admin-docker-image/">制作自己的<code>Dubbo Admin</code>镜像</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Docker </category>
          
          <category> Docker Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo Admin </tag>
            
            <tag> Docker Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作自己的Dubbo Admin镜像</title>
      <link href="2021/03/26/ops/docker/build-dubbo-admin-docker-image/"/>
      <url>2021/03/26/ops/docker/build-dubbo-admin-docker-image/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前在<code>dockerhub</code>仓库中，<code>Apache</code>官方提供的<code>Dubbo Admin</code>镜像只有<code>2</code>个<code>tag</code>：<code>0.1.0</code>和<code>latest</code>，我在测试的过程中发现这两个官方镜像都存在问题，运行环境是：<code>Spring Boot 2.2.0 + Dubbo 2.7.3</code>，即使按照 <a href="https://github.com/apache/dubbo-admin/issues/342"><code>https://github.com/apache/dubbo-admin/issues/342</code></a> 进行配置后前端页面还是不展示微服务的元数据。</p><p>于是我克隆了<code>Dubbo Admin</code>源码并在本地<code>IDEA</code>中启动，元数据又正常展示了。猜测是最新的<code>develop</code>分支修复了某些问题。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>按照<code>Dubbo Admin</code>的配置说明，需要在<code>Zookeeper</code>中添加一个节点<code>/dubbo/config/dubbo/dubbo.properties</code>，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br><span class="line">dubbo.metadata-report.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>这一步目前来看是需要手动操作的，参考 <a href="https://github.com/apache/dubbo-admin/issues/342"><code>https://github.com/apache/dubbo-admin/issues/342</code></a> 我们可以修改<code>dubbo-admin-server</code>源码让其进行自动配置。</p><p>修改<code>org.apache.dubbo.admin.config.ConfigCenter</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenter</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;admin.registry.address:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String registryAddress;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;admin.metadata-report.address:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String metadataAddress;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;zookeeper://&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;dubbo-admin#ConfigCenter start. In afterPropertiesSet method registryAddress=&quot;</span> + registryAddress);</span><br><span class="line">        <span class="keyword">if</span> (!registryAddress.startsWith(PREFIX)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String connectString = registryAddress.substring(PREFIX.length());</span><br><span class="line">        CuratorFramework zkClient = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(connectString)</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>))</span><br><span class="line">                .build();</span><br><span class="line">        zkClient.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zkClient.checkExists().forPath(<span class="string">&quot;/dubbo/config/dubbo/dubbo.properties&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zkClient.create()</span><br><span class="line">                    .creatingParentsIfNeeded()</span><br><span class="line">                    .forPath(<span class="string">&quot;/dubbo/config/dubbo/dubbo.properties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        zkClient.setData()</span><br><span class="line">                .forPath(</span><br><span class="line">                        <span class="string">&quot;/dubbo/config/dubbo/dubbo.properties&quot;</span>,</span><br><span class="line">                        (<span class="string">&quot;dubbo.registry.address=&quot;</span> + registryAddress + <span class="string">&quot;\ndubbo.metadata-report.address=&quot;</span> + metadataAddress).getBytes()</span><br><span class="line">                );</span><br><span class="line">        logger.info(<span class="string">&quot;dubbo-admin#ConfigCenter afterPropertiesSet process end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在启动参数中传入<code>registryAddress</code>和<code>metadataAddress</code>从而动态写入<code>Zookeeper</code>中。</p><h2 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a><code>maven</code>打包</h2><p>接下来我们对<code>dubbo-admin-server</code>模块进行打包：<code>mvn package</code>。执行成功后可在<code>/dubbo-admin-server/target</code>目录中看到打好的<code>dubbo-admin-server-0.3.0-SNAPSHOT.jar</code>包，此<code>jar</code>包已经包含了<code>dubbo-admin-ui</code>模块编译之后的<code>dist</code>静态文件，本地可直接<code>java -jar dubbo-admin-server-0.3.0-SNAPSHOT.jar</code>启动。启动成功后访问<code>http://127.0.0.1:8080</code>可查看控制台。</p><h2 id="制作Docker镜像"><a href="#制作Docker镜像" class="headerlink" title="制作Docker镜像"></a>制作<code>Docker</code>镜像</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写<code>Dockerfile</code></h3><p>进入工作目录编写<code>Dockerfile</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd &#x2F;opt&#x2F;images&#x2F;dubbo-admin</span><br><span class="line">&gt; touch Dockerfile</span><br><span class="line">&gt; vim Dockerfile</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">MAINTAINER SunChaser &lt;admin@lilu.org.cn&gt;</span><br><span class="line">COPY *.jar &#x2F;app.jar</span><br><span class="line">CMD [&quot;--server.prot&#x3D;8080&quot;]</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>上传<code>jar</code>包至<code>Dockerfile</code>同级目录。</p><blockquote><p>如果是云服务器，可使用命令上传文件：<code>scp -r /path/dubbo-admin-server-0.3.0-SNAPSHOT.jar root@ip:/opt/images/dubbo-admin</code></p></blockquote><h3 id="制作镜像并推送"><a href="#制作镜像并推送" class="headerlink" title="制作镜像并推送"></a>制作镜像并推送</h3><p>制作镜像：<code>docker build -t sunchaserlilu/dubbo-admin:2021.0.0 .</code></p><p>由于要推送至官方<code>dockerhub</code>仓库，镜像命名需要遵循一定规则：用户名/镜像名:<code>tag</code>。</p><blockquote><p>注意命令最后面有一个小数点<code>.</code></p></blockquote><p>登录<code>docker</code>推送镜像至<code>dockerhub</code>仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker login #输入正确的用户名和密码</span><br><span class="line">&gt; docker push sunchaserlilu&#x2F;dubbo-admin:2021.0.0</span><br></pre></td></tr></table></figure><p>推送会有一点慢，请耐心等待推送完成，然后就可以在 <a href="https://hub.docker.com/"><code>https://hub.docker.com/</code></a> 上搜索到我们刚才推送的镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Dubbo Admin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker Compose编排Zookeeper服务</title>
      <link href="2021/03/25/ops/docker/docker-compose/zk/"/>
      <url>2021/03/25/ops/docker/docker-compose/zk/</url>
      
        <content type="html"><![CDATA[<p>使用<code>Docker Compose</code>工具来编排<code>Zookeeper</code>单机服务和包含三节点的<code>Zookeeper</code>集群服务。</p><p>服务器的端口规划：</p><ul><li>单机<code>s-zk</code>：<code>2180</code></li><li>集群<code>zk1</code>：<code>2181</code></li><li>集群<code>zk2</code>：<code>2182</code></li><li>集群<code>zk3</code>：<code>2183</code></li></ul><p>在工作目录创建<code>Docker Compose</code>的<code>yml</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd &#x2F;opt&#x2F;sunchaser</span><br><span class="line">&gt; touch zk.yml</span><br><span class="line">&gt; vim zk.yml</span><br></pre></td></tr></table></figure><p><code>zk.yml</code>文件编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">s-zk:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.6.2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">s-zk</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2180</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./s-zk/conf:/conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./s-zk/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./s-zk/logs:/datalog</span></span><br><span class="line">  <span class="attr">zk1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.6.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zk1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zk1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=0.0.0.0:2888:3888;2181</span> <span class="string">server.2=zk2:2888:3888;2181</span> <span class="string">server.3=zk3:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/zk-cluster/zk1/data:/data</span></span><br><span class="line">  <span class="attr">zk2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.6.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zk2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zk2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888;2181</span> <span class="string">server.2=0.0.0.0:2888:3888;2181</span> <span class="string">server.3=zk3:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/zk-cluster/zk2/data:/data</span></span><br><span class="line">  <span class="attr">zk3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.6.2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zk3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888;2181</span> <span class="string">server.2=zk2:2888:3888;2181</span> <span class="string">server.3=0.0.0.0:2888:3888;2181</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/zk-cluster/zk3/data:/data</span></span><br></pre></td></tr></table></figure><p>保存退出后执行<code>docker-compose -f zk.yml up -d</code>命令启动服务。</p><p>单机服务：<code>zookeeper://ip:2180</code></p><p>集群服务：<code>zookeeper://ip:2181,ip:2182,ip:2183</code></p><blockquote><p>如果是在阿里云等云服务器上安装，需要在安全组的入方向中添加<code>2180</code>、<code>2181</code>、<code>2182</code>、<code>2183</code>端口。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Docker </category>
          
          <category> Docker Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker Compose </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌥️SpringCloud实战-客户端负载均衡之Ribbon</title>
      <link href="2021/02/22/microservice/springcloud/netflix/ribbon/"/>
      <url>2021/02/22/microservice/springcloud/netflix/ribbon/</url>
      
        <content type="html"><![CDATA[<p>客户端负载均衡组件之<code>Ribbon</code>。</p><h2 id="Ribbon整体架构"><a href="#Ribbon整体架构" class="headerlink" title="Ribbon整体架构"></a><code>Ribbon</code>整体架构</h2><p><code>Ribbon</code>是<code>Netflix</code>开源的客户端负载均衡组件，基于<code>HTTP</code>和<code>TCP</code>。<code>Spring Cloud Ribbon</code>基于<code>Ribbon</code>实现，提供轮询、随机等负载均衡策略进行服务调用，也可自定义负载均衡算法。配合<code>Eureka Server</code>使用时的架构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Ribbon/eureka_ribbon_architecture.png" alt="eureka-ribbon-architecture"></p><p>使用了<code>Ribbon</code>的<code>Eureka Client</code>服务消费者在发送请求之前，会从<code>Eureka Server</code>注册中心获取服务提供者列表，然后按照配置的负载均衡策略去发起请求，从而实现客户端的负载均衡。</p><p><code>Ribbon</code>本身也会维护一份服务提供者地址列表。如果它发现服务提供者不可用，则会重新从<code>Eureka Server</code>注册中心获取有效的服务提供者地址列表进行更新。</p><h2 id="为服务消费者配置Ribbon"><a href="#为服务消费者配置Ribbon" class="headerlink" title="为服务消费者配置Ribbon"></a>为服务消费者配置<code>Ribbon</code></h2><p>在<code>IDEA</code>中创建一个名叫<code>ribbon</code>的<code>maven</code>工程，然后在<code>pom.xml</code>中引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>Hoxton.SR9<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预定义依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring boot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring cloud --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- eureka-client依赖引入，其中包含了ribbon依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于<code>spring-cloud-starter-netflix-eureka-client</code>依赖中已经包含了<code>spring-cloud-starter-netflix-ribbon</code>依赖，所以无需单独引入。</p><p>在<code>src/main/resources</code>目录下创建<code>application.properties</code>配置文件，并添加以下配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9002</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">ribbon-service-consumer</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:520/eureka/,http://localhost:521/eureka/</span></span><br></pre></td></tr></table></figure><p>编写启动类<code>RibbonApplication</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.ribbon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/2/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(RibbonApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>eureka-client-service-consumer</code>微服务相比，我们只需要在<code>RestTemplate</code>上加入<code>@LoadBalanced</code>注解即可开启<code>ribbon</code>的客户端负载均衡功能。</p><p>下面我们使用带有负载均衡功能的<code>RestTemplate</code>来消费<code>eureka-client-service-provider</code>提供的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.ribbon.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client-service-provider/provider?id=&quot;</span> + id, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/print/provider/instance&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProviderInstanceList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceInstance serviceInstance = <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">&quot;eureka-client-service-provider&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;service instance:&#123;&#125;&quot;</span>, serviceInstance);</span><br><span class="line">        <span class="keyword">return</span> serviceInstance.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行启动类<code>RibbonApplication</code>，即可将该服务消费者注册至注册中心。</p><p>由于我们在<code>consume</code>方法中将<code>http</code>请求的地址指定为了<code>http://eureka-client-service-provider</code>，这意味着我们要将服务提供者的虚拟主机名改为<code>eureka-client-service-provider</code>，当<code>Ribbon</code>和<code>Eureka</code>配合使用时，会自动将虚拟主机名映射成微服务的网络地址。</p><p>修改<code>eureka-client-provider</code>微服务的<code>src/main/resources/application.properties</code>文件，添加以下配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.instance.virtual-host-name</span>=<span class="string">eureka-client-service-provider</span></span><br></pre></td></tr></table></figure><p>同样地方式启动两个服务提供者实例，先修改<code>Run/Debug Configurations</code>配置：点击<code>Edit Configurations...</code>，找到<code>EurekaClientProviderApplication</code>的启动配置，勾选<code>Allow parallel run</code>后点击<code>OK</code>保存。</p><div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>低版本<code>IDEA</code>对应的勾选项是<code>Single instance only</code>。</p></div><p>启动步骤：</p><p>1、将<code>application.properties</code>配置文件中的<code>server.port</code>端口号配置项设置为<code>9000</code>后启动项目。</p><p>2、修改<code>application.properties</code>配置文件中的<code>server.port</code>端口号配置项设置为<code>9003</code>后启动项目。</p><p>随后即可在<code>http://localhost:520</code>或<code>http://localhost:521</code>注册中心页面上看到两个<code>provider</code>服务提供者实例：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Ribbon/two_eureka_client_service_provider.png" alt="two_eureka_client_service_provider"></p><h2 id="客户端的负载均衡消费"><a href="#客户端的负载均衡消费" class="headerlink" title="客户端的负载均衡消费"></a>客户端的负载均衡消费</h2><p>发送<code>GET</code>请求：<code>GET</code> <a href="http://127.0.0.1:9001/consumer/1">http://127.0.0.1:9002/consumer/1</a>，可看到输出为：<code>provide:1</code>。同时可在其中一个服务提供者实例的控制台上看见被调用的日志信息（另一个实例的控制台无相应日志输出）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-02-22 21:36:46.065  INFO 46900 --- [nio-9001-exec-5] c.s.s.m.s.e.c.p.c.ProviderController     : provide invoked: id&#x3D;1</span><br></pre></td></tr></table></figure><p>再次请求，即可在另一个实例的控制台上看到同样的日志输出。这就是客户端的负载均衡调用。</p><p>我们还可以通过<code>getProviderInstanceList</code>方法查看本次负载均衡策略选择的服务提供者的实例信息。发送<code>GET</code>请求：<code>GET</code><a href="http://127.0.0.1:9001/print/provider/instance">http://127.0.0.1:9002/print/provider/instance</a>，可看到输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RibbonServer&#123;serviceId&#x3D;&#39;eureka-client-service-provider&#39;, server&#x3D;10.32.43.59:9001, secure&#x3D;false, metadata&#x3D;&#123;management.port&#x3D;9001&#125;&#125;</span><br></pre></td></tr></table></figure><p>再次请求，可看到输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RibbonServer&#123;serviceId&#x3D;&#39;eureka-client-service-provider&#39;, server&#x3D;10.32.43.59:9003, secure&#x3D;false, metadata&#x3D;&#123;management.port&#x3D;9003&#125;&#125;</span><br></pre></td></tr></table></figure><p>两次请求客户端选择的服务提供者实例不同，这就是客户端的负载均衡调用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
          <category> Ribbon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌥️SpringCloud实战-服务注册与发现之Eureka Client</title>
      <link href="2021/02/04/microservice/springcloud/netflix/eureka-client/"/>
      <url>2021/02/04/microservice/springcloud/netflix/eureka-client/</url>
      
        <content type="html"><![CDATA[<p>使用<code>Eureka Client</code>实现服务注册与发现。</p><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>将一个微服务（服务提供者）注册至<code>Eureka Server</code>注册中心上。其它微服务（服务消费者）在启动时就可从注册中心进行订阅。</p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>在<code>IDEA</code>中创建一个名叫<code>eureka-client-provider</code>的<code>maven</code>工程，然后在<code>pom.xml</code>中引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>Hoxton.SR9<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预定义依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring boot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring cloud --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- eureka-client依赖引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>src/main/resources</code>目录下创建<code>application.properties</code>配置文件，并添加以下配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9000</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-client-service-provider</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:520/eureka/,http://localhost:521/eureka/</span></span><br></pre></td></tr></table></figure><p>编写启动类<code>EurekaClientProviderApplication</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.eureka.client.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(EurekaClientProviderApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>注意：这里虽然没有在启动类上写<code>@EnableEurekaClient</code>注解，但服务还是会自动注册至注册中心。这是因为<code>Eureka</code>的配置项<code>eureka.client.register-with-eureka</code>默认为<code>true</code>。</p></div><p>我们提供一个很简单的参数输出的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.eureka.client.provider.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/provider&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">provide</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;provide invoked: id=&#123;&#125;&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;provide:&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行启动类<code>EurekaClientProviderApplication</code>，即可将该服务提供者注册至注册中心。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Eureka/eureka-client-service-provider.png" alt="eureka-client-service-provider"></p><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>在<code>IDEA</code>中新建一个名叫<code>eureka-client-consumer</code>的<code>maven</code>工程，然后在<code>pom.xml</code>中引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>src/main/resources</code>目录下创建<code>application.properties</code>配置文件，并添加以下配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9001</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-client-service-consumer</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:520/eureka/,http://localhost:521/eureka/</span></span><br></pre></td></tr></table></figure><p>编写启动类<code>EurekaClientConsumerApplication</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.eureka.client.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/2/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(EurekaClientConsumerApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Bean</code>注解将<code>restful</code>接口的访问模板工具类<code>RestTemplate</code>交给<code>Spring</code>进行管理。</p><p>接下来我们使用<code>RestTemplate</code>来消费<code>eureka-client-provider</code>微服务中提供的<code>/provider</code>服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.eureka.client.consumer.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:9000/provider?id=&quot;</span> + id, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行启动类<code>EurekaClientConsumerApplication</code>，即可将服务消费者注册至注册中心。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Eureka/eureka-client-service-consumer.png" alt="eureka-client-service-consumer"></p><p>发送<code>GET</code>请求：<code>GET</code> <a href="http://127.0.0.1:9001/consumer/1">http://127.0.0.1:9001/consumer/1</a>，可看到返回结果为：<code>provide:1</code>。至此我们已经完成了一次正常的服务调用。<code>eureka-client-service-consumer</code>服务消费者成功消费了一次<code>eureka-client-service-provider</code>服务提供者提供的服务。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
          <category> Eureka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> 服务注册与发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌥️SpringCloud实战-服务注册中心之Eureka Server</title>
      <link href="2021/02/04/microservice/springcloud/netflix/eureka-server/"/>
      <url>2021/02/04/microservice/springcloud/netflix/eureka-server/</url>
      
        <content type="html"><![CDATA[<p>服务注册与发现组件之<code>Eureka</code>。</p><h2 id="Eureka整体架构"><a href="#Eureka整体架构" class="headerlink" title="Eureka整体架构"></a><code>Eureka</code>整体架构</h2><p><code>Eureka</code>是<code>Netflix</code>开源的服务发现组件，本身是一个基于<code>REST</code>的服务。它包含<code>Server</code>和<code>Client</code>两部分。<code>Spring Cloud</code>将它集成在子项目<code>Spring Cloud Netflix</code>中，作为微服务套件中的服务治理组件，实现服务注册与发现功能。整体架构图如下：<br><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Eureka/eureka_architecture.png" alt="eureka_architecture"></p><p>主要包含两个角色：</p><ul><li><p><code>Server</code>端：注册中心，提供服务注册与发现功能。</p></li><li><p><code>Client</code>端：服务提供者和服务消费者。</p></li></ul><p>服务调用流程如下：</p><ul><li>服务提供者<code>Application Service</code>在启动时向注册中心<code>Eureka Server</code>注册自己提供的服务。</li><li>服务消费者<code>Application Client</code>在启动时从注册中心<code>Eureka Server</code>订阅自己所需的服务。</li><li>注册中心返回服务提供者的地址（<code>IP</code>和端口等）列表信息。服务消费者本地进行缓存。</li><li>服务消费者在调用时根据负载均衡策略从提供者地址列表中选择一个地址进行调用。</li></ul><p>微服务启动后，会周期性（默认<code>30s</code>）地向<code>Eureka Server</code>发送心跳以续约自己的“租期”。如果<code>Eureka Server</code>在一定时间内没有接收到某个微服务实例的心跳，<code>Eureka Server</code>将注销该实例（默认<code>90s</code>）。</p><h2 id="单节点Eureka注册中心"><a href="#单节点Eureka注册中心" class="headerlink" title="单节点Eureka注册中心"></a>单节点<code>Eureka</code>注册中心</h2><p>在<code>IDEA</code>中创建一个名叫<code>eureka-server</code>的<code>maven</code>工程，然后在<code>pom.xml</code>中引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>Hoxton.SR9<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 预定义依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring boot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring cloud --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- eureka-server依赖引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后编写启动类<code>EurekaServerApplication</code>，使用<code>@EnableEurekaServer</code>注解开启<code>eureka-server</code>注册中心功能。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.microservice.springcloud.eureka.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(EurekaServerApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在<code>src/main/resources</code>目录下创建<code>application.properties</code>配置文件，并添加以下配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">520</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># host名称</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="comment"># 是否将自己注册至eureka，默认为true。由于当前应用就是eureka-server，故设置为false。</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 是否从eureka-server获取注册信息，默认为true。由于当前应用是一个单点的eureka-server实例，不需要同步其它节点的数据，故设置为false。</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>启动该<code>eureka-server</code>项目，在浏览器中打开<code>http://localhost:520</code>，可看到该注册中心相关信息。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Eureka/single-eureka-server.png" alt="single-eureka-server"></p><p>至此，一个单节点的<code>eureka-server</code>注册中心就搭建完成。只不过还没有微服务进行注册。</p><h2 id="高可用Eureka注册中心"><a href="#高可用Eureka注册中心" class="headerlink" title="高可用Eureka注册中心"></a>高可用<code>Eureka</code>注册中心</h2><p>在实际微服务项目中，注册中心作为微服务之前通讯的桥梁，我们很有必要对其集群部署来保证高可用。</p><p>下面我们来搭建双节点<code>Eureka</code>注册中心集群来保证高可用。由于我们是在自己的笔记本电脑上做演示，所以只能做到伪集群：即同一台机器不同的端口。</p><p>在<code>src/main/resources</code>目录下新建两个配置文件，分别为<code>application-instance1.properties</code>和<code>application-instance2.properties</code>。我们只需要为其配置两个不同的端口号即可。</p><div class="tabs" id="port"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#port-1">application-instance1.properties</button></li><li class="tab"><button type="button" data-href="#port-2">application-instance2.properties</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="port-1"><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">520</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="port-2"><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">521</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>然后我们来修改<code>application.properties</code>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-server</span></span><br><span class="line"><span class="comment"># 当配置为instance1时使用application-instance1.properties作为配置文件</span></span><br><span class="line"><span class="comment"># 当配置为instance2时使用application-instance2.properties作为配置文件</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">instance1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># host名称</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="comment"># 是否将自己注册至eureka，默认为true。由于当前应用需要注册到另一台eureka-server，故设置为true。</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 是否从eureka-server获取注册信息，默认为true。由于当前应用是集群中的一个节点，需要从其它节点中同步数据，故设置为true。</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 设置与eureka-server交互的地址。当前应用的每一个实例都是eureka-server，相互之间进行注册，故这里填写每一个实例的地址，用逗号,进行分隔。</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://$&#123;eureka.instance.hostname&#125;:520/eureka/,http://$&#123;eureka.instance.hostname&#125;:521/eureka/</span></span><br></pre></td></tr></table></figure><h2 id="在IDEA中启动双实例"><a href="#在IDEA中启动双实例" class="headerlink" title="在IDEA中启动双实例"></a>在<code>IDEA</code>中启动双实例</h2><p>由于<code>IDEA</code>默认只能单实例运行，所以需要先修改<code>Run/Debug Configurations</code>配置：点击<code>Edit Configurations...</code>，找到<code>EurekaServerApplication</code>的启动配置，勾选<code>Allow parallel run</code>后点击<code>OK</code>保存。</p><div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>低版本<code>IDEA</code>对应的勾选项是<code>Single instance only</code>。</p></div><p>启动步骤：</p><p>1、将<code>application.properties</code>配置文件中的<code>spring.profiles.active</code>配置项设置为<code>instance1</code>后启动项目。</p><p>2、修改<code>application.properties</code>配置文件中的<code>spring.profiles.active</code>配置项为<code>instance2</code>后再次启动项目。</p><p>先启动的实例会在控制台输出一些异常堆栈信息，这是因为先启动的<code>instance1</code>实例会尝试注册到<code>instance2</code>实例中去，而这时<code>instance2</code>实例并未启动，所以会抛出异常，但这并不影响注册中心的启动，等到<code>instance2</code>实例正常启动后，<code>instance1</code>实例会通过心跳重连机制重新注册至<code>instance2</code>。</p><p>全部启动成功后，在浏览器打开<code>http://localhost:520</code>或<code>http://localhost:521</code>，可看到两个实例相互注册成功。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Eureka/eureka-server-instance1.png" alt="eureka-instance1"></p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/microservice/SpringCloud/Eureka/eureka-server-instance2.png" alt="eureka-instance2"></p><p>至此，一个高可用双节点<code>eureka-server</code>注册中心集群就搭建完成。</p><h2 id="使用IP地址注册服务"><a href="#使用IP地址注册服务" class="headerlink" title="使用IP地址注册服务"></a>使用<code>IP</code>地址注册服务</h2><p>上面我们是设置主机名<code>host</code>为<code>localhost</code>进行服务注册的，一旦我们的微服务发布至云服务器，需要在互联网上进行访问时，我们使用<code>host</code>注册就需要一个域名，但这并不是必需的，我们还可以直接使用服务器的<code>IP</code>来进行服务注册。</p><p>将<code>application.properties</code>配置文件修改为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用host注册</span><br><span class="line"># eureka.instance.hostname&#x3D;localhost</span><br><span class="line"># 使用IP地址注册</span><br><span class="line">eureka.instance.prefer-ip-address&#x3D;true</span><br><span class="line"># 指定IP</span><br><span class="line">eureka.client.service-url.defaultZone&#x3D;http:&#x2F;&#x2F;127.0.0.1:520&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;127.0.0.1:521&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>注释掉<code>host</code>注册的配置项，开启<code>eureka.instance.prefer-ip-address</code>配置项使用<code>IP</code>地址注册，然后修改<code>eureka.client.service-url.defaultZone</code>配置项指定<code>IP</code>地址。</p><p>在<code>application-instance1.properties</code>和<code>application-instance2.properties</code>中分别指定<code>instance-id</code>：</p><div class="tabs" id="port"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#port-1">application-instance1.properties</button></li><li class="tab"><button type="button" data-href="#port-2">application-instance2.properties</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="port-1"><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">instance1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="port-2"><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">eureka.instance.instance-id</span>=<span class="string">instance2</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>重新启动双实例即可使用<code>IP</code>地址进行注册。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
          <category> Eureka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🍃增强StopWatch类监控代码的执行耗时</title>
      <link href="2021/02/02/javaee/stop-watch-wrapper/"/>
      <url>2021/02/02/javaee/stop-watch-wrapper/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在业务开发中，我们经常需要对代码执行的耗时进行监控。<code>Spring</code> 有一个<code>org.springframework.util.StopWatch</code>工具类实现了该功能。</p><p>基本使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSpringStopWatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// mock biz</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stopWatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;执行耗时&#123;&#125;ms&quot;</span>,stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了我们需要执行的业务逻辑代码之外，我们还需要在<code>finally</code>代码块中手动调用<code>stop</code>方法，然后对执行耗时进行输出打印。</p><p>这样的代码多起来就显得很重复了。我们得想个办法少写点代码<code>qwq</code>~</p><h2 id="如何对方法进行增强"><a href="#如何对方法进行增强" class="headerlink" title="如何对方法进行增强"></a>如何对方法进行增强</h2><p>增强一个<code>Java</code>类中的方法有几种方式？</p><ul><li>继承：只有在能够控制这个类的构造器的时候（即不能全部是<code>private</code>修饰的构造器），才可以使用继承。</li><li>装饰模式：装饰对象和被装饰对象都要实现相同的接口，装饰对象中需要获取被装饰对象的引用。</li><li>动态代理：<ul><li><code>JDK</code>动态代理：需要被增强类实现一个接口。</li><li><code>cglib</code>动态代理：不需要被增强类实现一个接口，内部通过继承生成子类的方式对被代理类进行增强。所以被代理类最好不要声明成<code>final</code>。</li></ul></li></ul><h2 id="对StopWatch进行增强"><a href="#对StopWatch进行增强" class="headerlink" title="对StopWatch进行增强"></a>对<code>StopWatch</code>进行增强</h2><h3 id="增强方式"><a href="#增强方式" class="headerlink" title="增强方式"></a>增强方式</h3><p>由于监控代码执行耗时需要能监控任意一小段代码执行的耗时，所以我们不能使用AOP对整个方法进行增强。而装饰模式需要在装饰对象中获取被装饰对象的引用，适合有很多种增强的情况下使用，例如<code>JDK</code>的<code>IO</code>流体系。这里我只需要单一的对<code>StopWatch</code>类进行增强，所以我选择使用继承的方式。</p><h3 id="增强的具体实现"><a href="#增强的具体实现" class="headerlink" title="增强的具体实现"></a>增强的具体实现</h3><p>我们可以在继承<code>StopWatch</code>类后重写<code>stop</code>方法，在调用<code>super.stop()</code>后，进行耗时的日志打印。但这样还是每次都需要手动调用<code>stop()</code>方法。</p><p>有没有一种办法可以让我们不在业务代码中主动调用<code>stop</code>方法呢？</p><p>我们可以利用<code>JDK7</code>的<code>try-with-resources</code>特性：在<code>try</code>后面可以创建一个实现了<code>java.lang.AutoCloseable</code>接口的对象，该对象作用于整个<code>try</code>语句块中，当<code>try</code>语句块中的逻辑执行完毕后会自动回调<code>java.lang.AutoCloseable#close()</code>方法。</p><p>来看下对<code>StopWatch</code>增强的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.springboot.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对org.springframework.util.StopWatch类的增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatchWrapper</span> <span class="keyword">extends</span> <span class="title">StopWatch</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持try-with-resources写法</span></span><br><span class="line"><span class="comment">     * 1、监控停止：org.springframework.util.StopWatch#stop()</span></span><br><span class="line"><span class="comment">     * 2、耗时打印</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception org.springframework.util.StopWatch#stop() throws</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isRunning()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.stop();</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;-执行耗时&#123;&#125;ms&quot;</span>, StringUtils.isEmpty(<span class="keyword">this</span>.getId()) ? <span class="string">&quot;default&quot;</span> : <span class="keyword">this</span>.getId(), <span class="keyword">this</span>.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强后，我们的使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStopWatchWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (StopWatchWrapper watchWrapper = <span class="keyword">new</span> StopWatchWrapper(<span class="string">&quot;test-watch-wrapper&quot;</span>))&#123;</span><br><span class="line">        watchWrapper.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// mock exception</span></span><br><span class="line">        <span class="comment">// throw new RuntimeException(&quot;mock error&quot;);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">03:41:58.165 [main] INFO com.sunchaser.sparrow.springboot.utils.StopWatchWrapper - test-watch-wrapper-执行耗时101ms</span><br></pre></td></tr></table></figure><p>可看到已按照预期回调了<code>org.springframework.util.StopWatch#stop()</code>方法并打印了日志。</p>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StopWatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🦋基于Butterfly主题的美化日记</title>
      <link href="2021/01/31/butterfly/"/>
      <url>2021/01/31/butterfly/</url>
      
        <content type="html"><![CDATA[<p>本文基于<code>butterfly</code>主题<code>3.6.0</code>版本修改。</p><p>部分修改无法使用纯<code>css</code>或<code>JavaScript</code>实现，需要修改原主题的源码。如果后续需要升级原主题，请重新修改一遍。</p><div class="note red icon simple"><i class="note-icon fas fa-fan"></i><p>有些修改就算能用<code>JavaScript</code>实现，也严重影响加载速度，所以还不如修改原主题的源码。</p></div><p>为避免修改地方过多，可将自定义的<code>css</code>样式和<code>js</code>脚本分别放置在同一文件中。</p><p>在<code>/themes/butterfly/source/css/_global</code>目录下新建自己的<code>styl</code>样式文件，取名<code>sunchaser.styl</code>，<code>index.styl</code>中已自动引入。</p><p>在<code>/themes/butterfly/source/js</code>目录下新建自己的<code>js</code>脚本文件，取名<code>sunchaser.js</code>，然后在<code>_config.butterfly.yml</code>中进行<code>inject</code>引入。</p><p>配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/sunchaser.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="去掉首页的全屏图片"><a href="#去掉首页的全屏图片" class="headerlink" title="去掉首页的全屏图片"></a>去掉首页的全屏图片</h2><p>首页的全屏图片和<code>subtitle</code>，看似很美，却无实际作用。个人觉得作为博客站，打开的第一屏应该展现的是优质的文章。</p><p>在<code>3.6.0</code>版本之前，原主题没有关闭首页全屏图片的配置项。该功能为<code>3.6.0</code>版本新增。</p><div class="tabs" id="topimg"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#topimg-1">version<3.6.0</button></li><li class="tab active"><button type="button" data-href="#topimg-2">version=3.6.0</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="topimg-1"><p>版本号小于<code>3.6.0</code></p><p>打开<code>/themes/butterfly/layout/includes/header/index.pug</code>文件找到以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- var isHomeClass &#x3D; is_home() ? &#39;full_page&#39; : &#39;not-index-bg&#39;</span><br></pre></td></tr></table></figure><p>修改为以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- var isHomeClass &#x3D; is_home() ? &#39;&#39; : &#39;not-index-bg&#39;</span><br></pre></td></tr></table></figure><p>再在此文件中找到以下代码并全部注释掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;#site-info</span><br><span class="line">&#x2F;&#x2F;  h1#site-title&#x3D;site_title</span><br><span class="line">&#x2F;&#x2F;  #site-subtitle</span><br><span class="line">&#x2F;&#x2F;    span#subtitle</span><br><span class="line">&#x2F;&#x2F;  if(theme.social)</span><br><span class="line">&#x2F;&#x2F;    #site_social_icons</span><br><span class="line">&#x2F;&#x2F;      !&#x3D;fragment_cache(&#39;social&#39;, function()&#123;return partial(&#39;includes&#x2F;header&#x2F;social&#39;)&#125;)</span><br><span class="line">&#x2F;&#x2F;#scroll-down</span><br><span class="line">&#x2F;&#x2F;  i.fas.fa-angle-down.scroll-down-effects</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="topimg-2"><p>版本号等于<code>3.6.0</code></p><p>自带了配置项<code>disable_top_img</code>，设置为<code>true</code>时无首页全屏大图。</p><p>但会发现导航栏的背景颜色变成了白色且带一点透明，文字变成了黑色。这点看上去并不是很美观。所以这里可以将背景颜色修改为透明色，文字修改为白色。</p><p>在<code>sunchaser.styl</code>样式文件中添加以下样式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#page-header</span><br><span class="line">  &amp;.not-<span class="attribute">top</span>-img</span><br><span class="line">    #nav</span><br><span class="line">      <span class="attribute">background</span>: transparent !important</span><br><span class="line">      <span class="attribute">box-shadow</span>: none !important</span><br><span class="line">      a</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#ffffff</span> !important</span><br><span class="line"></span><br><span class="line">#page-header</span><br><span class="line">  &amp;.nav-visible</span><br><span class="line">    #nav</span><br><span class="line">      background: rgba(255, 255, 255, .8) !important</span><br><span class="line">      a</span><br><span class="line">        <span class="attribute">color</span>: var(--font-color) !important</span><br><span class="line"></span><br><span class="line">if hexo-config(&#x27;darkmode.enable&#x27;) || hexo-config(&#x27;display_mode&#x27;) == &#x27;dark&#x27;</span><br><span class="line">  [data-theme=<span class="string">&#x27;dark&#x27;</span>]</span><br><span class="line">    #page-header</span><br><span class="line">      &amp;<span class="selector-class">.not-top-img</span> &gt; #nav</span><br><span class="line">        <span class="attribute">background</span>: transparent !important</span><br><span class="line">        <span class="attribute">box-shadow</span>: none !important</span><br><span class="line">      &amp;<span class="selector-class">.nav-visible</span> &gt; #nav</span><br><span class="line">        background: alpha(#121212, .8) !important</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>关掉首页全屏大图后，会发现整个博客呈现白色背景，如果觉得不够美观，可在<code>_config.butterfly.yml</code>配置文件中将背景修改为图片：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">background:</span> <span class="string">url(https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/lilu.org.cn/index_1.png)</span></span><br></pre></td></tr></table></figure><h2 id="导航栏居左，搜索按钮居右，且加上浅色和深色模式转化的icon"><a href="#导航栏居左，搜索按钮居右，且加上浅色和深色模式转化的icon" class="headerlink" title="导航栏居左，搜索按钮居右，且加上浅色和深色模式转化的icon"></a>导航栏居左，搜索按钮居右，且加上浅色和深色模式转化的<code>icon</code></h2><p>打开<code>/themes/butterfly/layout/includes/header/nav.pug</code>文件，修改为以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  span#blog_name</span><br><span class="line">    a#site-name(href&#x3D;url_for(&#39;&#x2F;&#39;)) #[&#x3D;config.title]</span><br><span class="line">    span#menus</span><br><span class="line">      !&#x3D;fragment_cache(&#39;menus&#39;, function()&#123;return partial(&#39;includes&#x2F;header&#x2F;menu_item&#39;)&#125;)</span><br><span class="line">    #toggle-menu</span><br><span class="line">      a.site-page</span><br><span class="line">        i.fas.fa-bars.fa-fw</span><br><span class="line">    if theme.darkmode.enable &amp;&amp; theme.darkmode.button</span><br><span class="line">      div.button.mode-button#darkmode(type&#x3D;&quot;button&quot; title&#x3D;_p(&#39;rightside.night_mode_title&#39;))</span><br><span class="line">        a.site-page.social-icon</span><br><span class="line">          i.fas.fa-adjust.fa-fw</span><br><span class="line">    if (theme.algolia_search.enable || theme.local_search.enable)</span><br><span class="line">      #search-button</span><br><span class="line">        a.site-page.social-icon.search</span><br><span class="line">          i.fas.fa-search.fa-fw</span><br><span class="line">          span&#x3D;&#39; &#39; + _p(&#39;search&#39;)</span><br></pre></td></tr></table></figure><p>在<code>sunchaser.styl</code>样式文件中添加以下内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#nav</span><br><span class="line">  <span class="selector-id">#search-button</span>,.mode-button</span><br><span class="line">    <span class="attribute">float</span>: right</span><br><span class="line">  &amp;.hide-menu</span><br><span class="line">    #toggle-menu</span><br><span class="line">      <span class="attribute">float</span>: right</span><br><span class="line"></span><br><span class="line">  .mode-button</span><br><span class="line">    <span class="attribute">display</span>: inline</span><br><span class="line">    padding: 0 0 0 .4rem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// icon上的a标签不允许选中</span></span><br><span class="line">    a</span><br><span class="line">      -webkit-user-select: <span class="attribute">none</span>;</span><br><span class="line">      -moz-user-select: <span class="attribute">none</span>;</span><br><span class="line">      -ms-user-select: <span class="attribute">none</span>;</span><br><span class="line">      user-select: <span class="attribute">none</span>;</span><br><span class="line"></span><br><span class="line">[type=button],</span><br><span class="line">[type=reset],</span><br><span class="line">[type=submit],</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  -webkit-appearance: <span class="attribute">none</span> !important</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>sunchaser.js</code>文件中，添加以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;darkmode&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nowMode = <span class="built_in">document</span>.documentElement.getAttribute(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (nowMode === <span class="string">&#x27;light&#x27;</span>) &#123;</span><br><span class="line">        activateDarkMode();</span><br><span class="line">        saveToLocal.set(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        GLOBAL_CONFIG.Snackbar !== <span class="literal">undefined</span> &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activateLightMode();</span><br><span class="line">        saveToLocal.set(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        GLOBAL_CONFIG.Snackbar !== <span class="literal">undefined</span> &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle some cases</span></span><br><span class="line">    <span class="keyword">typeof</span> utterancesTheme === <span class="string">&#x27;function&#x27;</span> &amp;&amp; utterancesTheme();</span><br><span class="line">    <span class="keyword">typeof</span> FB === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="built_in">window</span>.loadFBComment();</span><br><span class="line">    <span class="built_in">window</span>.DISQUS &amp;&amp; <span class="built_in">document</span>.getElementById(<span class="string">&#x27;disqus_thread&#x27;</span>).children.length &amp;&amp; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">window</span>.disqusReset(), <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="浏览器滚动条美化"><a href="#浏览器滚动条美化" class="headerlink" title="浏览器滚动条美化"></a>浏览器滚动条美化</h2><p>在<code>sunchaser.styl</code>文件中添加以下样式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*::-webkit-scrollbar-thumb</span><br><span class="line">  <span class="attribute">background-image</span>: -webkit-linear-gradient( <span class="number">45deg</span>, rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>, transparent <span class="number">25%</span>, transparent <span class="number">50%</span>, rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>, rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>, transparent <span class="number">75%</span>, transparent)</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span></span><br><span class="line"></span><br><span class="line">*::-webkit-scrollbar-corner</span><br><span class="line">  <span class="attribute">background-color</span>: transparent</span><br><span class="line"></span><br><span class="line">*::-moz-selection</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span></span><br><span class="line">  <span class="attribute">background-color</span>: var(--btn-bg)</span><br></pre></td></tr></table></figure><h2 id="优化右侧固定widget在向上滚动过程中被导航栏遮住的情况"><a href="#优化右侧固定widget在向上滚动过程中被导航栏遮住的情况" class="headerlink" title="优化右侧固定widget在向上滚动过程中被导航栏遮住的情况"></a>优化右侧固定<code>widget</code>在向上滚动过程中被导航栏遮住的情况</h2><p>此问题在<code>3.6.0</code>版本已经被修复，低版本可按以下方式修改。</p><div class="tabs" id="widget"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#widget-1">方式一</button></li><li class="tab"><button type="button" data-href="#widget-2">方式二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="widget-1"><p>打开<code>/themes/butterfly/source/css/_layout/aside.styl</code>文件中，找到以下内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.sticky_layout</span><br><span class="line">  +minWidth900()</span><br><span class="line">    <span class="attribute">position</span>: sticky</span><br><span class="line">    <span class="attribute">position</span>: -webkit-sticky</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span></span><br></pre></td></tr></table></figure><p>将<code>top: 20px</code>修改为<code>top: 80px</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="widget-2"><p>在<code>sunchaser.styl</code>样式文件中添加以下内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#aside-<span class="attribute">content</span></span><br><span class="line">  .sticky_layout</span><br><span class="line">    +minWidth900()</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">80px</span> !important</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="侧边栏加入微信公众号图片widget"><a href="#侧边栏加入微信公众号图片widget" class="headerlink" title="侧边栏加入微信公众号图片widget"></a>侧边栏加入微信公众号图片<code>widget</code></h2><p>参考：<a href="https://butterfly.js.org/posts/ea33ab97/">https://butterfly.js.org/posts/ea33ab97/</a></p><p>鼠标放在搜一搜图片上时微小放大特效。在<code>sunchaser.styl</code>样式文件中添加以下内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.aside-img</span><br><span class="line">  <span class="attribute">object-fit</span>: cover</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">7px</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">  transition: all .6s</span><br><span class="line"></span><br><span class="line">  &amp;:hover</span><br><span class="line">    <span class="attribute">box-shadow</span>: none</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">7px</span></span><br><span class="line">    <span class="attribute">transform</span>: scale(<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure><h2 id="在文章详情页底部添加文章结束语和公众号"><a href="#在文章详情页底部添加文章结束语和公众号" class="headerlink" title="在文章详情页底部添加文章结束语和公众号"></a>在文章详情页底部添加文章结束语和公众号</h2><p>在<code>/themes/butterfly/layout/includes/post</code>目录下添加两个文件<code>post-end.pug</code>和<code>post-end-wechat.pug</code>，内容分别为：</p><p><code>post-end.pug</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">  div(style&#x3D;&#39;text-align:center;color: #ccc;font-size:14px;font-family: cursive;&#39;)</span><br><span class="line">    | -------------&amp;#x6709;&amp;#x8FC7;&amp;#x7275;&amp;#x6302;</span><br><span class="line">    i(style&#x3D;&#39;margin:0 7px;&#39;).fa.fa-umbrella</span><br><span class="line">    | &amp;#x4E86;&amp;#x65E0;&amp;#x7275;&amp;#x6302;-------------</span><br></pre></td></tr></table></figure><p><code>post-end-wechat.pug</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#post-end-wechat</span><br><span class="line">  center</span><br><span class="line">    img#wechat-qrcode(src&#x3D;&#96;$&#123;theme.post_end.wechat.cdn_qrcode&#125;&#96; onerror&#x3D;&#96;onerror&#x3D;null;src&#x3D;&#39;$&#123;theme.post_end.wechat.local_default_qrcode&#125;&#39;&#96;,alt&#x3D;&#39;打工这件小事&#39;)</span><br><span class="line">  div&#x3D;theme.post_end.wechat.description</span><br></pre></td></tr></table></figure><p>修改<code>/themes/butterfly/layout/post.pug</code>文件，在<code>include includes/post/post-copyright.pug</code>这一行的上方缩进对齐位置添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if theme.post_end.enable</span><br><span class="line">  include includes&#x2F;post&#x2F;post-end.pug</span><br><span class="line">if theme.post_end.wechat.enable</span><br><span class="line">  include includes&#x2F;post&#x2F;post-end-wechat.pug</span><br></pre></td></tr></table></figure><p>在<code>_config.butterfly.yml</code>配置文件中添加以下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_end:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wechat:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cdn_qrcode:</span> <span class="string">https://i.loli.net/2020/02/15/SDRF87I6ohlyVk1.jpg</span></span><br><span class="line">    <span class="attr">local_default_qrcode:</span> <span class="string">/assets/images/weixin/wechat-gzh.png</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">欢迎关注微信公众号【打工这件小事】～</span></span><br></pre></td></tr></table></figure><p>在<code>sunchaser.styl</code>样式文件中添加以下内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#post-end-wechat</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">  <span class="attribute">display</span>: inline-block</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">36px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto</span><br><span class="line">  </span><br><span class="line">  #wechat-qrcode</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span></span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span></span><br></pre></td></tr></table></figure><h2 id="footer底部作者名字前添加跳动的红心"><a href="#footer底部作者名字前添加跳动的红心" class="headerlink" title="footer底部作者名字前添加跳动的红心"></a><code>footer</code>底部作者名字前添加跳动的红心</h2><p>修改<code>/themes/butterfly/layout/includes/footer.pug</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if theme.footer.owner.since &amp;&amp; theme.footer.owner.since !&#x3D; nowYear</span><br><span class="line">  .copyright!&#x3D; &#96;&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125;&amp;nbsp;&lt;i style&#x3D;&quot;color:#FF6A6A;animation: announ_animation 0.8s linear infinite;&quot;class&#x3D;&quot;fas fa-heart&quot;&gt;&lt;&#x2F;i&gt; By $&#123;config.author&#125;&#96;</span><br><span class="line">else</span><br><span class="line">  .copyright!&#x3D; &#96;&amp;copy;$&#123;nowYear&#125;&amp;nbsp;&lt;i style&#x3D;&quot;color:#FF6A6A;animation: announ_animation 0.8s linear infinite;&quot;class&#x3D;&quot;fas fa-heart&quot;&gt;&lt;&#x2F;i&gt; By $&#123;config.author&#125;&#96;</span><br></pre></td></tr></table></figure><h2 id="添加RSS插件生成atom-xml"><a href="#添加RSS插件生成atom-xml" class="headerlink" title="添加RSS插件生成atom.xml"></a>添加RSS插件生成atom.xml</h2><p>在博客根目录下输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在博客配置文件<code>_config.yml</code>中添加以下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS订阅</span></span><br><span class="line"><span class="attr">plugin:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment"># Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在主题的配置文件<code>_config.butterfly.yml</code>中的<code>social</code>属性下添加<code>rss</code>的<code>icon</code>配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fa fa-rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure><h2 id="生成百度sitemap"><a href="#生成百度sitemap" class="headerlink" title="生成百度sitemap"></a>生成百度sitemap</h2><p>在<code>hexo</code>博客根目录下分别执行以下命令安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>修改博客根目录下<code>_config.yml</code>文件中的<code>url</code>属性为站点自定义域名（不支持<code>github.io</code>）</p><h2 id="sitemap提交"><a href="#sitemap提交" class="headerlink" title="sitemap提交"></a>sitemap提交</h2><h2 id="配置百度主动推送"><a href="#配置百度主动推送" class="headerlink" title="配置百度主动推送"></a>配置百度主动推送</h2><p>在<code>hexo</code>博客根目录下执行以下命令安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>在博客根目录下<code>_config.yml</code>文件中添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment"># 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">lilu.org.cn</span> <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">eNsEfgMEdafegvn</span> <span class="comment"># 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>修改<code>deploy</code>属性，有两个<code>type</code>时前面要加<code>-</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com/sunchaser-lilu/sunchaser-lilu.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><h2 id="添加PDF插件"><a href="#添加PDF插件" class="headerlink" title="添加PDF插件"></a>添加PDF插件</h2><p>此插件可在单页面中全屏打开PDF，效果与打开本地磁盘的PDF文件类似。</p><p>在<code>hexo</code>博客根目录下执行以下命令安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-pdf-plugin@0.0.1-beta --save</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">title: PDF</span><br><span class="line">date: 2021-01-29 16:00:00</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/pdf/the-road-to-code-improvement-from-code-farmers-to-craftsmen.pdf %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌥️Spring Cloud版本概述</title>
      <link href="2021/01/29/microservice/springcloud/spring-cloud-version-overview/"/>
      <url>2021/01/29/microservice/springcloud/spring-cloud-version-overview/</url>
      
        <content type="html"><![CDATA[<p><code>Spring Cloud</code>是一系列微服务解决方案的组合套件。它包含分布式配置中心、服务注册与发现、路由、服务调用、负载均衡、断路器、全局锁、领导选举/集群状态和分布式消息等组件。利用这些组件，我们可以快速地构建出一个分布式系统。</p><h2 id="Spring-Boot版本介绍"><a href="#Spring-Boot版本介绍" class="headerlink" title="Spring Boot版本介绍"></a><code>Spring Boot</code>版本介绍</h2><p>由于<code>Spring Cloud</code>是基于<code>Spring Boot</code>进行构建的，所以在介绍<code>Spring Cloud</code>的版本之前，我们先来看下<code>Spring Boot</code>的版本。</p><p>官网链接：<a href="https://spring.io/projects/spring-boot#learn"><code>https://spring.io/projects/spring-boot#learn</code></a></p><p><code>Spring Boot</code>版本号遵循<code>主版本号.次版本号.增量版本号.里程碑版本号</code>方案：</p><ul><li>主版本号：项目有可能进行重大重构，各主版本之间不一定能兼容。</li><li>次版本号：在主版本架构不变的情况下，加入新特性，保证兼容。</li><li>增量版本号：<code>BUG</code>的修复。</li><li>里程碑版本号：当前的发布版本，主要有以下几类：<ul><li><code>BUILD-SNAPSHOT</code>：开发快照版。</li><li><code>M</code>：<code>Milestone</code>的缩写，里程碑版本。该版本较之前版本在功能上有重大更新，是发布稳定版本的前兆。如<code>M1</code>/<code>M2</code>。</li><li><code>PRE</code>：预览版。不建议使用，可能存在未知<code>BUG</code>。</li><li><code>SNAPSHOT</code>：快照版。可稳定使用，但仍在继续改进功能。</li><li><code>RC</code>：<code>Release Candidate</code>的缩写。候选发布版本。此版本已相当成熟，基本不存在<code>BUG</code>。如<code>RC1</code>/<code>RC2</code>。</li><li><code>RELEASE</code>：最终发行版本。稳定正式版本。</li><li><code>GA</code>：<code>General Availability</code>，正式版本，官方推荐使用此版本。在国外是用<code>GA</code>来标识<code>RELEASE</code>版本。</li></ul></li></ul><p><code>Spring Boot</code>项目所有版本索引地址：<a href="https://docs.spring.io/spring-boot/docs/"><code>https://docs.spring.io/spring-boot/docs/</code></a></p><h2 id="Spring-Cloud版本介绍"><a href="#Spring-Cloud版本介绍" class="headerlink" title="Spring Cloud版本介绍"></a><code>Spring Cloud</code>版本介绍</h2><p>官网链接：<a href="https://spring.io/projects/spring-cloud#learn"><code>https://spring.io/projects/spring-cloud#learn</code></a></p><p>不同于<code>Spring Boot</code>及其它<code>Spring</code>项目的版本命名方式，<code>Spring Cloud</code>项目的版本是根据英国伦敦地铁站的英文名称并按照字母<code>A-Z</code>的顺序进行控制的，例如：<code>A（Angel）</code>、<code>B（Brixton）</code>、<code>C（Camden）</code>、<code>D（Dalston）</code>、<code>E（Edgware）</code>、<code>F（Finchley）</code>、<code>G（Greenwich）</code>和<code>H（Hoxton）</code>等。直到<code>2020</code>年<code>4</code>月<code>16</code>日，<code>Spring Cloud 2020.0.0-M1</code>版本发布，从该版本开始，发布至<code>Maven</code>仓库的版本号将不再使用英国伦敦地铁站方式命名，而是改为全新的“日历化”版本命名方式。</p><blockquote><p>官宣博客：<a href="https://spring.io/blog/2020/04/17/spring-cloud-2020-0-0-m1-released"><code>https://spring.io/blog/2020/04/17/spring-cloud-2020-0-0-m1-released</code></a></p></blockquote><h2 id="“日历化”版本命名方式"><a href="#“日历化”版本命名方式" class="headerlink" title="“日历化”版本命名方式"></a>“日历化”版本命名方式</h2><p>“日历化”版本命名遵循<code>YYYY.MINOR.MICRO</code>方案：</p><ul><li><code>YYYY</code>：代表四位年份。</li><li><code>MINOR</code>：代表一个递增的数字，每年从<code>0</code>开始递增。</li><li><code>MICRO</code>：代表先前使用的版本号后缀，例如<code>.0</code>类似于<code>.RELEASE</code>，<code>.2</code>类似于<code>.SR2</code>。</li></ul><p>预发布版本的后缀分隔符从<code>.</code>变更为<code>-</code>，例如<code>2020.0.0-M1</code>和<code>2020.0.0-RC2</code>；同时快照版本将不再添加<code>BUILD-</code>前缀，例如<code>2020.0.0-SNAPSHOT</code>。</p><p>在<code>Spring Cloud</code>项目中出现了新的里程碑版本号：<code>SR</code>：<code>Service Release</code>的缩写，表示修正版。修正了正式版本推出后发现的<code>BUG</code>。如<code>SR1</code>/<code>SR2</code>。</p><blockquote><p>虽然发布至<code>Maven</code>仓库的版本命名方式发生了变更，但<code>Spring Cloud</code>项目仍然使用英国伦敦地铁站命名方式作为代码名称。当前为<code>Ilford</code>。</p></blockquote><h2 id="如何选择合适的版本"><a href="#如何选择合适的版本" class="headerlink" title="如何选择合适的版本"></a>如何选择合适的版本</h2><p><code>Spring Cloud</code>是基于<code>Spring Boot</code>进行构建的，两者的版本必须相匹配，我们可以参考官网的版本映射。</p><p>官网链接：<a href="https://spring.io/projects/spring-cloud"><code>https://spring.io/projects/spring-cloud</code></a></p><p>下面列出大版本号的对应选择：</p><table><thead><tr><th><code>Release Train</code></th><th><code>Boot Version</code></th></tr></thead><tbody><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes"><code>2020.0.x</code></a>  <code>aka Ilford</code></td><td><code>2.4.x</code></td></tr><tr><td><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td><code>2.2.x, 2.3.x (Starting with SR5)</code></td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td><code>2.1.x</code></td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td><code>2.0.x</code></td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td><code>1.5.x</code></td></tr><tr><td><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td><code>1.5.x</code></td></tr></tbody></table><p>官方提供了一个<code>Actuator</code>端点返回了详细的各小版本号之间的对应关系。可根据自身需要进行更加细粒度的版本选择。</p><p>端点地址为：<a href="https://start.spring.io/actuator/info"><code>https://start.spring.io/actuator/info</code></a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云设计模式之缓存备用模式（Cache-Aside Pattern）</title>
      <link href="2021/01/03/design-patterns/cloud/cache-aside-pattern/"/>
      <url>2021/01/03/design-patterns/cloud/cache-aside-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>作用：将数据按需从数据库加载到缓存中。</p><p>此模式可以提高性能，并能保持缓存和数据库中数据的一致性。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>应用程序使用缓存来优化对数据库中存储信息的重复访问。但是，期望缓存和数据库中的数据完全一致是不切实际的。</p><p>应用程序应该实现一种有助于确保缓存中的数据尽量保持最新，同时当缓存中的数据过期时可以检测和处理的策略。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>很多商业缓存系统提供<code>read-through</code>和<code>write-through/write-behind</code>操作。在这些系统中，应用程序通过引用缓存来检索数据。如果数据不在缓存中，则从数据库中透明地查询数据并将其添加至缓存中；对缓存中保存的数据的任何修改也会自动写回到数据库中。</p><p>对于不提供此功能的缓存，由使用缓存来维护数据的应用程序负责。</p><p>应用程序可以通过实现缓存备用模式来模拟<code>read-through</code>缓存的功能。该模式可根据需要将数据高效地加载到缓存中。下图总结了此过程中的步骤。</p><p><img src="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/images/dn589799.55b56fd8930e405c5bf9580e455a16c1(en-us,pandp.10).png" alt="Cache-Aside Pattern"></p><p>通俗的讲，分为以下步骤：</p><ol><li>先查询缓存，判断缓存是否存在。</li><li>如果缓存不存在，则从数据库中查询。</li><li>然后将数据中查出来的数据设置到缓存中。</li></ol><p>如果应用程序需要修改数据库中的数据，可使用以下<code>write-through</code>策略：</p><ol><li>修改数据库。</li><li>让缓存失效。</li></ol><p>当下一次请求到来时，由于使用了缓存备用模式，将从数据库中查询出最新的数据并将其设置回缓存中。</p><h2 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h2><p>在决定如何实现此模式时，应考虑以下几点：</p><ul><li>缓存数据的生命周期：很多缓存实现了过期策略，如果在指定的时间内未访问缓存数据，缓存会自动失效并进行删除。为了使缓存备用模式高效，请确保过期策略与使用该缓存的应用程序的访问模式相匹配。不要将过期时间设置的太短，否则可能导致应用程序不断从数据库中查询数据并将其添加至缓存中；同样不要设置的太长，以免缓存的数据不是最新的。请记住，对于相对静态的数据或经常读取的数据，使用缓存最有效。</li><li>淘汰数据：即内存淘汰策略。与数据库相比，大多数高速缓存只有有限的内存空间大小，在必要的时候会进行内存淘汰。大多数缓存都使用<code>LRU</code>（最近最少使用）算法来实现，但这可以进行自定义，可配置缓存的全局过期属性以及每个缓存<code>key</code>的过期属性，以帮助缓存具有成本效益。将内存淘汰策略应用于所有缓存<code>key</code>并不总是合适的，例如，如果从数据中查询并添加至缓存中的代价非常昂贵，那么将其保留在缓存中可能是有益的。</li><li>启动缓存：即缓存预热。许多解决方案会在应用程序启动过程中预先加载可能需要的数据至缓存中。如果这部分缓存过期或被淘汰，缓存备用模式仍然有效。</li><li>一致性：实现缓存备用模式并不能保证数据库和缓存之间的数据一致性。数据库中的数据可能在任意时刻被外部修改，并且在下次该数据被加载到缓存中之前，此修改可能不会反映在缓存中。在跨数据存储复制数据的系统中，如果非常频繁的发生同步，则此问题可能会变得特别严重。</li><li>本地缓存：缓存可以存在于应用程序实例的本地内存中，如果应用程序重复访问相同的数据，缓存备用模式会非常有用。但是本地缓存是每个应用程序实例私有的，在分布式系统中，本地缓存之间的数据可能很快变得不一致，我们需要非常频繁的刷新本地缓存并且设置较短的过期时间。在这种情况下，应该考虑使用分布式缓存。</li></ul><h2 id="什么场景使用该模式？"><a href="#什么场景使用该模式？" class="headerlink" title="什么场景使用该模式？"></a>什么场景使用该模式？</h2><p>适用场景：</p><ul><li>缓存系统不提供<code>read-through</code>和<code>write-through</code>操作。</li><li>资源需求无法进行预测。此模式可使应用程序按需加载数据至缓存，它不会预先假设应用程序需要哪些数据。</li></ul><p>不适合使用的场景：</p><ul><li>当缓存的数据为静态的时候，如果缓存空间足够存储数据，请在启动时进行缓存预热，并让其永不过期。</li><li>在<code>Web</code>应用程序中缓存会话状态信息。此场景下应避免引入基于客户端-服务端相似性的依赖关系。</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>在日常开发中，我们一般会使用<code>Redis</code>作为多个应用程序实例之间共享的分布式缓存。以下代码中的<code>selectCacheOrDb</code>方法展示了基于<code>Redis</code>的缓存备用模式的模板方法实现。该方法使用<code>read-through</code>从缓存中读取数据。</p><ul><li>首先从缓存中读取数据；</li><li>如果缓存数据不存在，则从数据库进行查询；</li><li>如果数据库中的数据存在，则将其设置到缓存中，设置一个过期时间，然后返回；</li><li>如果缓存数据存在，则直接返回缓存中的数据；</li><li>整个过程如果出现异常，返回默认值进行降级。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.designpatterns.cloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> com.sunchaser.sparrow.designpatterns.common.model.request.CacheAsideRequest;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAsidePattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectCacheOrDb</span><span class="params">(CacheAsideRequest&lt;T&gt; cacheAsideRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cacheKey = cacheAsideRequest.getCacheKey();</span><br><span class="line">            <span class="comment">// random 防止雪崩</span></span><br><span class="line">            <span class="keyword">int</span> expiredTime = cacheAsideRequest.getExpiredTime() + ThreadLocalRandom.current().nextInt(<span class="number">60</span>);</span><br><span class="line">            TimeUnit timeUnit = cacheAsideRequest.getTimeUnit();</span><br><span class="line">            String cacheValueString = redisTemplate.opsForValue().get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(cacheValueString)) &#123;</span><br><span class="line">                T dbValue = cacheAsideRequest.getDbSelector().get();</span><br><span class="line">                log.info(<span class="string">&quot;cache miss, query db and the db value is: &#123;&#125;&quot;</span>,dbValue);</span><br><span class="line">                <span class="keyword">if</span> (Objects.nonNull(dbValue)) &#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(</span><br><span class="line">                            cacheKey,</span><br><span class="line">                            JSONObject.toJSONString(dbValue),</span><br><span class="line">                            expiredTime,</span><br><span class="line">                            timeUnit</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dbValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T t = JSONObject.parseObject(cacheValueString, <span class="keyword">new</span> TypeReference&lt;T&gt;() &#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;hit cache, the cache value is: &#123;&#125;&quot;</span>,cacheValueString);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;query cache or db error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> cacheAsideRequest.getDefaultValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中方法入参<code>CacheAsideRequest</code>的具体字段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.designpatterns.common.model.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存备用模式请求入参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAsideRequest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cacheKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer expiredTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间的单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DB查询器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;T&gt; dbSelector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生异常进行降级的默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>HashMap</code>模拟一个数据库，当需要查询时，以下代码中的<code>testSelectCacheOrDb</code>方法展示了我们的使用方式，<code>testUpdate</code>方法模拟了数据库的更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.designpatterns.cloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> com.sunchaser.sparrow.designpatterns.common.model.request.CacheAsideRequest;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAsidePatternTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheAsidePattern cacheAsidePattern;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; db = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        db.put(<span class="string">&quot;defaultUser&quot;</span>,<span class="string">&quot;defaultValue&quot;</span>);</span><br><span class="line">        db.put(<span class="string">&quot;user1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        db.put(<span class="string">&quot;user2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        db.put(<span class="string">&quot;user3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">        db.put(<span class="string">&quot;user4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectCacheOrDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheAsideRequest&lt;String&gt; cacheAsideRequest = <span class="keyword">new</span> CacheAsideRequest&lt;&gt;();</span><br><span class="line">        cacheAsideRequest.setCacheKey(<span class="string">&quot;test-key&quot;</span>);</span><br><span class="line">        cacheAsideRequest.setExpiredTime(<span class="number">100</span>);</span><br><span class="line">        cacheAsideRequest.setTimeUnit(TimeUnit.SECONDS);</span><br><span class="line">        cacheAsideRequest.setDbSelector(() -&gt; db.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">        cacheAsideRequest.setDefaultValue(db.get(<span class="string">&quot;defaultUser&quot;</span>));</span><br><span class="line">        String s = cacheAsidePattern.selectCacheOrDb(cacheAsideRequest);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db.put(<span class="string">&quot;user1&quot;</span>,<span class="string">&quot;updateValue1&quot;</span>);</span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;test-key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们在更新数据时，应该先更新数据库，再让缓存失效。这样带来的数据延迟只有一个<code>redis</code>操作的时间。</p><blockquote><p>如果先让缓存失效，后更新数据库。在这两步操作的窗口期间，有很小的可能客户端会先读取到数据库中旧的数据并将其重新设置到缓存中，然后对数据库的更新才正式提交。这会导致缓存中的数据不是最新。</p></blockquote><h2 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h2><p>有时候我们希望对从数据库中查询出的数据进行一定的校验后才决定是否存入缓存。例如查询出的数据包含的字段全部不为零值才进行缓存，或者查询出的数据包含的字段只要有一个为零值就进行缓存。另外一方面，我们从数据库中查询出来的数据可能是一个数据表实体对象，也可能是一个包含数据表实体对象的<code>ArrayList</code>集合，所以我们需要进行分类讨论。对外我们提供一个可选的策略，对内我们兼容单个实体类和集合两种情况。根据数据库查询返回的数据类型执行不同的解析方式，我们利用反射来解析单个对象或集合中的每一个对象的字段是否为零值。</p><blockquote><p>零值：例如<code>Integer</code>的零值为<code>0</code>；<code>Long</code>的零值为<code>0L</code>；<code>Double</code>的零值为<code>0.00</code>等等，还可根据具体的业务场景进行自定义。</p></blockquote><p>下面给出我们的策略枚举类<code>CacheStrategyEnum</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.designpatterns.common.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存策略枚举及策略对应的实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2021/1/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CacheStrategyEnum</span> </span>&#123;</span><br><span class="line">    ALL_NO_ZERO(<span class="string">&quot;ALL_NO_ZERO&quot;</span>,<span class="string">&quot;全部字段不为零则进行缓存&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">analysisList</span><span class="params">(List&lt;?&gt; list)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Object el : list) &#123;</span><br><span class="line">                <span class="comment">// 获取包含父类super的所有字段</span></span><br><span class="line">                Field[] allFields = getAllFields(el);</span><br><span class="line">                <span class="keyword">for</span> (Field field : allFields) &#123;</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// 只要有一个字段为零，返回false</span></span><br><span class="line">                    <span class="keyword">if</span> (analysisZero(field.get(el))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">analysisCustomObject</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">            Field[] allFields = getAllFields(object);</span><br><span class="line">            <span class="keyword">for</span> (Field field : allFields) &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 只要有一个字段为零，返回false</span></span><br><span class="line">                <span class="keyword">if</span> (analysisZero(field.get(object))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ANY_NO_ZERO(<span class="string">&quot;ANY_NO_ZERO&quot;</span>,<span class="string">&quot;任意一个字段不为零则进行缓存&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">analysisList</span><span class="params">(List&lt;?&gt; list)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Object el : list) &#123;</span><br><span class="line">                <span class="comment">// 获取包含父类super的所有字段</span></span><br><span class="line">                Field[] allFields = getAllFields(el);</span><br><span class="line">                <span class="keyword">for</span> (Field field : allFields) &#123;</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// 任意一个字段不为零，返回true</span></span><br><span class="line">                    <span class="keyword">if</span> (!analysisZero(field.get(el))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">analysisCustomObject</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">            Field[] allFields = getAllFields(object);</span><br><span class="line">            <span class="keyword">for</span> (Field field : allFields) &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 任意一个字段不为零，返回true</span></span><br><span class="line">                <span class="keyword">if</span> (!analysisZero(field.get(object))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flyweight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,CacheStrategyEnum&gt; enumMap = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (CacheStrategyEnum cacheStrategyEnum : CacheStrategyEnum.values())</span><br><span class="line">            enumMap.put(cacheStrategyEnum.strategy,cacheStrategyEnum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheStrategyEnum <span class="title">getEnumByStrategy</span><span class="params">(String strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumMap.get(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheStrategyEnum(String strategy, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法：解析List中的自定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list list对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> false：不进行缓存；true：进行缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException 上层进行异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">analysisList</span><span class="params">(List&lt;?&gt; list)</span> <span class="keyword">throws</span> IllegalAccessException </span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法：解析自定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 待解析的自定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> false：不进行缓存；true：进行缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException 上层进行异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">analysisCustomObject</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IllegalAccessException </span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析字段是否为零值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 待解析字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：为零值；false：不为零。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">analysisZero</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Long) o == <span class="number">0L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer) o == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Double) o == <span class="number">0.00</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// do other biz zero</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取包含super父类的所有字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 需要获取字段的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象的所有字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Field[] getAllFields(Object object) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = object.getClass();</span><br><span class="line">        List&lt;Field&gt; fieldList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fieldList.addAll(Lists.newArrayList(clazz.getDeclaredFields()));</span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        Field[] fields = <span class="keyword">new</span> Field[fieldList.size()];</span><br><span class="line">        fieldList.toArray(fields);</span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们需要在模板方法的入参<code>CacheAsideRequest</code>中添加该枚举字段。同时模板方法<code>selectCacheOrDb</code>的实现也要做对应修改，具体可看以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectCacheOrDb</span><span class="params">(CacheAsideRequest&lt;T&gt; cacheAsideRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String cacheKey = cacheAsideRequest.getCacheKey();</span><br><span class="line">        <span class="comment">// random 防止雪崩</span></span><br><span class="line">        <span class="keyword">int</span> expiredTime = cacheAsideRequest.getExpiredTime() + ThreadLocalRandom.current().nextInt(<span class="number">60</span>);</span><br><span class="line">        TimeUnit timeUnit = cacheAsideRequest.getTimeUnit();</span><br><span class="line">        CacheStrategyEnum cacheStrategyEnum = cacheAsideRequest.getCacheStrategyEnum();</span><br><span class="line">        String cacheValueString = redisTemplate.opsForValue().get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(cacheValueString)) &#123;</span><br><span class="line">            T dbValue = cacheAsideRequest.getDbSelector().get();</span><br><span class="line">            log.info(<span class="string">&quot;cache miss, query db and the db value is: &#123;&#125;&quot;</span>,dbValue);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(dbValue)) &#123;</span><br><span class="line">                <span class="comment">// flag的含义：false：不进行缓存；true：进行缓存。</span></span><br><span class="line">                <span class="keyword">boolean</span> flag;</span><br><span class="line">                <span class="comment">// 解析List中的每一个对象的零值</span></span><br><span class="line">                <span class="keyword">if</span> (dbValue <span class="keyword">instanceof</span> List) flag = cacheStrategyEnum.analysisList((List&lt;?&gt;) dbValue);</span><br><span class="line">                <span class="comment">// 解析单个对象的零值</span></span><br><span class="line">                <span class="keyword">else</span> flag = cacheStrategyEnum.analysisCustomObject(dbValue);</span><br><span class="line">                <span class="keyword">if</span> (flag) redisTemplate.opsForValue().set(</span><br><span class="line">                        cacheKey,</span><br><span class="line">                        JSONObject.toJSONString(dbValue),</span><br><span class="line">                        expiredTime,</span><br><span class="line">                        timeUnit</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dbValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T t = JSONObject.parseObject(cacheValueString, <span class="keyword">new</span> TypeReference&lt;T&gt;() &#123;&#125;);</span><br><span class="line">            log.info(<span class="string">&quot;hit cache, the cache value is: &#123;&#125;&quot;</span>,cacheValueString);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;query cache or db error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cacheAsideRequest.getDefaultValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了云设计模式之缓存备用模式的基本概念和原理，然后使用了一个较为通用的模板方法实现了缓存备用模式，最后我们还对模板方法中一些可能出现的业务细节进行了扩展，这对现有的业务系统是一个很好的实现参考。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589799(v=pandp.10)">https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589799(v=pandp.10)</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 云设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 云设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-链表标签：回文链表</title>
      <link href="2021/01/03/algorithm/leetcode/tag/linkedlist/palindrome-linked-list/"/>
      <url>2021/01/03/algorithm/leetcode/tag/linkedlist/palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<p>题目：请判断一个单向链表是否为回文链表。</p><p><code>Leetcode</code>在线<code>OJ</code>系统：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">传送门</a></p><p>示例<code>1</code>：</p><pre class="mermaid">graph LRA[1]-->B[2]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例<code>2</code>:</p><pre class="mermaid">graph LRA[1]-->B[2]B[2]-->C[2]C[2]-->D[1]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>思路：</p><p>首先需要知道什么是“回文”：回文指的是无论正向还是反向读，得到的结果一致。由于单向链表的特点，如果我们直接读原链表，则只能正向读取，无法进行判断。所以我们需要进行一定的转化。</p><p>转换方式一：将整个单向链表映射到一个数组中，然后使用两个指针分别从数组两端开始遍历，当遇到数值不相等的节点时，可断定为非回文链表，如果遍历到两个节点相遇时都未发现数值不相等的节点，则为回文链表。</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><p><code>Java</code>语言实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">    List&lt;SinglyLinkedListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = list.size();i &lt; size / <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list.get(i).val.equals(list.get(size - i - <span class="number">1</span>).val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的空间复杂度为<code>O(n)</code>，时间复杂度为<code>O(n + n/2) = O(n)</code>。</p><p>转换方式二：不使用额外空间，我们在原链表上做文章，如果一个单向链表为回文链表，我们可以先将前半段链表进行反转，然后再使用两个指针<code>p1</code>和<code>p2</code>，<code>p1</code>从头部开始，<code>p2</code>从中间开始，遍历链表，当遇到数值不相等的节点，可断定为非回文链表；如果<code>p2</code>遍历到尾部都还未遇到数值不相等的节点，则为回文链表。</p><p>如何将前半段链表进行反转？可利用一快一慢两个指针先找到中间节点，然后将从头节点开始到中间节点的这一部分进行反转。</p><p><code>Java</code>语言实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeUseReverse</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    SinglyLinkedListNode fast = head;</span><br><span class="line">    SinglyLinkedListNode slow = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时，慢指针指向中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转从头节点到中间节点之间的部分</span></span><br><span class="line">    SinglyLinkedListNode p1 = head;</span><br><span class="line">    SinglyLinkedListNode p2 = slow;</span><br><span class="line">    SinglyLinkedListNode pre = slow;</span><br><span class="line">    SinglyLinkedListNode next;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        next = p1.next;</span><br><span class="line">        p1.next = pre;</span><br><span class="line">        pre = p1;</span><br><span class="line">        p1 = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原链接节点个数为奇数，则中间节点p2（slow）需要右移一位才能进行回文比较</span></span><br><span class="line">    <span class="comment">// 例如：1-&gt;2-&gt;3-&gt;2-&gt;1；反转前半部分后为：2-&gt;1-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">// p2指向中间节点3，需要右移一位指向2，才能进行回文比较</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) p2 = p2.next;</span><br><span class="line">    <span class="comment">// 此时pre指向新链表的头节点</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre.val.equals(p2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方式的时间复杂度为：<code>O(n + n/2 + n/2) = O(n)</code>，空间复杂度为<code>O(1)</code>。</p><p>缺点是改变了原链表的结构，但可在判断出是否为回文链表后再次反转前半部分节点，从而恢复原链表的结构。</p><p>方式二的优化版本：使用快慢指针寻找中间节点的过程中慢指针已经遍历了前半部分链表，可就在这一次的遍历中进行反转。</p><p>优化后的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeUseReverseOptimization</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SinglyLinkedListNode fast = head;</span><br><span class="line">    SinglyLinkedListNode slow = head;</span><br><span class="line">    SinglyLinkedListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    SinglyLinkedListNode next;</span><br><span class="line">    <span class="comment">// 慢指针移动的同时进行反转</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        next = slow.next;</span><br><span class="line">        slow.next = pre;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) slow = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pre.val.equals(slow.val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的时间复杂度为：<code>O(n/2 + n/2) = O(n)</code>，空间复杂度为<code>O(1)</code>。但仍然破坏了原链表的结构，同样地，可再次反转链表前半部分进行恢复。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx安装与卸载</title>
      <link href="2021/01/01/ops/nginx/install-nginx/"/>
      <url>2021/01/01/ops/nginx/install-nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx安装的两种方式"><a href="#Nginx安装的两种方式" class="headerlink" title="Nginx安装的两种方式"></a><code>Nginx</code>安装的两种方式</h2><h3 id="方式一：yum源安装"><a href="#方式一：yum源安装" class="headerlink" title="方式一：yum源安装"></a>方式一：<code>yum</code>源安装</h3><p>我们使用<code>Nginx</code>官方的<code>yum</code>源。可去 <a href="http://nginx.org/en/linux_packages.html">http://nginx.org/en/linux_packages.html</a> 查看主线版和稳定版的<code>yum</code>源，一般我们会使用稳定版本。</p><p>首先需要添加<code>nginx</code>官方的<code>yum</code>源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo</span><br></pre></td></tr></table></figure><p>然后<code>vim</code>编辑该<code>repo</code>文件添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name&#x3D;nginx repo</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure><p>保存后使用以下命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>安装完成后使用以下命令启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;systemctl start nginx.service</span><br></pre></td></tr></table></figure><h3 id="方式二：源码编译安装"><a href="#方式二：源码编译安装" class="headerlink" title="方式二：源码编译安装"></a>方式二：源码编译安装</h3><h2 id="安装gcc库"><a href="#安装gcc库" class="headerlink" title="安装gcc库"></a>安装<code>gcc</code>库</h2><p><code>nginx</code>使用<code>c</code>语言编写，源码编译方式需要安装<code>gcc</code>编译器。一般阿里云等云服务器商都会自带<code>gcc</code>，如果用的是虚拟机，可以先检查是否已安装。</p><p>使用命令<code>gcc -v</code>可查看版本信息，如果提示命令找不到，则需要执行<code>yum -y install gcc</code>安装<code>gcc</code>。</p><h2 id="pcre、pcre-devel安装"><a href="#pcre、pcre-devel安装" class="headerlink" title="pcre、pcre-devel安装"></a><code>pcre</code>、<code>pcre-devel</code>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p><code>pcre</code>是一个<code>perl</code>库，包括<code>perl</code>兼容的正则表达式库，<code>nginx</code>的<code>http</code>模块使用<code>pcre</code>来解析正则表达式，所以需要进行安装。</p><h2 id="zlib安装"><a href="#zlib安装" class="headerlink" title="zlib安装"></a><code>zlib</code>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p><code>zlib</code>库提供了多种压缩和解压缩的方式，<code>nginx</code>使用<code>zlib</code>对<code>http</code>包的内容进行<code>gzip</code>压缩，所以需要安装。</p><h2 id="openssl安装"><a href="#openssl安装" class="headerlink" title="openssl安装"></a><code>openssl</code>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p>可用来加密<code>https</code>协议。</p><h2 id="下载Nginx源码包"><a href="#下载Nginx源码包" class="headerlink" title="下载Nginx源码包"></a>下载<code>Nginx</code>源码包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure><p>可以去<a href="http://nginx.org/download/"><code>http://nginx.org/download/</code></a>页面查看更多版本信息，选择稳定版本下载即可。</p><h2 id="解压并编译安装"><a href="#解压并编译安装" class="headerlink" title="解压并编译安装"></a>解压并编译安装</h2><p>解压至当前目录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure><p>解压完成后进入<code>nginx</code>目录：<code>cd nginx-1.18.0</code></p><p>设置<code>nginx</code>的安装路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;nginx</span><br></pre></td></tr></table></figure><p><code>--prefix</code>表示将<code>nginx</code>安装至<code>/opt/nginx</code>目录下。</p><p>最后一步，进行编译和安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure><p>启动<code>nginx</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;opt&#x2F;nginx&#x2F;sbin&#x2F;nginx .&#x2F;nginx</span><br></pre></td></tr></table></figure><h2 id="访问nginx首页"><a href="#访问nginx首页" class="headerlink" title="访问nginx首页"></a>访问<code>nginx</code>首页</h2><p>直接访问云服务器的公网<code>ip</code>即可。</p><p>如果是阿里云服务器，需要去阿里云控制台添加<code>80</code>端口至该主机的安全组入网方向。</p><h2 id="卸载已安装的Nginx"><a href="#卸载已安装的Nginx" class="headerlink" title="卸载已安装的Nginx"></a>卸载已安装的<code>Nginx</code></h2><p>首先需要停止<code>Nginx</code>服务：<code>/bin/systemctl stop nginx.service</code></p><p>如果是使用<code>yum</code>源安装的，可使用命令<code>find / -name nginx*</code>查看<code>nginx</code>相关文件，先手动删除一些源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line">rm -rf &#x2F;etc&#x2F;nginx</span><br></pre></td></tr></table></figure><p>再使用<code>yum remove nginx</code>清理。</p><p>如果是源码包编译安装的，先停止服务，然后删除整个安装目录即可。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-链表标签：合并两个有序链表</title>
      <link href="2020/12/29/algorithm/leetcode/tag/linkedlist/merge-two-sorted-lists/"/>
      <url>2020/12/29/algorithm/leetcode/tag/linkedlist/merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<p>题目：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：</p><pre class="mermaid">graph LRA[1]-->B[2]B[2]-->C[4]</pre><pre class="mermaid">graph LRA[1]-->B[3]B[3]-->C[4]</pre><p>输出：</p><pre class="mermaid">graph LRA[1]-->B[1]B[1]-->C[2]C[2]-->D[3]D[3]-->E[4]E[4]-->F[4]</pre><p>思路：</p><p>已知条件：两个链表的头节点<code>l1</code>和<code>l2</code>。</p><p>对于两个升序链表，它们的长度不一定相等，当我们把较短的链表合并完成后，直接连接较长链表的剩余部分即可。</p><p>我们并不知道哪一个的头节点值更小，所以需要分类讨论。</p><p>递归法：</p><p>我们可以用如下的公式定义我们的递归<code>merge</code>操作：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/leetcode/merge-two-sorted-lists-formula.png" alt="merge-two-sorted-lists-formula.png"></p><p>判断<code>l1</code>和<code>l2</code>哪一个链表的头节点值较小，将较小的那个节点的下一个节点与另一个链表进行递归<code>merge</code>。</p><p>递归的出口：如果递归到<code>l1[0]</code>或<code>l2[0]</code>为<code>null</code>时，直接返回另外一个链表。另外一个链表可能也为<code>null</code>（如果原链表长度相等），或者非<code>null</code>（原链表长度不等）。</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><p><code>Java</code>语言实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SinglyLinkedListNode <span class="title">mergeTwoSortedLinkedListRecursionImpl</span><span class="params">(SinglyLinkedListNode l1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                         SinglyLinkedListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoSortedLinkedListRecursionImpl(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoSortedLinkedListRecursionImpl(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法：</p><p>正所谓所有的递归都可以转化成迭代。</p><p>由于待合并的两个链表都有序，合并后的头节点要么是<code>l1</code>要么是<code>l2</code>。如果我们不希望修改原来的链表，就需要构造出一个新链表，顺序连接两个原链表的各个节点。</p><p>首先，我们创建一个哨兵节点<code>hair</code>，然后维护一个<code>cur</code>指针，每次使用<code>cur</code>指针去连接各个节点。我们依次比较<code>l1</code>和<code>l2</code>节点的值，如果<code>l1</code>的值小于<code>l2</code>，则用<code>cur</code>连接<code>l1</code>，然后<code>l1</code>右移；否则，用<code>cur</code>连接<code>l2</code>，然后<code>l2</code>右移。直到<code>l1</code>或者<code>l2</code>为<code>null</code>，将另一个节点的剩余节点连接至<code>cur</code>，然后再返回<code>hair.next</code>，即为合并后链表的新头节点。</p><blockquote><p>哨兵节点<code>hair</code>：指针域<code>next</code>指向的节点即为合并后的链表的头节点。</p></blockquote><p><code>Java</code>语言实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SinglyLinkedListNode <span class="title">mergeTwoSortedLinkedList</span><span class="params">(SinglyLinkedListNode l1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            SinglyLinkedListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    SinglyLinkedListNode hair = <span class="keyword">new</span> SinglyLinkedListNode();</span><br><span class="line">    SinglyLinkedListNode cur = hair;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) cur.next = l1;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-链表标签：删除中间节点</title>
      <link href="2020/12/27/algorithm/leetcode/tag/linkedlist/delete-middle-node-lcci/"/>
      <url>2020/12/27/algorithm/leetcode/tag/linkedlist/delete-middle-node-lcci/</url>
      
        <content type="html"><![CDATA[<p>题目：实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p><p>示例：</p><pre class="mermaid">graph LRA[a]-->B[b]B[b]-->C[c]C[c]-->D[d]D[d]-->E[e]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：节点c</span><br><span class="line">结果：不返回任何数据，将节点c从原链表中删除。</span><br></pre></td></tr></table></figure><p>思路：这题的思路有点意思。首先我们只能访问到节点<code>c</code>，按照常规思路，如果我们要删除节点<code>c</code>，就要将<code>c</code>的上一个节点<code>b</code>指向<code>c</code>的下一个节点<code>d</code>，但我们只能访问节点<code>c</code>和<code>d</code>，由于单向链表的特性，节点<code>b</code>我们是无法访问的。那我们该如何“神不知鬼不觉”的删除节点<code>c</code>呢？</p><p>“偷天换日”：我们的目标是让<code>b</code>指向<code>d</code>，但我们无法直接操作<code>b</code>，而<code>b</code>又一直指向<code>c</code>，所以我们只需要把<code>c</code>替换为<code>d</code>，然后再把<code>d</code>删除即可。</p><blockquote><p>删不掉我自己(<code>c</code>)，我就变成你(<code>d</code>)，再删掉你(<code>d</code>)，就等于删掉我自己(<code>c</code>)。</p></blockquote><p><code>Java</code>语言实现如下：</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(SinglyLinkedListNode node)</span> </span>&#123;</span><br><span class="line">    SinglyLinkedListNode next = node.next;</span><br><span class="line">    node.val = next.val;</span><br><span class="line">    node.next = next.next;</span><br><span class="line">    next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-链表标签：返回倒数第k个节点</title>
      <link href="2020/12/23/algorithm/leetcode/tag/linkedlist/kth-node-from-end-of-list-lcci/"/>
      <url>2020/12/23/algorithm/leetcode/tag/linkedlist/kth-node-from-end-of-list-lcci/</url>
      
        <content type="html"><![CDATA[<p>题目：实现一种算法，找出单向链表中倒数第<code>k</code>个节点。返回该节点的值。</p><p><code>Leetcode</code>在线<code>OJ</code>系统：<a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/">传送门</a></p><p>示例：</p><pre class="mermaid">graph LRA[1]-->B[2]B[2]-->C[3]C[3]-->D[4]D[4]-->E[5]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><blockquote><p>说明：给定的 k 保证是有效的。</p></blockquote><p>思路：双指针法。定义两个指针<code>first</code>和<code>second</code>，<code>first</code>指针先走<code>k - 1</code>步，然后<code>second</code>指针和<code>first</code>指针同时走，每次走一步，当<code>first</code>指针到达链表末尾时，<code>second</code>指针指向的节点即为倒数第<code>k</code>个节点。</p><p><code>Java</code>语言实现如下：</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(SinglyLinkedListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SinglyLinkedListNode first = head;</span><br><span class="line">    SinglyLinkedListNode second = head;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 长度不足k</span></span><br><span class="line">        <span class="keyword">if</span> (first.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second.val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之链表-判断链表是否有环</title>
      <link href="2020/12/22/algorithm/base/datastructure/link-has-cycle/"/>
      <url>2020/12/22/algorithm/base/datastructure/link-has-cycle/</url>
      
        <content type="html"><![CDATA[<p>题目：判断给定的链表中是否有环。如果有环则返回<code>true</code>，否则返回<code>false</code>。你能给出空间复杂度<code>O(1)</code>的解法么？</p><p><code>Leetcode</code>在线<code>OJ</code>系统：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">传送门</a></p><p>示例<code>1</code>：</p><pre class="mermaid">graph LRA[3]-->B[2]B[2]-->C[0]C[0]-->D[-4]D[-4]-->B[2]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，由 -4 指向 2 </span><br></pre></td></tr></table></figure><p>示例<code>2</code>:</p><pre class="mermaid">graph LRA[1]-->B[2]B[2]-->A[1]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：&#96;true&#96;</span><br><span class="line">解释：链表中有一个环，由 2 指向 1 </span><br></pre></td></tr></table></figure><p>示例<code>3</code>：</p><pre class="mermaid">graph LRA[1]</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：&#96;false&#96;</span><br><span class="line">解释：链表中没有环</span><br></pre></td></tr></table></figure><p>思路：将链表想象成校园里的操场，两位同学从同一起点开始比赛跑步，出发后，如果两位同学的跑步速度不一致，那么跑过若干圈后，他们一定会在跑道的某处相遇，且跑的快的同学恰好比跑的慢的同学多跑一圈。这是物理运动学上的经典追击问题。</p><p>对于链表来说，我们可以定义一快一慢两个指针，让它们同时从头节点同时出发，快指针每次走两步，慢指针每次走一步，如果它们最终能在某处“相遇”，说明链表有环，如果快指针走到链表末尾都没有追上走的慢的指针，说明链表无环。</p><p>以上的思路俗称：“快慢指针法”；学名：<code>Floyd</code>判圈算法。</p><blockquote><p><code>Floyd</code>判圈算法（<code>Floyd Cycle Detection Algorithm</code>），又称龟兔赛跑算法(<code>Tortoise and Hare Algorithm</code>),是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，以及判断环的起点与长度的算法。</p></blockquote><p><code>Java</code>语言实现如下：</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SinglyLinkedListNode fast = head;</span><br><span class="line">    SinglyLinkedListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手实现Lombok</title>
      <link href="2020/12/19/javaee/lombok/impl-simple-lombok/"/>
      <url>2020/12/19/javaee/lombok/impl-simple-lombok/</url>
      
        <content type="html"><![CDATA[<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a><code>Javac</code>编译器</h2><p>提到编译器，可能很多后端研发工程师只是在脑海中有一个模糊的概念，我也是这样，因为业务开发中几乎使用不到。我们都工作在编译器的上层。</p><p>对于<code>Java</code>语言来说，它的整个编译期是不确定的过程，我们写的<code>.java</code>类文件需要被编译成<code>.class</code>字节码文件然后加载至虚拟机中，<code>.class</code>字节码文件需要被编译成机器码进行执行，当然也有直接将<code>.java</code>类文件编译成机器码的编译器。</p><p><code>Javac</code>编译器是一个将<code>.java</code>文件编译成<code>.class</code>字节码的编译器，它可以在不改变底层虚拟机的情况下对程序编码进行编译期的优化，即：语法糖。</p><p>从<code>sun</code>公司提供的<code>Javac</code>编译器代码（源码在<code>JDK</code>的<code>tool.jar</code>包中）实现来看，编译的过程可分为以下三个阶段：</p><ul><li><code>Parse and Enter</code>：解析与填充符号表，编译器会将<code>Java</code>文件解析成<code>Abstract Syntax Tree</code>（<code>AST</code>）抽象语法树，这个过程会校验语法的正确性等。</li><li><code>Annotation Processing</code>：插入式注解处理器的注解处理，这个过程可以对语法树进行相关操作。</li><li><code>Analyse and Generate</code>：分析语法树与字节码生成。</li></ul><p>在<code>JDK5</code>后，<code>Java</code>语言引入了注解，这些注解与普通的<code>Java</code>类一样，是在运行期间发挥作用的。<code>JDK6</code>实现了<code>JSR-269</code>规范，提供出一组插入式注解处理器的标准<code>API</code>在编译期间对注解进行处理，我们可以把它看作是一组编译器的插件，或者称为钩子，我们可以使用这些<code>API</code>对第一阶段产生的语法树进行修改，一旦语法树被修改，编译器将会回到第一阶段重新解析与填充符号表，直到所有的插入式注解处理器都没有再对语法树进行修改为止，每一次回到第一阶段称为一次<code>Round</code>。</p><p><code>Javac</code>编译器的源码是<code>com.sun.tools.javac.main.JavaCompiler</code>类，编译的方法是<code>com.sun.tools.javac.main.JavaCompiler#compile</code>，其中插入注解处理器的初始化过程是在<code>this.initProcessAnnotations(var3);</code>方法中完成的；执行过程是在<code>com.sun.tools.javac.main.JavaCompiler#processAnnotations</code>方法中完成的，该方法中判断是否还有新的注解处理器需要执行，如果有的话，通过<code>com.sun.tools.javac.processing.JavacProcessingEnvironment#doProcessing</code>方法得到一个新的<code>JavaCompiler</code>类对象继续后续的处理。</p><h2 id="Lombok的原理"><a href="#Lombok的原理" class="headerlink" title="Lombok的原理"></a><code>Lombok</code>的原理</h2><p><code>Lombok</code>正是利用<code>Javac</code>编译器的第二阶段进行实现的，使用的也正是<code>JDK6</code>提供的<code>JSR-269</code>实现。在编译期操作语法树，实现字节码的动态生成。</p><h2 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h2><p>我们要实现的是一个简易的<code>Lombok</code>，一个注解在编译期同时生成<code>getter</code>和<code>setter</code>方法。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>首先要定义一个注解<code>@GetterAndSetter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GetterAndSetter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义注解处理器"><a href="#自定义注解处理器" class="headerlink" title="自定义注解处理器"></a>自定义注解处理器</h3><p>然后定义一个处理<code>@GetterAndSetter</code>注解的处理器<code>GetterAndSetterProcessor</code>，所有的处理器都建议去继承<code>javax.annotation.processing.AbstractProcessor</code>抽象类，它提供了一些基本实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.auto.service.AutoService;</span><br><span class="line"><span class="keyword">import</span> com.sun.source.util.Trees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"><span class="keyword">import</span> org.sunchaser.lombok.impl.annotation.GetterAndSetter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"><span class="keyword">import</span> javax.tools.Diagnostic;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义<span class="doctag">@GetterAndSetter</span>注解的插入处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;&quot;org.sunchaser.lombok.impl.annotation.GetterAndSetter&quot;&#125;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterAndSetterProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可将Element转换成JCTree，组成AST语法树。使用Trees.instance(processingEnv);进行初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Trees trees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造JCTree的工具类。使用TreeMaker.instance(((JavacProcessingEnvironment) processingEnv).getContext());初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeMaker treeMaker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名字处理工具类。使用Names.instance(context);进行初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Names names;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译期的日志打印工具类。使用processingEnv.getMessager();进行初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init 初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processingEnv 环境：提供一些Javac的执行工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        <span class="keyword">this</span>.messager = processingEnv.getMessager();</span><br><span class="line">        <span class="keyword">this</span>.trees = Trees.instance(processingEnv);</span><br><span class="line">        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="keyword">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">        <span class="keyword">this</span>.names = Names.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotations   注解集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roundEnv      执行round环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE,<span class="string">&quot;roundEnv ---&gt;&quot;</span> + roundEnv);</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            <span class="comment">// 所有@GetterAndSetter注解标注的类</span></span><br><span class="line">            Set&lt;? extends Element&gt; annotated = roundEnv.getElementsAnnotatedWith(GetterAndSetter.class);</span><br><span class="line">            annotated.forEach(element -&gt; &#123;</span><br><span class="line">                <span class="comment">// 获得当前遍历类的语法树</span></span><br><span class="line">                JCTree tree = (JCTree) trees.getTree(element);</span><br><span class="line">                <span class="comment">// 使用GetterAndSetterTreeTranslator处理</span></span><br><span class="line">                tree.accept(<span class="keyword">new</span> GetterAndSetterTreeTranslator(treeMaker, names, messager));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回true：Javac编译器会从编译期的第二阶段回到第一阶段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前处理器支持的注解类型集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * JDK7后可用注解<span class="doctag">@SupportedAnnotationTypes</span>代替该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注解类全限定类名字符串的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取支持的JDK版本</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * JDK7后可用注解<span class="doctag">@SupportedSourceVersion</span>代替该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JDK版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解处理器的实现细节"><a href="#注解处理器的实现细节" class="headerlink" title="注解处理器的实现细节"></a>注解处理器的实现细节</h3><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>我们来看下子类中实现的主要方法：</p><h5 id="init-ProcessingEnvironment-processingEnv"><a href="#init-ProcessingEnvironment-processingEnv" class="headerlink" title="init(ProcessingEnvironment processingEnv)"></a><code>init(ProcessingEnvironment processingEnv)</code></h5><p>初始化方法，在父抽象类中对入参<code>ProcessingEnvironment</code>对象进行了初始化，我们可以通过这个对象得到很多工具类，例如<code>Trees</code>、<code>TreeMaker</code>和<code>Names</code>等等。</p><h5 id="process"><a href="#process" class="headerlink" title="process"></a><code>process</code></h5><p>父类中的抽象方法，子类进行具体的处理实现。输入参数<code>RoundEnvironment</code>代表每一次<code>Round</code>的环境。</p><h5 id="getSupportedAnnotationTypes"><a href="#getSupportedAnnotationTypes" class="headerlink" title="getSupportedAnnotationTypes"></a><code>getSupportedAnnotationTypes</code></h5><p>指定当前处理器是用来处理哪个注解的，返回值是需要处理的注解的全限定类名字符串的集合。在<code>JDK7</code>后，父抽象类基于<code>@SupportedAnnotationTypes</code>注解进行了实现，子类中可不重写该方法，直接使用注解：<code>@SupportedAnnotationTypes(&#123;&quot;org.sunchaser.lombok.impl.annotation.GetterAndSetter&quot;&#125;)</code>即可。</p><h5 id="getSupportedSourceVersion"><a href="#getSupportedSourceVersion" class="headerlink" title="getSupportedSourceVersion"></a><code>getSupportedSourceVersion</code></h5><p>指定支持的<code>JDK</code>版本，这里通常返回<code>SourceVersion.latestSupported()</code>最新版本。在<code>JDK7</code>后，父抽象类基于<code>@SupportedSourceVersion</code>注解进行了实现，子类中可不重新进行实现，直接使用注解：<code>@SupportedSourceVersion(SourceVersion.RELEASE_8)</code>即可。</p><h4 id="工具类介绍"><a href="#工具类介绍" class="headerlink" title="工具类介绍"></a>工具类介绍</h4><p>下面介绍一下<code>init</code>方法中初始化的一些工具类：</p><h5 id="javax-annotation-processing-Messager"><a href="#javax-annotation-processing-Messager" class="headerlink" title="javax.annotation.processing.Messager"></a><code>javax.annotation.processing.Messager</code></h5><p>编译期的日志打印工具类。使用<code>processingEnv.getMessager();</code>进行初始化。</p><h5 id="javax-lang-model-element-Element"><a href="#javax-lang-model-element-Element" class="headerlink" title="javax.lang.model.element.Element"></a><code>javax.lang.model.element.Element</code></h5><p>对一个<code>.java</code>文件结构的建模。一个<code>Java</code>类被划分为各个<code>Element</code>，每个部分都有对应的子类实现。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser;                  <span class="comment">/** PackageElement      **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;                      <span class="comment">/** TypeElement         **/</span></span><br><span class="line">    <span class="keyword">private</span> String str;                 <span class="comment">/** VariableElement     **/</span></span><br><span class="line">    <span class="keyword">private</span> Foo foo;                    <span class="comment">/** VariableElement     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;                     <span class="comment">/** ExecuteableElement  **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String str                      <span class="comment">/** TypeElement         **/</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;                 <span class="comment">/** ExecuteableElement  **/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="com-sun-source-util-Trees"><a href="#com-sun-source-util-Trees" class="headerlink" title="com.sun.source.util.Trees"></a><code>com.sun.source.util.Trees</code></h5><p>可将<code>Element</code>转换成<code>JCTree</code>，组成<code>AST</code>语法树。使用<code>Trees.instance(processingEnv);</code>进行初始化。</p><h5 id="com-sun-tools-javac-tree-TreeMaker"><a href="#com-sun-tools-javac-tree-TreeMaker" class="headerlink" title="com.sun.tools.javac.tree.TreeMaker"></a><code>com.sun.tools.javac.tree.TreeMaker</code></h5><p>构造<code>JCTree</code>的工具类。使用<code>TreeMaker.instance(((JavacProcessingEnvironment) processingEnv).getContext());</code>进行初始化。</p><h5 id="com-sun-tools-javac-util-Names"><a href="#com-sun-tools-javac-util-Names" class="headerlink" title="com.sun.tools.javac.util.Names"></a><code>com.sun.tools.javac.util.Names</code></h5><p>名字处理工具类。使用<code>Names.instance(context);</code>进行初始化。无论是类、方法、变量或者参数的名称都需要此类来创建，常用形式为<code>names.fromString(&quot;setNameXXX&quot;)</code>。</p><h5 id="com-sun-tools-javac-util-List"><a href="#com-sun-tools-javac-util-List" class="headerlink" title="com.sun.tools.javac.util.List"></a><code>com.sun.tools.javac.util.List</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">A</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">List</span>&lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A head;</span><br><span class="line">    <span class="keyword">public</span> List&lt;A&gt; tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** nil()方法返回的空集合 **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;?&gt; EMPTY_LIST = <span class="keyword">new</span> List&lt;Object&gt;((Object)<span class="keyword">null</span>, (List)<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">setTail</span><span class="params">(List&lt;Object&gt; var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">nil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 以下是一系列重载的of方法，用来创建List **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">of</span><span class="params">(A var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List(var0, nil());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">of</span><span class="params">(A var0, A var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List(var0, of(var1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">of</span><span class="params">(A var0, A var1, A var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List(var0, of(var1, var2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">of</span><span class="params">(A var0, A var1, A var2, A... var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> List(var0, <span class="keyword">new</span> List(var1, <span class="keyword">new</span> List(var2, from(var3))));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这套抽象语法树的实现中，所有的<code>List</code>都使用的是<code>com.sun.tools.javac.util.List</code>，而不是<code>java.util.ArrayList</code>。这是一个链式<code>List</code>，尾节点为集合。常用的方法有<code>List.nil()</code>和<code>List.of()</code>。</p><h4 id="JCTree介绍"><a href="#JCTree介绍" class="headerlink" title="JCTree介绍"></a><code>JCTree</code>介绍</h4><p><code>JCTree</code>是语法树元素的基类，包含一个重要的字段<code>pos</code>，该字段用来指明当前语法树节点<code>JCTree</code>在语法树中的位置。<code>com.sun.tools.javac.tree.JCTree</code>是一个抽象类，且子类的构造函数都是<code>protected</code>的，所以不能直接使用<code>new</code>关键字创建语法树元素节点，而是使用访问者设计模式进行创建。</p><p>下面介绍几个重要的子类：</p><ul><li><code>com.sun.tools.javac.tree.JCTree.JCStatement</code>：声明语法树节点，仍然是一个抽象类，下面是常用子类：<ul><li><code>com.sun.tools.javac.tree.JCTree.JCBlock</code>：语句块语法树节点。</li><li><code>com.sun.tools.javac.tree.JCTree.JCReturn</code>：<code>return</code>语句语法树节点。</li><li><code>com.sun.tools.javac.tree.JCTree.JCClassDecl</code>：类定义语法树节点。</li><li><code>com.sun.tools.javac.tree.JCTree.JCVariableDecl</code>：字段/变量定义语法树节点。</li></ul></li><li><code>com.sun.tools.javac.tree.JCTree.JCMethodDecl</code>：方法定义语法树节点。</li><li><code>com.sun.tools.javac.tree.JCTree.JCModifiers</code>：访问标志语法树节点。</li><li><code>com.sun.tools.javac.tree.JCTree.JCExpression</code>：表达式语法树节点，仍然是一个抽象类，下面是常用子类：<ul><li><code>com.sun.tools.javac.tree.JCTree.JCAssign</code>：赋值语句语法树节点。</li><li><code>com.sun.tools.javac.tree.JCTree.JCIdent</code>：标志符语法树节点，可以是变量、类型和关键字等等。</li></ul></li></ul><h4 id="TreeMaker介绍"><a href="#TreeMaker介绍" class="headerlink" title="TreeMaker介绍"></a><code>TreeMaker</code>介绍</h4><p><code>TreeMaker</code>用于创建一系列的语法树节点，上面说到创建<code>JCTree</code>语法树节点不能直接使用<code>new</code>关键字创建，所以才有了<code>TreeMaker</code>工具类，它会在创建时为<code>JCTree</code>对象设置<code>pos</code>字段，必须使用上下文相关的<code>TreeMaker</code>对象来创建语法树节点。</p><p>下面介绍几个常用方法：</p><h5 id="TreeMaker-Modifiers"><a href="#TreeMaker-Modifiers" class="headerlink" title="TreeMaker.Modifiers"></a><code>TreeMaker.Modifiers</code></h5><p>用于创建访问标志的语法树节点<code>JCModifiers</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JCModifiers <span class="title">Modifiers</span><span class="params">(<span class="keyword">long</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Modifiers(flags, List.nil());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建访问标志的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flags         访问标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotations   注解列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCModifiers <span class="title">Modifiers</span><span class="params">(<span class="keyword">long</span> flags, List&lt;JCAnnotation&gt; annotations)</span> </span>&#123;</span><br><span class="line">    JCModifiers tree = <span class="keyword">new</span> JCModifiers(flags, annotations);</span><br><span class="line">    <span class="keyword">boolean</span> noFlags = (flags &amp; <span class="number">8796093033983L</span>) == <span class="number">0L</span>;</span><br><span class="line">    tree.pos = noFlags &amp;&amp; annotations.isEmpty() ? -<span class="number">1</span> : <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>flags</code>可以使用枚举类<code>com.sun.tools.javac.code.Flags</code>，例如<code>treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL)</code>创建的语法树节点为：<code>public static final</code>。</p><h5 id="TreeMaker-ClassDef"><a href="#TreeMaker-ClassDef" class="headerlink" title="TreeMaker.ClassDef"></a><code>TreeMaker.ClassDef</code></h5><p>用于创建类定义的语法树节点<code>JCClassDecl</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建类定义的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modifiers     访问标识，可通过treeMaker.Modifiers创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name          类名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeParameter 泛型参数列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extending     父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> implementing  实现的接口集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defs          类定义的详细语句，包括字段、方法的定义等等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCClassDecl <span class="title">ClassDef</span><span class="params">(JCModifiers modifiers,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Name name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;JCTypeParameter&gt; typeParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">                            JCExpression extending,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;JCExpression&gt; implementing,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;JCTree&gt; defs)</span> </span>&#123;</span><br><span class="line">    JCClassDecl tree = <span class="keyword">new</span> JCClassDecl(modifiers, name, typeParameter, extending, implementing, defs, (ClassSymbol)<span class="keyword">null</span>);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-VarDef"><a href="#TreeMaker-VarDef" class="headerlink" title="TreeMaker.VarDef"></a><code>TreeMaker.VarDef</code></h5><p>用于创建字段/变量定义的语法树节点<code>JCVariableDecl</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建字段/变量定义的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modifiers 访问标志，可通过treeMaker.Modifiers创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name      字段/变量名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> varType   字段/变量类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> init      字段/变量初始化语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCVariableDecl <span class="title">VarDef</span><span class="params">(JCModifiers modifiers,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Name name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            JCExpression varType,</span></span></span><br><span class="line"><span class="function"><span class="params">                            JCExpression init)</span> </span>&#123;</span><br><span class="line">    JCVariableDecl tree = <span class="keyword">new</span> JCVariableDecl(modifiers, name, varType, init, (VarSymbol)<span class="keyword">null</span>);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-Ident"><a href="#TreeMaker-Ident" class="headerlink" title="TreeMaker.Ident"></a><code>TreeMaker.Ident</code></h5><p>用于创建标识符的语法树节点<code>JCIdent</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建标识符的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name  标识符名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCIdent <span class="title">Ident</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">    JCIdent tree = <span class="keyword">new</span> JCIdent(name, (Symbol)<span class="keyword">null</span>);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-Return"><a href="#TreeMaker-Return" class="headerlink" title="TreeMaker.Return"></a><code>TreeMaker.Return</code></h5><p>用于创建<code>return</code>语句的语法树节点<code>JCReturn</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建`return`语句的语法树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCReturn <span class="title">Return</span><span class="params">(JCExpression ex)</span> </span>&#123;</span><br><span class="line">    JCReturn tree = <span class="keyword">new</span> JCReturn(ex);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-Apply"><a href="#TreeMaker-Apply" class="headerlink" title="TreeMaker.Apply"></a><code>TreeMaker.Apply</code></h5><p>用于创建方法调用的语法树节点<code>JCMethodInvocation</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建方法调用的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> argsTypes 参数类型列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn        方法调用语句</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args      方法参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCMethodInvocation <span class="title">Apply</span><span class="params">(List&lt;JCExpression&gt; argsTypes, JCExpression fn, List&lt;JCExpression&gt; args)</span> </span>&#123;</span><br><span class="line">    JCMethodInvocation tree = <span class="keyword">new</span> JCMethodInvocation(argsTypes, fn, args);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-Select"><a href="#TreeMaker-Select" class="headerlink" title="TreeMaker.Select"></a><code>TreeMaker.Select</code></h5><p>用于创建域访问/方法访问的语法树节点<code>JCFieldAccess</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建域访问/方法访问的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selected  . 运算符左边的表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> selector  . 运算符右边的表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCFieldAccess <span class="title">Select</span><span class="params">(JCExpression selected, Name selector)</span> </span>&#123;</span><br><span class="line">    JCFieldAccess tree = <span class="keyword">new</span> JCFieldAccess(selected, selector, (Symbol)<span class="keyword">null</span>);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-Assign"><a href="#TreeMaker-Assign" class="headerlink" title="TreeMaker.Assign"></a><code>TreeMaker.Assign</code></h5><p>用于创建赋值语句的语法树节点<code>JCAssign</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建赋值语句的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leftEx    赋值语句左边的表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rightEx   赋值语句右边的表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCAssign <span class="title">Assign</span><span class="params">(JCExpression leftEx, JCExpression rightEx)</span> </span>&#123;</span><br><span class="line">    JCAssign tree = <span class="keyword">new</span> JCAssign(leftEx, rightEx);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-Exec"><a href="#TreeMaker-Exec" class="headerlink" title="TreeMaker.Exec"></a><code>TreeMaker.Exec</code></h5><p>用于创建可执行语句的语法树节点<code>JCExpressionStatement</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建可执行语句的语法树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCExpressionStatement <span class="title">Exec</span><span class="params">(JCExpression ex)</span> </span>&#123;</span><br><span class="line">    JCExpressionStatement tree = <span class="keyword">new</span> JCExpressionStatement(ex);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>TreeMaker.Apply</code>和<code>TreeMaker.Assign</code>需要在外面包一层<code>TreeMaker.Exec</code>来获取一个可执行语句<code>JCExpressionStatement</code>。</p></blockquote><h5 id="TreeMaker-Block"><a href="#TreeMaker-Block" class="headerlink" title="TreeMaker.Block"></a><code>TreeMaker.Block</code></h5><p>用于创建组合语句的语法树节点<code>JCExpressionStatement</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建组合语句的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flags         访问标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> statements    语句列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCBlock <span class="title">Block</span><span class="params">(<span class="keyword">long</span> flags, List&lt;JCStatement&gt; statements)</span> </span>&#123;</span><br><span class="line">    JCBlock tree = <span class="keyword">new</span> JCBlock(flags, statements);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TreeMaker-MethodDef"><a href="#TreeMaker-MethodDef" class="headerlink" title="TreeMaker.MethodDef"></a><code>TreeMaker.MethodDef</code></h5><p>用于创建方法定义的语法树节点<code>JCMethodDecl</code>，主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建方法定义的语法树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modifiers         访问标志，可通过treeMaker.Modifiers创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name              方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType        返回类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeParameters    泛型参数列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params            参数列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> throwns           异常声明列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodBody        方法体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue      默认方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCMethodDecl <span class="title">MethodDef</span><span class="params">(JCModifiers modifiers,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Name name,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCExpression returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;JCTypeParameter&gt; typeParameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;JCVariableDecl&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;JCExpression&gt; throwns,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCBlock methodBody,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCExpression defaultValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.MethodDef(modifiers, name, returnType, typeParameters, (JCVariableDecl)<span class="keyword">null</span>, params, throwns, methodBody, defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> JCMethodDecl <span class="title">MethodDef</span><span class="params">(JCModifiers modifiers,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Name name,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCExpression returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;JCTypeParameter&gt; typeParameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCVariableDecl variable,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;JCVariableDecl&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;JCExpression&gt; throwns,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCBlock methodBody,</span></span></span><br><span class="line"><span class="function"><span class="params">                              JCExpression defaultValue)</span> </span>&#123;</span><br><span class="line">    JCMethodDecl tree = <span class="keyword">new</span> JCMethodDecl(modifiers, name, returnType, typeParameters, variable, params, throwns, methodBody, defaultValue, (MethodSymbol)<span class="keyword">null</span>);</span><br><span class="line">    tree.pos = <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="process执行"><a href="#process执行" class="headerlink" title="process执行"></a><code>process</code>执行</h4><p>下面详细介绍<code>process</code>方法中的具体处理逻辑：</p><p>首先要知道<code>process</code>方法如果返回了<code>true</code>，那么<code>Javac</code>编译器会从编译期的第二阶段回到第一阶段：即重新回到解析与填充符号表阶段。</p><p>处理逻辑：如果<code>!roundEnv.processingOver()</code>还未<code>process</code>完成，则找到所有<code>@GetterAndSetter</code>注解标注的类，依次遍历获得每个类的语法树，然后交给自定义的<code>org.sunchaser.lombok.impl.process.GetterAndSetterTreeTranslator</code>类进行处理，全部处理完成后返回<code>true</code>以便回到编译的第一阶段。</p><p>下面是<code>GetterAndSetterTreeTranslator</code>类中具体操作语法树插入<code>getter</code>和<code>setter</code>方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.tools.javac.tree.JCTree.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AST树访问处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaserlilu@didiglobal.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2020/12/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterAndSetterTreeTranslator</span> <span class="keyword">extends</span> <span class="title">TreeTranslator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造JCTree的工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMaker treeMaker;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名字处理工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Names names;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译期的日志打印工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetterAndSetterTreeTranslator</span><span class="params">(TreeMaker treeMaker, Names names, Messager messager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.treeMaker = treeMaker;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">        <span class="keyword">this</span>.messager = messager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问到类定义时的处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jcClassDecl 类定义的抽象语法树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitClassDef</span><span class="params">(JCClassDecl jcClassDecl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitClassDef(jcClassDecl);</span><br><span class="line">        jcClassDecl.defs.forEach(def -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (def.getKind().equals(Kind.VARIABLE)) &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE,def + <span class="string">&quot;----processed&quot;</span>);</span><br><span class="line">                <span class="comment">// 插入getter方法</span></span><br><span class="line">                jcClassDecl.defs = jcClassDecl.defs.prepend(createGetterMethod((JCVariableDecl) def));</span><br><span class="line">                <span class="comment">// 插入setter方法</span></span><br><span class="line">                jcClassDecl.defs = jcClassDecl.defs.prepend(createSetterMethod((JCVariableDecl) def));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建getter方法的语法树节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> def 变量节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> getter方法的语法树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JCTree <span class="title">createGetterMethod</span><span class="params">(JCVariableDecl def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> treeMaker.MethodDef(</span><br><span class="line">                <span class="comment">// 访问修饰符</span></span><br><span class="line">                treeMaker.Modifiers(Flags.PUBLIC),</span><br><span class="line">                <span class="comment">// 方法名</span></span><br><span class="line">                names.fromString(<span class="string">&quot;get&quot;</span> + <span class="keyword">this</span>.toFirstUpperCase(def.getName().toString())),</span><br><span class="line">                <span class="comment">// 方法返回类型</span></span><br><span class="line">                (JCExpression) def.getType(),</span><br><span class="line">                <span class="comment">// 泛型参数</span></span><br><span class="line">                List.nil(),</span><br><span class="line">                <span class="comment">// 方法参数列表</span></span><br><span class="line">                List.nil(),</span><br><span class="line">                <span class="comment">// throw表达式</span></span><br><span class="line">                List.nil(),</span><br><span class="line">                <span class="comment">// 方法体</span></span><br><span class="line">                treeMaker.Block(<span class="number">0L</span>,List.of(</span><br><span class="line">                        treeMaker.Return(</span><br><span class="line">                                treeMaker.Select(</span><br><span class="line">                                        treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)),</span><br><span class="line">                                        names.fromString(def.getName().toString())</span><br><span class="line">                                )</span><br><span class="line">                        )</span><br><span class="line">                )),</span><br><span class="line">                <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建setter方法的语法树节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> def 变量节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> setter方法的语法树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JCTree <span class="title">createSetterMethod</span><span class="params">(JCVariableDecl def)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造方法入参</span></span><br><span class="line">        JCVariableDecl param = treeMaker.VarDef(treeMaker.Modifiers(Flags.PARAMETER), def.getName(), def.vartype, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 构造 this.def = def</span></span><br><span class="line">        JCFieldAccess thisX = treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)), def.getName());</span><br><span class="line">        JCAssign assign = treeMaker.Assign(thisX, treeMaker.Ident(def.getName()));</span><br><span class="line">        <span class="comment">// 构造方法体</span></span><br><span class="line">        JCBlock methodBody = treeMaker.Block(<span class="number">0L</span>, List.of(treeMaker.Exec(assign)));</span><br><span class="line">        <span class="comment">// 构造方法返回类型</span></span><br><span class="line">        JCExpression returnType = treeMaker.Type(<span class="keyword">new</span> Type.JCVoidType());</span><br><span class="line">        <span class="comment">// 构造setter方法</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.MethodDef(</span><br><span class="line">                <span class="comment">// 访问修饰符</span></span><br><span class="line">                treeMaker.Modifiers(Flags.PUBLIC),</span><br><span class="line">                <span class="comment">// 方法名</span></span><br><span class="line">                names.fromString(<span class="string">&quot;set&quot;</span> + <span class="keyword">this</span>.toFirstUpperCase(def.getName().toString())),</span><br><span class="line">                <span class="comment">// 方法返回类型</span></span><br><span class="line">                returnType,</span><br><span class="line">                <span class="comment">// 泛型参数</span></span><br><span class="line">                List.nil(),</span><br><span class="line">                <span class="comment">// 方法参数列表</span></span><br><span class="line">                List.of(param),</span><br><span class="line">                <span class="comment">// throw表达式</span></span><br><span class="line">                List.nil(),</span><br><span class="line">                <span class="comment">// 方法体</span></span><br><span class="line">                methodBody,</span><br><span class="line">                <span class="comment">// 默认值</span></span><br><span class="line">                <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工具方法：将字符串首位转为大写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 首位大写的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toFirstUpperCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        charArray[<span class="number">0</span>] -= <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个简易<code>Lombok</code>的功能就实现了，但是还无法正常使用，我们需要把我们的插入注解处理器类<code>GetterAndSetterProcessor</code>使用<code>SPI</code>的形式提供给外部使用。</p><h3 id="SPI实现"><a href="#SPI实现" class="headerlink" title="SPI实现"></a><code>SPI</code>实现</h3><p>实现方式一：</p><p>手动在<code>resources</code>目录下创建<code>META-INF/services</code>目录，然后在<code>services</code>目录下创建<code>javax.annotation.processing.Processor</code>文件，文件内容为插入注解处理器类<code>GetterAndSetterProcessor</code>的全限定类名。</p><p>实现方式二：</p><p>使用<code>google</code>提供的<code>auto-service</code>框架，该框架也是基于插入注解处理器实现的。其<code>maven</code>坐标为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.auto.service&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;auto-service&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-rc7&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在我们自定义的插入注解处理器类<code>GetterAndSetterProcessor</code>上打上<code>auto-service</code>框架提供的<code>@AutoService(Processor.class)</code>注解，在编译后即自动生成<code>target/classes/META-INF/services/javax.annotation.processing.Processor</code>文件。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们无法在插入注解处理器类<code>GetterAndSetterProcessor</code>所在的<code>maven</code>模块进行测试，因为该处理器是使用<code>SPI</code>对外提供服务的，所以我们需要新建一个<code>maven</code>子模块，然后引入插入注解处理器<code>GetterAndSetterProcessor</code>类所在的<code>maven</code>模块的坐标，然后才可以使用我们自定义的注解，简单测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.sunchaser.lombok.impl.annotation.GetterAndSetter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意此类跟GetterAndSetterProcessor不在同一个maven模块中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2020/12/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetterAndSetter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainSetterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>main</code>方法即可。</p><p>可看到<code>Build Output</code>中有如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java: roundEnv ---&gt;[errorRaised&#x3D;false, rootElements&#x3D;[com.sunchaser.lomboktest.ChainSetterTest], processingOver&#x3D;false]</span><br><span class="line">java: private String name----processed</span><br><span class="line">java: roundEnv ---&gt;[errorRaised&#x3D;false, rootElements&#x3D;[], processingOver&#x3D;true]</span><br></pre></td></tr></table></figure><p>打开<code>target/classes/com/sunchaser/lomboktest/ChainSetterTest.class</code>字节码文件，可看到已生成字段<code>name</code>的<code>getName</code>和<code>setName</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sunchaser.lomboktest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainSetterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChainSetterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们就基本实现了一个简易的<code>Lombok</code>。</p><p>但是我留下了一个疑问，<code>setter</code>方法如何生成链式的，貌似我没有找到对应的<code>API</code>，<code>Lombok</code>是通过另一个注解<code>@Accessors(chain = true)</code>来实现链式<code>setter</code>方法的，为什么它不直接在<code>@Setter</code>注解中设置一个属性用来控制生成的<code>setter</code>方法是否为链式的？看<code>Lombok</code>的源码并未看懂这部分的实现，网上也没有找到对应资料，如果有同行研究过这个问题可留言进行交流，十分感谢！</p>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个冷门Lombok注解与Spring的结合</title>
      <link href="2020/12/14/javaee/lombok/lombok-combine-spring-di/"/>
      <url>2020/12/14/javaee/lombok/lombok-combine-spring-di/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>说到<code>Lombok</code>，大部分人可能都停留在<code>@Data</code>注解可以同时生成<code>getter/setter</code>、<code>toString</code>、<code>equals</code>和<code>hashCode</code>等方法；<code>@NoArgsConstructor/@AllArgsConstructor</code>可以生成无参和全参构造器。确实<code>Lombok</code>的设计初衷也是为了生成代码。</p><p>有些人因为需要安装插件而拒绝了<code>Lombok</code>，觉得这样会要求团队内所有成员都安装插件。诚然，这是一个还说得过去的理由。但是这并不足以让我们拒绝<code>Lombok</code>。<code>Lombok</code>所做的事情是在改变<code>Java</code>，有些人觉得它改变了<code>Java</code>语法是破坏了<code>Java</code>，那有没有想过，也许<code>Java</code>一直以来的设计就是不好的存在呢？业务系统中出现的无数<code>getter/setter</code>方法，动辄几百行的实体类，阅读体验真的好吗？<code>Lombok</code>是在改变<code>Java</code>，我们只不过是在拥抱变化。<code>Spring Boot</code>已经把<code>Lombok</code>加入预定义依赖中了；<code>Apache ShardingSphere</code>的开发规范中明确要求优先使用<code>Lombok</code>代替构造器、<code>getter/setter</code>方法和<code>log</code>变量；就连<code>Java14</code>也借鉴了<code>Lombok</code>思想提出了<code>record</code>语法。我们为什么还要去拒绝<code>Lombok</code>呢？</p><p>所以，从今天起，开始拥抱<code>Lombok</code>吧！</p><h2 id="一个冷门注解：-RequiredArgsConstructor"><a href="#一个冷门注解：-RequiredArgsConstructor" class="headerlink" title="一个冷门注解：@RequiredArgsConstructor"></a>一个冷门注解：<code>@RequiredArgsConstructor</code></h2><p>很多人都知道<code>@RequiredArgsConstructor</code>这个注解，但是却从未使用过。如果你也一样，那就得好好看看我这篇文章了，看完之后也许你就会发现新的大陆！</p><h2 id="Spring的依赖注入"><a href="#Spring的依赖注入" class="headerlink" title="Spring的依赖注入"></a><code>Spring</code>的依赖注入</h2><p>故事还得从<code>Spring</code>的依赖注入开始说起…</p><p>依赖注入的两大变体：</p><ul><li>构造函数注入</li><li><code>setter</code>方法注入</li></ul><p>但是现在业务开发中却很少使用这两种依赖注入方式，而是使用<code>@Autowired</code>注解进行自动装配。不管是业务层<code>Service</code>还是仓储层<code>MyBatis</code>框架的<code>Mapper</code>或者其它等等，业务代码写起来大概是下面这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAService iaService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IBService ibService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ICService icService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AMapper aMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BMapper bMapper;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do business</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的<code>@Autowired</code>字段少则三五个，多则一二十个。而且在<code>IDEA</code>中，<code>XXXService</code>上面的<code>@Autowired</code>注解会有一条黄色的下划线：<code>Field injection is not recommended </code>；对于<code>XXXMapper</code>类来说，变量名还会有一条红色的下划线：<code>Could not autowire. No beans of &#39;XXXMapper&#39; type found.</code>，虽然运行起来不会报错，但这样的警告和报错着实让人看起来很不舒服。</p><p>有人说可以用<code>@Resource</code>注解来代替<code>@Autowired</code>，这样就不会出现警告和报错了。诚然，这样做可以解决问题，<code>@Resource</code>默认优先按<code>beanName</code>自动注入，<code>@Autowired</code>默认优先按<code>beanType</code>自动注入。这是解决问题的一种方式。</p><blockquote><p><code>@Resource</code>注解是<code>JSR-250</code>规范提供的注解，而<code>@Autowired</code>注解是<code>Spring</code>提供的。这点不足以称为暇疵。</p></blockquote><h2 id="Lombok的优雅"><a href="#Lombok的优雅" class="headerlink" title="Lombok的优雅"></a><code>Lombok</code>的优雅</h2><p>如何使用<code>Lombok</code>来解决这个问题？</p><p>我们关注一下构造函数注入的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IAService iaService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBService ibService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICService icService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AMapper aMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BMapper bMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorService</span><span class="params">(IAService iaService, IBService ibService, ICService icService, AMapper aMapper, BMapper bMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iaService = iaService;</span><br><span class="line">        <span class="keyword">this</span>.ibService = ibService;</span><br><span class="line">        <span class="keyword">this</span>.icService = icService;</span><br><span class="line">        <span class="keyword">this</span>.aMapper = aMapper;</span><br><span class="line">        <span class="keyword">this</span>.bMapper = bMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它要求成员变量是<code>final</code>类型，同时构造函数上的<code>@Autowired</code>是可选的。</p><p>而<code>@RequiredArgsConstructor</code>刚好是为被声明为final的字段生成构造器的注解。</p><p>于是我们的写法就变得优（<code>zhuang</code>）雅（<code>bi</code>）起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IAService iaService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBService ibService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICService icService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AMapper aMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BMapper bMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do business</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样编译后的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IAService iaService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBService ibService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICService icService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AMapper aMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BMapper bMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LombokService</span><span class="params">(IAService iaService, IBService ibService, ICService icService, AMapper aMapper, BMapper bMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iaService = iaService;</span><br><span class="line">        <span class="keyword">this</span>.ibService = ibService;</span><br><span class="line">        <span class="keyword">this</span>.icService = icService;</span><br><span class="line">        <span class="keyword">this</span>.aMapper = aMapper;</span><br><span class="line">        <span class="keyword">this</span>.bMapper = bMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是标准的<code>Spring</code>构造函数注入方式吗？甚至我们还可以把<code>@Autowired</code>注解给加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @_(@Autowired))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IAService iaService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBService ibService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICService icService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AMapper aMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BMapper bMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do business</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样编译后的构造函数上就会加上<code>@Autowired</code>注解。</p><p><code>onConstructor = @_(@Autowired)</code>中间的<code>@_</code>还可以继续加下划线<code>_</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @______________________________(@Autowired))</span></span><br></pre></td></tr></table></figure><p>即使你像上面这样写，代码也不会报错，能正常运行。</p><p>这样我们就只用写一个注解就可以完成任意多个属性的注入，<code>Lombok</code>就是这么优（<code>zhuang</code>）雅（<code>bi</code>）！所以请尽情地拥抱<code>Lombok</code>吧！</p>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok必知必会</title>
      <link href="2020/12/13/javaee/lombok/lombok-base/"/>
      <url>2020/12/13/javaee/lombok/lombok-base/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p><a href="https://www.projectlombok.org/"><code>ProjectLombok</code>官网</a> 介绍：<code>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</code></p></blockquote><p>永远不要再写另一个<code>getter</code>或者<code>equals</code>方法，一个注解就可以让你的类有一个功能全面的生成器，自动化你的日志变量等等。</p><p>在业务开发中，我们不可避免的需要去定义数据库表的实体<code>Entity</code>类、中间数据传输对象<code>DTO</code>类、前端视图对象<code>VO</code>类等，这些类有一个共同的特点就是都会有很多很多的业务字段，承载着系统的业务数据。基于面向对象的封装性，类中的字段会被定义成<code>private</code>，然后提供出<code>public</code>的<code>getter</code>和<code>setter</code>方法暴露给外部操作。于是代码中就出现了一大片一大片的使用<code>IDE</code>生成的<code>getter</code>和<code>setter</code>方法。</p><p><code>Lombok</code>要解决的问题就是去消除这些模版式的<code>getter</code>和<code>setter</code>方法。当然还有一些其它的模版式的代码也可以使用<code>Lombok</code>来消除。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>引入<code>Maven</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你是第一次使用<code>Lombok</code>，还需要在<code>IDE</code>上安装<code>Lombok</code>的插件。（插件的安装方式请自行谷歌）</p><blockquote><p>如果是<code>Spring Boot</code>项目，<code>Spring Boot 2.1.x</code>版本的<code>parent</code>中默认已经预定义了<code>Lombok</code>的依赖，直接引入<code>Maven</code>坐标即可。</p></blockquote><h3 id="Getter和-Setter"><a href="#Getter和-Setter" class="headerlink" title="@Getter和@Setter"></a><code>@Getter</code>和<code>@Setter</code></h3><p>这两个注解可以单独写在某些字段上，也可以写在类上。编译后会在字节码文件中加入相应字段的<code>getter</code>和<code>setter</code>方法。</p><p>单独写在类上的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterAndSetterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String getField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String setField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter(AccessLevel.PROTECTED)</span></span><br><span class="line">    <span class="keyword">private</span> String otherField;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Getter</code>注解会生成对应字段的<code>getter</code>方法，<code>@Setter</code>注解会生成对应字段的<code>setter</code>方法，可同时作用于同一个字段，还可以定义生成的方法的访问修饰符，例如<code>@Setter(AccessLevel.PROTECTED)</code>生成的<code>setter</code>方法就是<code>protected</code>级别的。</p><blockquote><p>需要注意的是，如果字段被声明成<code>final</code>类型，<code>@Setter</code>注解不会为其生成对应的<code>setter</code>方法。</p></blockquote><p>编译后的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterAndSetterTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String getField;</span><br><span class="line">    <span class="keyword">private</span> String setField;</span><br><span class="line">    <span class="keyword">private</span> String otherField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetterAndSetterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGetField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSetField</span><span class="params">(String setField)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setField = setField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOtherField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.otherField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setOtherField</span><span class="params">(String otherField)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.otherField = otherField;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.fs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想细粒度的控制到每个字段，可以直接在类上添加<code>@Getter</code>和<code>Setter</code>注解，会为所有的字段生成<code>getter</code>和<code>setter</code>方法。</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a><code>@ToString</code></h3><p>我们经常会去重写<code>Object#toString()</code>方法以便在控制台输出时打印的是类的基本信息而不是十六进制的地址值。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString(exclude = &#123;&quot;id&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ToString(callSuper = true,includeFieldNames = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> Integer gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ToString</code>注解会生成一个<code>toString()</code>方法，默认输出类名，所有字段的名称和值。可以使用注解的<code>exclude</code>属性来排除某些字段；还可以设置<code>includeFieldNames = false</code>屏蔽所有字段名称的输出；如果字段存在基类，可以设置<code>callSuper = true</code>来输出基类中的字段。</p><p>编译后生成的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> ToStringTest.UserInfo userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToStringTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ToStringTest(address=&quot;</span> + <span class="keyword">this</span>.address + <span class="string">&quot;, userInfo=&quot;</span> + <span class="keyword">this</span>.userInfo + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">ToStringTest</span>.<span class="title">BaseInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> Integer gender;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ToStringTest.UserInfo(super=&quot;</span> + <span class="keyword">super</span>.toString() + <span class="string">&quot;, &quot;</span> + <span class="keyword">this</span>.age + <span class="string">&quot;, &quot;</span> + <span class="keyword">this</span>.gender + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BaseInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ToStringTest.BaseInfo(username=&quot;</span> + <span class="keyword">this</span>.username + <span class="string">&quot;, password=&quot;</span> + <span class="keyword">this</span>.password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a><code>@EqualsAndHashCode</code></h3><p>自定义类对象进行相等比较时一般需要重写<code>equals()</code>方法，同时最好也重写<code>hashCode()</code>方法。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(exclude = &#123;&quot;ex&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsAndHashCodeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String equal;</span><br><span class="line">    <span class="keyword">private</span> String hc;</span><br><span class="line">    <span class="keyword">transient</span> String tr;</span><br><span class="line">    <span class="keyword">private</span> String ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，会使用所有非静态<code>non-static</code>和非瞬态<code>non-transient</code>的字段来生成<code>equals()</code>和<code>hashCode()</code>方法。类似地，可以使用<code>exclude</code>属性来排除某些字段；如果存在基类，也可以使用<code>callSuper = true</code>来囊括基类中的字段。</p><p>编译后生成的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsAndHashCodeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String equal;</span><br><span class="line">    <span class="keyword">private</span> String hc;</span><br><span class="line">    <span class="keyword">transient</span> String tr;</span><br><span class="line">    <span class="keyword">private</span> String ex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualsAndHashCodeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> EqualsAndHashCodeTest)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            EqualsAndHashCodeTest other = (EqualsAndHashCodeTest)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object <span class="keyword">this</span>$equal = <span class="keyword">this</span>.equal;</span><br><span class="line">                Object other$equal = other.equal;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$equal == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$equal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$equal.equals(other$equal)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object <span class="keyword">this</span>$hc = <span class="keyword">this</span>.hc;</span><br><span class="line">                Object other$hc = other.hc;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$hc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$hc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$hc.equals(other$hc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> EqualsAndHashCodeTest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Object $equal = <span class="keyword">this</span>.equal;</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + ($equal == <span class="keyword">null</span> ? <span class="number">43</span> : $equal.hashCode());</span><br><span class="line">        Object $hc = <span class="keyword">this</span>.hc;</span><br><span class="line">        result = result * <span class="number">59</span> + ($hc == <span class="keyword">null</span> ? <span class="number">43</span> : $hc.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到还加入了一个<code>canEqual</code>方法用来预先判断是否能和当前类对象进行<code>equals</code>比较。</p><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a><code>@Data</code></h3><p>基本上每一个实体类都会使用到上面四个注解：<code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>和<code>@EqualsAndHashCode</code>，但是如果在每一个类上都重复的写上这四个注解，就又显得累赘了。于是<code>Lombok</code>提供了<code>@Data</code>注解，它等价于这四个注解的组合，会同时生成<code>getter</code>、<code>setter</code>、<code>toString</code>、<code>equals</code>、<code>canEqual</code>和<code>hashCode</code>这六个方法。同时还提供了一个属性<code>staticConstructor</code>，例如：<code>staticConstructor=&quot;of&quot;</code>，这样使用后，会将无参构造函数私有化，同时会提供一个静态成员方法<code>of()</code>用来创建当前类对象，在类外部无法使用<code>new</code>关键字来创建对象。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data(staticConstructor = &quot;of&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> String c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> String c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DataTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataTest <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setS</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> DataTest)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DataTest other = (DataTest)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object <span class="keyword">this</span>$s = <span class="keyword">this</span>.getS();</span><br><span class="line">                Object other$s = other.getS();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$s != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$s.equals(other$s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object <span class="keyword">this</span>$c = <span class="keyword">this</span>.getC();</span><br><span class="line">                Object other$c = other.getC();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$c.equals(other$c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> DataTest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Object $s = <span class="keyword">this</span>.getS();</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + ($s == <span class="keyword">null</span> ? <span class="number">43</span> : $s.hashCode());</span><br><span class="line">        Object $c = <span class="keyword">this</span>.getC();</span><br><span class="line">        result = result * <span class="number">59</span> + ($c == <span class="keyword">null</span> ? <span class="number">43</span> : $c.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DataTest(s=&quot;</span> + <span class="keyword">this</span>.getS() + <span class="string">&quot;, c=&quot;</span> + <span class="keyword">this</span>.getC() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NoArgsConstructor、-AllArgsConstructor和RequiredArgsConstructor"><a href="#NoArgsConstructor、-AllArgsConstructor和RequiredArgsConstructor" class="headerlink" title="@NoArgsConstructor、@AllArgsConstructor和RequiredArgsConstructor"></a><code>@NoArgsConstructor</code>、<code>@AllArgsConstructor</code>和<code>RequiredArgsConstructor</code></h3><ul><li><code>@NoArgsConstructor</code>：无参构造器；</li><li><code>@AllArgsConstructor</code>：全参构造器；</li><li><code>@RequiredArgsConstructor</code>：部分参数构造器，针对被声明为<code>final</code>的字段生成构造器。</li></ul><p><code>Java</code>类的构造器机制是：如果类中未声明任何一个构造器，则编译器会在编译期自动加上一个无参构造器；如果声明了任意一个构造器，则不会自动加上无参构造器。</p><p>所以一般会将无参和全参构造器进行搭配使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgsConstructor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgsConstructor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ac;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArgsConstructor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArgsConstructor</span><span class="params">(String ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ac = ac;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>@RequiredArgsConstructor</code>注解跟前两个是互斥的，该注解是针对<code>final</code>字段来生成构造器，可与<code>Spring</code>的<code>DI</code>依赖注入搭配使用。</p><h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="@Slf4j"></a><code>@Slf4j</code></h3><p>作为研发我们避免不了日志打印，但我们却要在每一个需要打印日志的类中定义这样一个静态日志常量：<code>private static final Logger log = LoggerFactory.getLogger(XXXService.class);</code>，其中<code>XXXService</code>的名称还都不相同，这太影响像我这样的<code>CV</code>工程师的效率了。<code>Lombok</code>提供了<code>@Slf4j</code>注解来解决这个问题。</p><p>使用前提：引入日志框架<code>slf4j</code>的<code>Maven</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LogTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只用一个相同的注解<code>@Slf4j</code>就可以为每个类分别生成对应的日志常量<code>log</code>对象。<code>CV</code>工程师的效率又提高了！</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><code>Lombok</code>的使用很简单，只需添加对应注解，就可以在字节码中生成对应的代码。从源文件到字节码之间只经过了编译阶段，所以<code>Lombok</code>一定是在编译阶段对注解进行解析然后注入对应的字节码。</p><p>而编译阶段对注解的解析有两种机制：</p><ol><li><code>Annotation Processing Tool</code>：简称<code>apt</code></li></ol><p><code>apt</code>随着<code>JDK5</code>引入注解时产生，在<code>JDK7</code>中被标记为过期，不推荐使用，<code>JDK8</code>已彻底将其删除。</p><p>从<code>JDK6</code>开始，可以使用<code>Pluggable Annotation Processing API</code>来替换它，<code>apt</code>被替换的主要原因是：</p><ul><li><code>api</code>都在<code>com.sun.mirror</code>非标准包下；</li><li>没有集成到<code>javac</code>中，需要额外运行。</li></ul><ol start="2"><li><code>Pluggable Annotation Processing API</code></li></ol><p>这其实是<a href="https://jcp.org/en/jsr/detail?id=269">JSR 269</a>规范，在<code>JDK6</code>中被引入作为<code>apt</code>的替代方案，它解决了<code>apt</code>的那两个问题，在<code>javac</code>执行过程中会调用实现了该规范的程序，这样我们就可以对<code>javac</code>编译器做一些增强。</p><blockquote><p><code>JSR</code>是<code>Java Specification Requests</code>的缩写，意思是<code>Java</code>规范提案。</p></blockquote><p><code>Lombok</code>就是一个实现了<code>JSR 269</code>规范的程序，在<code>javac</code>编译过程中会调用<code>Lombok</code>，从而实现代码的自动加入。</p><p>整个编译的过程大致如下：</p><ul><li><code>javac</code>对源代码进行分析，生成一颗抽象语法树（<code>AST</code>）；</li><li>调用<code>JSR 269</code>的实现：<code>Lombok</code>；</li><li><code>Lombok</code>对抽象语法树进行解析，找到<code>Lombok</code>定义的注解所在的语法树，然后进行修改，添加<code>getter</code>和<code>setter</code>等方法定义的树节点；</li><li>使用修改后的语法树生成字节码<code>class</code>文件。</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p><ul><li>代码简洁优雅，通过注解的形式自动生成一些模版式的代码。</li><li>当类字段发生修改时，不用去修改对应的<code>getter</code>和<code>setter</code>等方法。</li></ul><p>缺点：</p><ul><li><code>IDE</code>中需要安装插件，否则项目报错。</li><li>不支持任意个参数的构造器重载。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于<code>Lombok</code>，网上一部分人支持，一部分人反对。反对的理由还很多：强依赖插件；组内有一人用则所有人用；操作语法树等于改变<code>Java</code>语法等等。暂且认为这些都有道理，但有句话怎么说来着：拥抱变化！<code>Java</code>语言走过这么多年也经过了很多变化，每个大版本也或多或少会出现一些新语法。<code>Lombok</code>的出现也预示着<code>Java</code>需要发生变化，而不是局限于当下的安稳。所以，我认为<code>Lombok</code>是值得去拥抱的！</p><blockquote><p>从另一个角度说，那些反对<code>Lombok</code>的人可能是没写过业务系统，业务代码中经常出现一个类有二三十个字段，甚至更多，这时如果手动去维护各个类的<code>getter</code>和<code>setter</code>方法，效率可想而知，而且也没什么技术含量。打工人讲究的是如何高效打工！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之链表-基础知识</title>
      <link href="2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/"/>
      <url>2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>链表：各个元素物理内存空间不连续，通过“指针”将一组零散的内存空间串联起来。指针的链接顺序为链表中元素的逻辑顺序。</p><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><p>链表由一组节点组成，每个节点包含两个部分：一个是存储元素的数据域，另一个是存储下一个节点地址的指针域。天然支持动态扩容。</p><h2 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h2><ul><li>单链表：第一个节点称为头节点，最后一个节点称为尾节点。头节点用来记录链表的基地址，可以通过头节点遍历整个链表。尾节点的指针域指向<code>null</code>。</li><li>循环链表：特殊的单链表，与单链表唯一不同的是：尾节点的指针域指向了头节点。</li><li>双向链表：每个节点不仅存储数据域和指向下一个节点的指针域，它还会有一个指针域指向前一个节点。通常称为前驱节点和后继节点。</li><li>双向循环链表：综合了循环链表和双向链表。头节点的前驱节点指向尾节点，尾节点的后继节点指向头节点。</li></ul><p><code>JDK</code>的<code>java.util.LinkedList</code>就是一个双向链表。</p><h2 id="单链表节点类定义"><a href="#单链表节点类定义" class="headerlink" title="单链表节点类定义"></a>单链表节点类定义</h2><p>我们来定义一个单链表的节点类<code>SinglyLinkedListNode</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.algorithm.base.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单向链表节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2020/6/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglyLinkedListNode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 值域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指针域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SinglyLinkedListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SinglyLinkedListNode</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造单链表及其打印"><a href="#构造单链表及其打印" class="headerlink" title="构造单链表及其打印"></a>构造单链表及其打印</h2><p>构造一个单链表，并按顺序打印在控制台。我们提供一个工具类<code>LinkedListUtils</code>来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.sparrow.algorithm.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sunchaser.sparrow.algorithm.base.linkedlist.SinglyLinkedListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser admin@lilu.org.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK8 2020/12/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LinkedListUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SinglyLinkedListNode <span class="title">generateSinglyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SinglyLinkedListNode node4 = <span class="keyword">new</span> SinglyLinkedListNode(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        SinglyLinkedListNode node3 = <span class="keyword">new</span> SinglyLinkedListNode(<span class="number">4</span>,node4);</span><br><span class="line">        SinglyLinkedListNode node2 = <span class="keyword">new</span> SinglyLinkedListNode(<span class="number">3</span>,node3);</span><br><span class="line">        SinglyLinkedListNode node1 = <span class="keyword">new</span> SinglyLinkedListNode(<span class="number">2</span>,node2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SinglyLinkedListNode(<span class="number">1</span>,node1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序打印单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 要打印的单链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLink</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-&gt;&quot;</span> + head.val + <span class="string">&quot;-&gt;null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;-&gt;&quot;</span> + head.val);</span><br><span class="line">        printLink(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h2><p>单链表的插入操作：例如：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>。</p><p>现在要将元素<code>0</code>插入到<code>3</code>和<code>4</code>之间。做法很简单，只需要先将<code>0</code>指向<code>4</code>，再将<code>3</code>指向<code>0</code>即可。注意先后顺序，要先将<code>0</code>指向<code>4</code>，后将<code>3</code>指向<code>0</code>。因为如果顺序对调，将<code>3</code>先指向<code>0</code>之后就找不到节点<code>4</code>了。</p><p>现在要将<code>0</code>从链表中删除。需要将节点<code>0</code>前面的节点<code>3</code>指向节点<code>0</code>后面的<code>4</code>，然后将节点<code>0</code>的指针域置为空。注意：将节点<code>3</code>指向节点<code>4</code>后，中间的节点<code>0</code>就会找不到了，所以需要用一个中间变量来保存节点<code>0</code>，待指向完成后再将节点<code>0</code>的指针域指向<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// generate singly linked list</span></span><br><span class="line">    SinglyLinkedListNode head = LinkedListUtils.generateSinglyLinkedList();</span><br><span class="line">    LinkedListUtils.printLink(head); <span class="comment">// -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</span></span><br><span class="line">    <span class="comment">// 从3和4之间插入0</span></span><br><span class="line">    SinglyLinkedListNode c = <span class="keyword">new</span> SinglyLinkedListNode(<span class="number">0</span>);</span><br><span class="line">    SinglyLinkedListNode cHead = head;</span><br><span class="line">    <span class="keyword">while</span> (cHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cHead.val == <span class="number">3</span>) &#123;</span><br><span class="line">            c.next = cHead.next;</span><br><span class="line">            cHead.next = c;</span><br><span class="line">        &#125;</span><br><span class="line">        cHead = cHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedListUtils.printLink(head); <span class="comment">// -&gt;1-&gt;2-&gt;3-&gt;0-&gt;4-&gt;5-&gt;null</span></span><br><span class="line">    <span class="comment">// 将0从3和4之间删除</span></span><br><span class="line">    SinglyLinkedListNode dHead = head;</span><br><span class="line">    <span class="keyword">while</span> (dHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dHead.val == <span class="number">3</span>) &#123;</span><br><span class="line">            SinglyLinkedListNode temp = dHead.next;</span><br><span class="line">            dHead.next = dHead.next.next;</span><br><span class="line">            temp.next = <span class="keyword">null</span>; <span class="comment">// help gc</span></span><br><span class="line">        &#125;</span><br><span class="line">        dHead = dHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedListUtils.printLink(head); <span class="comment">// -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之链表-奇数个元素的链表的中间节点</title>
      <link href="2020/12/12/algorithm/base/datastructure/middle-linknode/"/>
      <url>2020/12/12/algorithm/base/datastructure/middle-linknode/</url>
      
        <content type="html"><![CDATA[<p>题目：给定一个奇数个元素的链表，查找出这个链表中间位置的节点的数值。</p><p>示例：单链表：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，中间位置的节点的数值为<code>3</code>。</p><p>思路：由于单链表特性，我们只能先遍历一次才能得到其长度，得到总长度之后我们就知道其中间位置是第几个，再次进行遍历即可得到。这种暴力解法时间复杂度是：<code>O(n) + O(2/n)</code>。</p><p>下面介绍一种时间复杂度更低的解法：快慢指针法。</p><p>定义一快一慢两个指针：<code>fast</code>和<code>slow</code>，两个指针同时走，快指针每次走两步，慢指针每次走一步，当快指针走到链表末尾的时候，慢指针就恰好在链表中间位置，即我们需要的中间节点。</p><p>我们来看快慢指针的<code>Java</code>语言实现：</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SinglyLinkedListNode <span class="title">middleNode</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">    SinglyLinkedListNode fast = head;</span><br><span class="line">    SinglyLinkedListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之链表-使用非递归法实现单链表的反转</title>
      <link href="2020/12/12/algorithm/base/datastructure/non-recursive-reverse-link/"/>
      <url>2020/12/12/algorithm/base/datastructure/non-recursive-reverse-link/</url>
      
        <content type="html"><![CDATA[<p>题目：使用非递归法实现单链表的反转</p><p>示例：单链表：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，反转之后的结果为：<code>5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null</code>。</p><p>之前已经写过一篇文章使用递归法来实现，可查看：<a href="https://lilu.org.cn/2020/06/04/algorithm/base/recursive-reverse-link/">勇闯算法-递归法拿下反转链表的三杀</a></p><p>现在我们使用非递归法来进行实现。</p><p>思路：由于单链表的特性，我们只能从前往后依次遍历各个链表节点，对于示例中的单链表，如果我们直接将<code>1</code>和<code>2</code>进行反转，将<code>2</code>指向<code>1</code>，我们会发现<code>2</code>后面的节点已经无法访问到了。所以我们需要提前将<code>2</code>后面的<code>3</code>记录下来，然后再将<code>2</code>指向<code>1</code>，类似地，我们提前将<code>3</code>后面的<code>4</code>记录下来，再将<code>3</code>指向<code>2</code>…直至到最后一个节点，整个过程结束。</p><p>定义三个指针变量：<code>pre</code>、<code>current</code>、<code>next</code>。</p><p>初始状态：<code>pre = null,current = 1,next = null</code>。</p><p>反转过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next = current.next;</span><br><span class="line">current.next = pre;</span><br></pre></td></tr></table></figure><p>指针右移：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre = current;</span><br><span class="line">current = next;</span><br></pre></td></tr></table></figure><p>终止条件：<code>current.next == null</code>。</p><p><code>Java</code>语言完整实现：</p><blockquote><p>单链表节点类定义可查看文章：<a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SinglyLinkedListNode <span class="title">reverse</span><span class="params">(SinglyLinkedListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义三个指针：pre、current、next</span></span><br><span class="line">    SinglyLinkedListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    SinglyLinkedListNode current = head;</span><br><span class="line">    SinglyLinkedListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (current.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录current的next</span></span><br><span class="line">        next = current.next;</span><br><span class="line">        <span class="comment">// current反转</span></span><br><span class="line">        current.next = pre;</span><br><span class="line">        <span class="comment">// pre右移</span></span><br><span class="line">        pre = current;</span><br><span class="line">        <span class="comment">// current右移</span></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Maven必知必会</title>
      <link href="2020/12/11/javaee/maven/maven-must-know-and-know/"/>
      <url>2020/12/11/javaee/maven/maven-must-know-and-know/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没有使用<code>Maven</code>之前，我们开发一个<code>JavaWeb</code>项目，如果使用到非<code>JDK</code>提供的类库，需要去网上下载对应的<code>jar</code>包，然后将<code>jar</code>包复制粘贴放到项目的<code>lib</code>目录下才能够使用。这样的做法是很麻烦的，每开发一个<code>JavaWeb</code>项目都需要去将<code>jar</code>包文件放置在<code>lib</code>目录下，且只能以文件的形式进行管理。</p><p>我们可以使用<code>Maven</code>的依赖管理功能来减少复制<code>jar</code>包这样重复的工作。</p><h2 id="什么是Maven？"><a href="#什么是Maven？" class="headerlink" title="什么是Maven？"></a>什么是<code>Maven</code>？</h2><p><code>Maven</code>是一个项目管理工具，可以对项目（不仅限于<code>Java</code>语言）进行构建和依赖管理。简单来说：使用了<code>Maven</code>之后我们就不需要再去下载复制粘贴<code>jar</code>包了。</p><h2 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a><code>Maven</code>安装</h2><p><a href="https://lilu.org.cn/2020/02/07/installed/install-maven/">Windows 10下Maven的安装及配置</a></p><h2 id="Maven的约定配置"><a href="#Maven的约定配置" class="headerlink" title="Maven的约定配置"></a><code>Maven</code>的约定配置</h2><p><code>Maven</code>提供约定优于配置的原则，对于一个使用<code>Maven</code>构建和依赖管理的项目，应该遵循以下的目录结构：</p><table><thead><tr><th>目录</th><th>目录存放内容</th></tr></thead><tbody><tr><td><code>$&#123;basedir&#125;</code></td><td><code>Maven</code>项目根路径，存放<code>pom.xml</code>和所有的子目录</td></tr><tr><td><code>$&#123;basedir&#125;/src/main/java</code></td><td>项目的<code>java</code>类文件</td></tr><tr><td><code>$&#123;basedir&#125;/src/main/resources</code></td><td>项目的资源文件，例如<code>properties</code>配置文件，前端静态资源文件等</td></tr><tr><td><code>$&#123;basedir&#125;/src/test/java</code></td><td>项目的单元测试类文件，一般为<code>Junit</code>的单元测试类</td></tr><tr><td><code>$&#123;basedir&#125;/src/test/resources</code></td><td>提供给测试类使用的资源文件</td></tr><tr><td><code>$&#123;basedir&#125;/src/main/webapp/WEB-INF</code></td><td><code>JavaWeb</code>项目的<code>web</code>应用文件目录，存放<code>web.xml</code>、<code>.jsp</code>和前端静态资源等文件。</td></tr><tr><td><code>$&#123;basedir&#125;/target</code></td><td>打包输出目录</td></tr><tr><td><code>$&#123;basedir&#125;/target/classes</code></td><td>编译输出目录，<code>java</code>类编译后的字节码文件目录</td></tr><tr><td><code>$&#123;basedir&#125;/target/test-classes</code></td><td>测试类编译输出目录</td></tr><tr><td><code>XXXTest.java</code></td><td><code>Maven</code>只会自动运行类名以<code>Test</code>结尾的测试类</td></tr><tr><td><code>~/.m2/repository</code></td><td><code>Maven</code>的默认本地仓库路径</td></tr></tbody></table><h2 id="pom-xml常用标签"><a href="#pom-xml常用标签" class="headerlink" title="pom.xml常用标签"></a><code>pom.xml</code>常用标签</h2><p>下面是一个典型<code>Spring Boot</code>项目的<code>pom.xml</code>文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值（继承）。 坐标包括group ID，artifact ID和version。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的唯一组织名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的唯一构建标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的版本号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目的唯一组织名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunchaser.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目的唯一构建标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目的版本号，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目的描述简介 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以值（value）代替名称（name），可在整个pom.xml中使用，格式：&lt;name&gt;value&lt;name/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 该元素描述了项目相关的所有依赖。这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 由于parent的存在，以下依赖继承了parent中申明的版本号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。</span></span><br><span class="line"><span class="comment">                - compile ：默认范围，用于编译</span></span><br><span class="line"><span class="comment">                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用</span></span><br><span class="line"><span class="comment">                - test: 用于test任务时使用</span></span><br><span class="line"><span class="comment">                - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径</span></span><br><span class="line"><span class="comment">                - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上是将<code>Spring Boot</code>作为<code>parent</code>的<code>pom.xml</code>，这样的好处是<code>parent</code>可以聚合依赖的版本等一些信息，在后面添加依赖时只需要填写<code>groupId</code>和<code>artifactId</code>坐标，版本号默认继承<code>parent</code>中定义的版本号。但很多时候我们的项目是<code>Maven</code>多模块项目，或者由于一些其它原因导致我们无法使用<code>Spring Boot</code>作为<code>parent</code>，这个时候就需要用到<code>dependencyManagement</code>标签来进行依赖预定义了，<code>Spring Boot</code>提供了<code>BOM</code>用来进行预定义依赖的引入，使用方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunchaser.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 预定义依赖引入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a><code>Maven</code>的生命周期</h2><p><code>Maven</code>有三个标准的生命周期：</p><ul><li><code>clean</code>：项目清理的处理。</li><li><code>default(build)</code>：项目部署的处理。</li><li><code>site</code>：项目站点文档创建的处理。</li></ul><h3 id="Clean生命周期"><a href="#Clean生命周期" class="headerlink" title="Clean生命周期"></a><code>Clean</code>生命周期</h3><p>包含以下阶段：</p><ul><li><code>pre-clean</code>：执行一些需要在<code>clean</code>之前完成的工作。</li><li><code>clean</code>：移除所有上一次构建生成的文件。</li><li><code>post-clean</code>：执行一些需要在<code>clean</code>之后立即完成的工作。</li></ul><p>我们所用的<code>mvn clean</code>命令就是上面的<code>clean</code>阶段。在一个生命周期中，运行某个阶段的时候，在它之前的所有阶段都会被运行。也就是说，如果执行<code>maven clean</code>命令将运行<code>pre-clean</code>和<code>clean</code>这两个生命周期阶段。</p><h3 id="Default-build-生命周期"><a href="#Default-build-生命周期" class="headerlink" title="Default(build)生命周期"></a><code>Default(build)</code>生命周期</h3><p>包含以下<code>23</code>个阶段：</p><ul><li><code>validate</code>校验：校验项目是否正确并且所有必要的信息可以完成项目的构建过程。</li><li><code>initialize</code>初始化：初始化构建阶段，比如设置属性值。</li><li><code>generate-sources</code>生成源代码：生成包含在编译阶段中的任何源代码。</li><li><code>process-sources</code>处理源代码：处理源代码，比如过滤任意值。</li><li><code>generate-resources</code>生成资源文件：生成将会包含在项目包中的资源文件。</li><li><code>process-resources</code>处理资源文件：复制和处理资源到目标目录，为打包阶段做好准备。</li><li><code>compile</code>编译：编译项目的源代码。</li><li><code>process-classes</code>处理类文件：处理编译生成的文件，比如说对<code>Java class</code>文件做字节码改善优化。</li><li><code>generate-test-sources</code>生成测试源代码：生成包含在编译阶段中的任何测试源代码。</li><li><code>process-test-sources</code>处理测试源代码：处理测试源代码，比如说，过滤任意值。</li><li><code>generate-test-resources</code>生成测试资源文件：为测试创建资源文件。</li><li><code>process-test-resources</code>处理测试资源文件：复制和处理测试资源到目标目录。</li><li><code>test-compile</code>编译测试源码：编译测试源代码到测试目标目录。</li><li><code>process-test-class</code>处理测试类文件：处理测试源码编译生成的文件。</li><li><code>test</code>测试：使用合适的单元测试框架运行测试（<code>Junit</code>是其中之一）。</li><li><code>prepare-package</code>准备打包：在实际打包之前，执行任何的必要的操作为打包做准备。</li><li><code>package</code>打包：将编译后的代码打包成可分发格式的文件，比如<code>JAR</code>、<code>WAR</code>或者<code>EAR</code>文件。</li><li><code>pre-integration-test</code>集成测试前：在执行集成测试前进行必要的动作。比如说，搭建需要的环境。</li><li><code>integration-test</code>集成测试：处理和部署项目到可以运行集成测试环境中。</li><li><code>post-integration-test</code>集成测试后：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。</li><li><code>verify</code>验证：运行任意的检查来验证项目包有效且达到质量标准。</li><li><code>install</code>安装：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。</li><li><code>deploy</code>部署：将最终的项目包发布到远程仓库中与其他开发者和项目共享。</li></ul><p>我们常用的<code>mvn install</code>命令，在执行<code>install</code>之前，按顺序执行了之前的<code>21</code>个阶段。如果用于多模块项目，每一个子项目都会执行<code>mvn install</code>命令。</p><p>还可以一次指定两个阶段，例如<code>mvn clean deploy</code>，这可以用来纯净的构建和部署项目到远程仓库中。<code>Maven</code>会先执行<code>clean</code>命令，再执行<code>deploy</code>命令，对多模块项目也适用。</p><h3 id="Site生命周期"><a href="#Site生命周期" class="headerlink" title="Site生命周期"></a><code>Site</code>生命周期</h3><p><code>Maven Site</code>插件一般用来创建新的报告文档和部署站点等。这个在我们的开发工作中一般不会用到，了解即可。</p><p>包含以下<code>4</code>个阶段：</p><ul><li><code>pre-site</code>：执行一些需要在生成站点文档之前完成的工作。</li><li><code>site</code>：生成项目的站点文档。</li><li><code>post-site</code>：执行一些需要在生成站点文档之后完成的工作，并且为部署做准备。</li><li><code>site-deploy</code>：将生成的站点文档部署到特定的服务器上。</li></ul><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a><code>Maven</code>仓库</h2><p><code>Maven</code>仓库简单的理解就是存储<code>JAR</code>包的地方。有以下三种类型：</p><ul><li>本地仓库（<code>local</code>）</li><li>中央仓库（<code>central</code>）</li><li>远程仓库（<code>remote</code>）</li></ul><h3 id="本地仓库（local）"><a href="#本地仓库（local）" class="headerlink" title="本地仓库（local）"></a>本地仓库（<code>local</code>）</h3><p>运行<code>Maven</code>项目时，任何依赖的构建或第三方<code>JAR</code>包都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构建至本地仓库，然后再使用本地仓库的构建。</p><p>默认的本地仓库路径为<code>~/.m2/repository</code>，要修改该默认位置，可在<code>Maven</code>的<code>setting.xml</code>文件中指定本地仓库路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Library/maven/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="中央仓库（central）"><a href="#中央仓库（central）" class="headerlink" title="中央仓库（central）"></a>中央仓库（<code>central</code>）</h3><p>中央仓库是由<code>Maven</code>社区提供的仓库，需要通过网络进行访问。国内常用的是阿里云中央仓库。可在<code>Maven</code>的<code>setting.xml</code>文件中配置阿里云的中央仓库源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Library/maven/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Maven</code>社区提供了一个网站：<a href="https://search.maven.org/">https://search.maven.org</a>，可搜索到所有可以获取的构建库和<code>JAR</code>包。</p><h3 id="远程仓库（remote）"><a href="#远程仓库（remote）" class="headerlink" title="远程仓库（remote）"></a>远程仓库（<code>remote</code>）</h3><p>如果<code>Maven</code>在中央仓库也找不到依赖的构建，它会停止构建过程并输出错误信息到控制台。为了避免这种情况，<code>Maven</code>提供了远程仓库的概念，它是开发人员自己定制的仓库，包含了所需要的代码库或者其它工程中用到的<code>JAR</code>文件。</p><h2 id="Maven依赖搜索顺序"><a href="#Maven依赖搜索顺序" class="headerlink" title="Maven依赖搜索顺序"></a><code>Maven</code>依赖搜索顺序</h2><p>首先从本地仓库（<code>local</code>）中搜索，如果找不到，则去中央仓库（<code>central</code>）中搜索；</p><p>如果在中央仓库（<code>central</code>）中找不到，则查看是否设置了远程仓库（<code>remote</code>），如果没有设置，则停止搜索并抛出错误（无法找到依赖）。</p><p>如果在远程仓库（<code>remote</code>）中找不到，则停止搜索并抛出错误（无法找到依赖）；如果在远程仓库（<code>remote</code>）中找到了，则下载至本地仓库并引用。</p><h2 id="Maven插件"><a href="#Maven插件" class="headerlink" title="Maven插件"></a><code>Maven</code>插件</h2><p><code>Maven</code>的三个标准生命周期中都包含一系列的阶段，每一个阶段的具体实现都是由<code>Maven</code>的插件完成。</p><p>例如我们使用的<code>mvn clean</code>命令，<code>clean</code>对应着<code>Clean</code>生命周期中的<code>clean</code>阶段，<code>clean</code>的具体操作是由<code>maven-clean-plugin</code>完成的。</p><h3 id="插件类型"><a href="#插件类型" class="headerlink" title="插件类型"></a>插件类型</h3><p><code>Maven</code>提供了以下两种类型的插件：</p><ul><li><code>Build Plugins</code>：在构建时执行，并在<code>pom.xml</code>的元素中配置。</li><li><code>Reporting Plugins</code>：在网站生成过程中执行，并在<code>pom.xml</code>的元素中配置。</li></ul><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p>下面是一些常用的插件：</p><ul><li><code>clean</code>：构建之后清理目标文件。删除目标目录。</li><li><code>compiler</code>：编译<code>Java</code>源文件。</li><li><code>surefile</code>：运行<code>Junit</code>单元测试。创建测试报告。</li><li><code>jar</code>：从当前工程中构建<code>jar</code>文件。</li><li><code>war</code>：从当前工程中构建<code>war</code>文件。</li><li><code>javadoc</code>：为工程生成<code>javadoc</code>。</li><li><code>antrun</code>：从构建过程的任意一个阶段中运行一个<code>ant</code>任务的集合。</li></ul><h2 id="引入外部依赖"><a href="#引入外部依赖" class="headerlink" title="引入外部依赖"></a>引入外部依赖</h2><p>有些时候我们需要去对接一些第三方的<code>SDK</code>包，一般第三方会提供<code>SDK</code>的下载地址，但是很可能未发布至中央仓库，就导致无法通过<code>Maven</code>坐标直接引入。这个时候我们需要手动将<code>SDK</code>包下载并复制粘贴到项目中，可在<code>$&#123;basedir&#125;/src/main/resources</code>目录下新建一个<code>lib</code>目录，专门用来存放未发布至中央仓库的<code>JAR</code>包。引入方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 库名称，可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx-sdk-1.0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 库名称，可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 作用域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- resource目录下的lib文件夹下，文件名为：xxx-sdk.jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\main\resources\lib\xxx-sdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="快照（SNAPSHOT）"><a href="#快照（SNAPSHOT）" class="headerlink" title="快照（SNAPSHOT）"></a>快照（<code>SNAPSHOT</code>）</h2><p>在<code>Apache Dubbo</code>微服务项目开发中，服务消费方需要去引入服务提供方对外暴露的<code>API</code>接口<code>jar</code>包。服务提供方很有可能在短期内多次修改对外暴露的接口，如果按照正常的版本号：<code>producer-service.jar:1.0.0</code>，那每修改一次接口都需要升级一个小版本，服务消费方不得不去更新<code>pom.xml</code>来引用最新的<code>jar</code>包。如果修改接口而不升级版本号就发布至仓库中，服务消费方在引用时不会去仓库下载相同版本号的最新<code>jar</code>包。也就是说，服务消费方只会下载一次指定版本号的<code>jar</code>包。为了避免这种繁琐的更新，<code>Maven</code>提供了快照版本。</p><p>快照版本是一种特殊的版本，指定了当前的开发进度的副本。不同于常规的版本，<code>Maven</code>每次构建都会在远程仓库中检查新的快照，服务提供方只需发布包含最新代码的快照版本（<code>producer-service.jar:1.0.0-SNAPSHOT</code>）至仓库中，服务消费方每次都会自动去获取包含最新代码的快照（<code>producer-service.jar:1.0.0-SNAPSHOT</code>）。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p><code>Maven</code>解析<code>jar</code>包的方式是依赖传递。例如我们引入<code>spring-boot-starter-web</code>，当<code>Maven</code>解析该依赖时，不仅仅会引入其内部依赖的<code>spring-web</code>、<code>spring-webmvc</code>和<code>spring-boot-starter-tomcat</code>等，还会引入这些内部依赖所依赖的<code>jar</code>包，例如<code>spring-web</code>依赖的<code>spring-bean</code>等，依赖关系不断向下传递，直至没有依赖，最终形成了一颗依赖树。</p><h3 id="依赖冲突的问题"><a href="#依赖冲突的问题" class="headerlink" title="依赖冲突的问题"></a>依赖冲突的问题</h3><p>举个栗子：假设有依赖<code>A</code>，它内部的依赖传递关系为：<code>A</code>-&gt;<code>B</code>-&gt;<code>C</code>-&gt;<code>D</code>-&gt;<code>E1</code>；有另一个依赖<code>F</code>，它内部的依赖传递关系为：<code>F</code>-&gt;<code>G</code>-&gt;<code>E2</code>。<code>E1</code>和<code>E2</code>为<code>E</code>的不同版本。</p><p>如果<code>pom.xml</code>同时引入<code>A</code>和<code>F</code>依赖，按照<code>Maven</code>依赖传递原则，实际引入的依赖将包括：<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E1</code>、<code>F</code>、<code>G</code>和<code>E2</code>，因此<code>E1</code>和<code>E2</code>将会产生包冲突。</p><h3 id="解决依赖冲突"><a href="#解决依赖冲突" class="headerlink" title="解决依赖冲突"></a>解决依赖冲突</h3><p><code>Maven</code>解析<code>pom.xml</code>时，同一个<code>groupId</code>和<code>artifactId</code>的依赖只会保留一个，这样可以有效避免因引入不同版本的依赖所带来的问题。</p><p><code>Maven</code>默认处理策略：</p><ul><li>最短路径优先原则：因为从<code>F</code>到<code>E2</code>的路径比从<code>A</code>到<code>E1</code>的路径短，所以<code>Maven</code>在面对<code>E1</code>和<code>E2</code>时会选择<code>E2</code>。</li><li>最先声明优先原则：举个栗子：<code>A</code>-&gt;<code>B</code>-&gt;<code>C1</code>；<code>D</code>-&gt;<code>E</code>-&gt;<code>C2</code>。这两个依赖传递的路径长度是一样的，所以谁在<code>pom.xml</code>先被声明就引入谁。</li></ul><p>排除依赖：默认处理策略已经能解决包的依赖问题，但还是会显示依赖冲突，现象就是<code>IDEA</code>中会报红；同时默认处理引入的依赖版本号可能不是我们所需要的，如果我们想引入指定版本号的依赖，可以使用<code>&lt;exclusions /&gt;</code>和<code>&lt;exclusion&gt;</code>标签先排除冲突的依赖，再另外单独在<code>pom.xml</code>中引入指定版本号的依赖。</p><p>检测包冲突的<code>Maven</code>命令如下：</p><ul><li><code>mvn dependency:help</code></li><li><code>mvn dependency:analyze</code></li><li><code>mvn dependency:tree</code></li><li><code>mvn dependency:tree -Dverbose</code></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>当开发多模块项目时，在最外层的父<code>pom.xml</code>中使用<code>dependencyManagement</code>标签进行依赖及版本号的预定义，便于统一管理项目依赖及版本号。在子模块引入依赖时，只需指定<code>groupId</code>和<code>artifactId</code>即可引入对应依赖。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>菜鸟教程 - <code>Maven</code>教程</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java EE </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-第7题：整数反转</title>
      <link href="2020/12/04/algorithm/leetcode/easy/7/"/>
      <url>2020/12/04/algorithm/leetcode/easy/7/</url>
      
        <content type="html"><![CDATA[<p>题目：给出一个 <code>32</code> 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 <code>1</code>:<br>输入: <code>123</code><br>输出: <code>321</code></p><p>示例 <code>2</code>:<br>输入: <code>-123</code><br>输出: <code>-321</code></p><p>示例 <code>3</code>:<br>输入: <code>120</code><br>输出: <code>21</code></p><p>注意:<br>假设我们的环境只能存储得下 <code>32</code> 位的有符号整数，则其数值范围为 <code>[−2^31,2^31 − 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 <code>0</code>。</p><p>来源：力扣（<code>LeetCode</code>）<br>链接：<code>https://leetcode-cn.com/problems/reverse-integer</code><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>思路：</p><p>首先我们考虑一个普通的正整数如何进行反转。</p><p>例如 <code>1234</code>。</p><p>最直接暴力的：字符串异常法。先将其转化为字符串，然后对字符串遍历，利用栈结构进行反转，反转之后的字符串类型强制转换成整数，抛出异常则溢出。这样可以处理<code>1234</code>这样的正整数。但是遇到负数就行不通了。</p><p>我们得考虑如何对负数进行反转，其实也很简单，只需要先判断输入数的正负性，然后记一个标记，同样的方式反转完成后，如果是负数，则拼接上负号<code>-</code>再进行强制类型转换，这样就可以解决了。</p><p>来看下这种“暴力字符串异常法”的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">convertStringToReverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否小于0</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = x &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取绝对值转字符串</span></span><br><span class="line">    String s = String.valueOf(Math.abs(x));</span><br><span class="line">    <span class="comment">// 转换成char数组进行遍历</span></span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="comment">// 声明栈</span></span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">        stack.push(aChar);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// x值小于0，前面拼接上负号</span></span><br><span class="line">        res.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        res.append(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 强制类型转换</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(res.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常表示溢出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法，入栈遍历的时间复杂度<code>O(n)</code>，栈结构的空间复杂度<code>O(n)</code>，出栈遍历的时间复杂度<code>O(n)</code>。整体的时间复杂度是<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p><p>显然，这种解法并不是最优解。</p><p>不做类型转换，只操作整数进行反转。如何操作？其实可以套用生产者消费者的思想。</p><p>对于输入整数<code>x</code>：</p><p>生产者逻辑：</p><p>获取整数的个位数字：<code>n = x % 10</code>。</p><p>消费者逻辑：</p><p>整个过程开始之前，反转结果<code>res</code>的初始值等于<code>0</code>。</p><p>将生产者产出的个位数加到<code>res</code>后面：<code>res = res * 10 + n</code>。</p><p>将输入整数的个位数去除：<code>x /= 10</code>。</p><p>当消费到<code>x = 0</code>时，整个过程结束，最终的<code>res</code>即为反转结果。</p><p>看似完美，但题意中说到了整数溢出。反转之后的范围为：<code>[-2^31,2^31 - 1]</code>，我们需要去考虑溢出的边界。</p><p>反转结果<code>res</code>每次消费都会增大一个数量级，我们来看下限制的数值范围：<code>[-2147483648,2147483647]</code></p><p>对于反转结果<code>res</code>：</p><p>首先分析正数区间，考虑倒数第二位，如果本次消费前<code>res &gt; 214748364</code>（即去掉正区间最大值的最后一位），无论此次消费到的个位数<code>n</code>为多少都溢出了；另一种情况，考虑最后一位，如果本次消费前<code>res = 214748364</code>，那本次消费时<code>n</code>值只要大于<code>7</code>，就溢出了。</p><p>再来看负数区间，同样考虑倒数第二位，如果本次消费前<code>res &lt; -214748364</code>成立，无论此次消费到的个位数<code>n</code>为多少都溢出了；另一种情况，考虑最后一位，如果本次消费前<code>res = -214748364</code>，那本次消费时<code>n</code>值只要小于<code>-8</code>，就溢出了。</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 反转结果初始值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 生产：获取个位数</span></span><br><span class="line">        <span class="keyword">int</span> x = n % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 溢出边界</span></span><br><span class="line">        <span class="keyword">if</span> ((res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; x &gt; Integer.MAX_VALUE % <span class="number">10</span>))</span><br><span class="line">                || (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; x &lt; Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消费：加到反转结果后面</span></span><br><span class="line">        res = res * <span class="number">10</span> + x;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 简单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试必问HashMap</title>
      <link href="2020/11/17/javase/base/hashmap/"/>
      <url>2020/11/17/javase/base/hashmap/</url>
      
        <content type="html"><![CDATA[<p>无论是小厂还是大厂面试，<code>HashMap</code>的出场率一直居高不下。作为<code>Java</code>语言中<code>Map</code>数据结构的经典实现，对其内部原理的掌握和理解程度在一定程度上能反映出一个开发人员的水平与实力。</p><p>下面我们提供出一些常见面试问法以及对应的官方回答（建议熟读并背诵）：</p><ol><li><code>HashMap</code>底层是如何实现的？<code>JDK7</code>和<code>JDK8</code>的实现有何区别？</li></ol><p>答：<code>HashMap</code>底层存储元素的数据结构是数组。在存储元素时如果发生了哈希冲突，<code>JDK7</code>使用“链地址法”（俗称“拉链法”）来解决，采用“头插法”进行元素插入。在<code>JDK8</code>中，当哈希冲突不是很严重时，仍然使用“链地址法”解决，但采用的是“尾插法”；而当哈希冲突特别严重，即链表的长度大于<code>8</code>并且数组的容量大于<code>64</code>时，会将链表结构转化成红黑树结构用以解决链表过长带来的性能问题。</p><ol start="2"><li>加载因子<code>loadFactor</code>为什么是<code>0.75</code>？</li></ol><p>答：这是一个基于容量和性能考虑的折衷值。如果加载因子设置过大，带来的好处是扩容的门槛提高，节约了内存空间，但出现哈希冲突的几率会变大，从而导致对元素的操作性能下降；如果加载因子设置过小，带来的好处是扩容门槛降低，数组中存储的元素会比较稀疏，不易出现哈希冲突，对元素的操作性能较高。但会存在一定的空间浪费。于是折衷考虑选择了<code>0.75</code>。</p><ol start="3"><li>什么时机会触发扩容？<code>JDK8</code>在扩容时做了哪些优化？</li></ol><p>答：当存储元素数量大于等于阈值时触发扩容。<code>JDK7</code>在扩容时会对所有元素进行<code>rehash</code>重新哈希计算数组下标；而<code>JDK8</code>在扩容时通过高位运算（哈希码 &amp; 旧容量）来判断元素是否需要移动，如果高位运算结果高一位为<code>0</code>，那么扩容后该元素的位置不会发生变化，如果高位运算结果高一位为<code>1</code>，那么扩容后该元素的位置发生了变化，新的数组下标位置为原下标位置加上原数组长度。</p><ol start="4"><li>描述插入一个元素的完整过程。</li></ol><p>答：首先判断哈希表是否为空，如果为空则表示第一次插入，进行扩容；否则根据键计算出数组下标，然后判断该下标位置的元素是否为<code>null</code>，如果是，则直接插入；否则判断键是否相等（先比较<code>hashCode</code>，哈希码不相等再进行<code>equals</code>比较），如果相等，则直接覆盖值；否则判断是红黑树还是链表，分别执行对应数据结构的插入逻辑。其中链表数据结构在<code>JDK7</code>中使用头插法进行插入，在<code>JDK8</code>中使用尾插法。而红黑树在<code>JDK8</code>才引入，如果已经是红黑树了，则执行红黑树的插入逻辑，如果是链表，在使用尾插法遍历节点时如果发现链表长度大于<code>8</code>了且数组容量小于<code>64</code>时，将链表转换成红黑树后在执行插入，否则执行链表的尾部插入。元素插入完成后，判断哈希表容量是否超过阈值，超过则进行扩容。</p><ol start="5"><li><code>HashMap</code>的线程不安全体现在哪？如何去应对？</li></ol><p>答：在多线程条件下，<code>JDK7</code>的<code>HashMap</code>在扩容时会出现死循环的问题，<code>JDK8</code>的<code>HashMap</code>在插入时会出现值被覆盖的问题。应对这种线程不安全，可以使用同步容器<code>HashTable</code>或并发容器<code>ConcurrentHashMap</code>。推荐使用<code>ConcurrentHashMap</code>。</p><p>以上面试题及答案基本可以应对那些普通公司的一问一答式的面试了，背诵就完事了。</p><p>但有些面试官可能会追着其中某个点一直往下细问，这个时候光靠上面背诵的这点东西就有点力不从心了，你必须对整个<code>HashMap</code>的原理真正的有一定了解才能够从容去应对。</p><p>下面我们针对上面的面试题，阅读<code>JDK8</code>的<code>HashMap</code>源码，真正的去搞懂原理。</p><h2 id="如何存储元素？"><a href="#如何存储元素？" class="headerlink" title="如何存储元素？"></a>如何存储元素？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>元素都存储在这个<code>Node</code>数组里面，我们来看下<code>Node</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// hash值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter/toString/equals/hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是一个单链表的数据结构，也就是说<code>table</code>数组中存储的是一个一个的<code>Node</code>节点，而这每一个<code>Node</code>节点都是一个单链表的头节点，当没有发生哈希冲突时，链表长度为<code>1</code>。</p><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>下面我们来看一些主要的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量-必须为2的整数幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表转化成红黑树的阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从红黑树退化成链表的阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要执行红黑树化的最小数组容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h2 id="有关加载因子loadFactor为什么是0-75？"><a href="#有关加载因子loadFactor为什么是0-75？" class="headerlink" title="有关加载因子loadFactor为什么是0.75？"></a>有关加载因子<code>loadFactor</code>为什么是<code>0.75</code>？</h2><p>还记得文章开头的解答吗？这是一个基于容量和性能考虑的折衷值。如果加载因子设置过大，带来的好处是扩容的门槛提高，节约了内存空间，但出现哈希冲突的几率会变大，从而导致对元素的操作性能下降；如果加载因子设置过小，带来的好处是扩容门槛降低，数组中存储的元素会比较稀疏，不易出现哈希冲突，对元素的操作性能较高。但会存在一定的空间浪费。于是折衷考虑选择了<code>0.75</code>。</p><p>其实这个答案已经很能说明原因了，但有些面试官就是纠结这个数值为什么是<code>0.75</code>，为什么不是<code>0.74</code>或者<code>0.76</code>等。下面我们尝试用一种八股文来对抗面试官：</p><p>为什么加载因子是<code>0.75</code>呢？</p><p>理论：通过预测存储桶是否为空，可以避免链接并利用分支预测。如果存储桶为空的可能性超过<code>0.5</code>，则该存储桶可能为空。</p><p>证明：<code>s</code>代表大小，<code>n</code>代表增加的键数。根据牛顿二项式定理，存储桶为空的概率为：</p><p><code>P(0) = C(n, 0) * (1/s)^0 * (1 - 1/s)^(n - 0)</code></p><p>因此，如果少于<code>log(2)/log(s/(s - 1))</code>个键，当<code>s</code>达到无穷大时并且如果添加的键数使得<code>P(0) = 0.5</code>时，则<code>n/s</code>迅速接近<code>log(2)</code>。</p><p><code>log(2)</code>约等于<code>0.693</code>。</p><p>结论：<code>log(2)</code>不是约等于<code>0.693</code>吗？为什么会选择<code>0.75</code>呢？因为阀值需要一个整数，默认初始容量是<code>16</code>，当加载因子等于<code>0.75</code>时乘积才为整数。<code>0.70/0.71/0.72/0.73/0.74...</code>等等，只有<code>0.75</code>的乘积才是整数。</p><p>以上理论及证明过程来自 <a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap">stackoverflow.com</a></p><p>所以问题来了，为什么默认初始容量是<code>16</code>呢？这…，建议准备面下一家公司了…</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>除了存储元素的<code>table</code>数组，还有以下其它成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set缓存，可用于迭代器</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map元素个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map修改次数，用来实现fail-fast机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阀值，当size&gt;threshold时会触发扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="如何构造HashMap对象？"><a href="#如何构造HashMap对象？" class="headerlink" title="如何构造HashMap对象？"></a>如何构造<code>HashMap</code>对象？</h2><p>一共有四个构造器，但我们常用的只有两个：无参构造器和指定初始容量的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量的构造器，内部调用带两个参数的构造器，传入默认加载因子DEFAULT_LOAD_FACTOR=0.75f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造器，使用默认的初始容量：16，默认的加载因子：0.75f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在开发时，如果我们能提前预估出数据量，建议调用指定初始容量的构造器来创建一个合适容量的<code>HashMap</code>；如果无法预估，最好使用无参构造器。</p><p>我们来看下指定初始容量和指定加载因子的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量负值校验</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 容量最大值校验</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 加载因子合法性校验</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 初始化阀值为初识容量（此处只是进行预初始化，后续调用resize方法时会进行准确赋值）</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化赋值的时候，并不会将阀值<code>threshold</code>设置为<code>initialCapacity * loadFactor</code>，而是预初始化成初始容量，此处会调用<code>tableSizeFor</code>方法得到一个大于等于<code>initialCapacity</code>且最近的<code>2</code>的整数次幂的数，然后赋值给<code>threshold</code>，后续第一次调用<code>put</code>方法进行插入时会进行首次扩容，调用<code>resize</code>方法对<code>threshold</code>进行准确赋值。</p><h2 id="tableSizeFor方法原理"><a href="#tableSizeFor方法原理" class="headerlink" title="tableSizeFor方法原理"></a><code>tableSizeFor</code>方法原理</h2><p><code>tableSizeFor</code>方法是得到一个大于等于<code>initialCapacity</code>且最近的<code>2</code>的整数次幂的数。我们来看<code>JDK8</code>是如何进行巧妙实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要知道位运算符号<code>&gt;&gt;&gt;</code>表示无符号右移，忽略符号位，空位都以<code>0</code>补齐。</p><p>假设<code>cap = 10</code>，那么<code>n = 9</code>。</p><p>执行<code>n != n &gt;&gt;&gt; 1</code>即<code>n = 9 | (9 &gt;&gt;&gt; 1)</code>的步骤是：</p><ul><li><code>9</code>的二进制是<code>1001</code>；</li><li><code>9 &gt;&gt;&gt; 1</code>即：<code>1001 &gt;&gt;&gt; 1 = 0100</code>；</li><li><code>9 | (9 &gt;&gt;&gt; 1) = 1001 | 0100 = 1101</code>。</li></ul><p>接下来依次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">n |&#x3D; n &gt;&gt;&gt; 16;</span><br></pre></td></tr></table></figure><p>过程分别为：</p><p><code>n |= n &gt;&gt;&gt; 2;</code>，此时<code>n = 1101</code>，即：<code>n = 1101 | (1101 &gt;&gt;&gt; 2) = 1101 | 0011 = 1111</code>；</p><p><code>n |= n &gt;&gt;&gt; 4;</code>，此时<code>n = 1111</code>，即：<code>n = 1111 | (1111 &gt;&gt;&gt; 4) = 1111 | 0000 = 1111</code>；</p><p><code>n |= n &gt;&gt;&gt; 8;</code>，此时<code>n = 1111</code>，即：<code>n = 1111 | (1111 &gt;&gt;&gt; 8) = 1111 | 0000 = 1111</code>；</p><p><code>n |= n &gt;&gt;&gt; 16;</code>，此时<code>n = 1111</code>，即：<code>n = 1111 | (1111 &gt;&gt;&gt; 16) = 1111 | 0000 = 1111</code>；</p><p>最后的结果为：<code>n = 1111</code>，转换成十进制等于<code>15</code>，<code>return</code>语句中进行三目判断，最后返回的值为：<code>n + 1 = 16</code>。</p><h2 id="如何插入元素？"><a href="#如何插入元素？" class="headerlink" title="如何插入元素？"></a>如何插入元素？</h2><p>下面我们来看<code>put</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算hash值，调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量tab用于接收成员变量table</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果table数组中无元素，则调用resize()扩容得到一个新的Node&lt;K,V&gt;[]数组并赋值给tab，然后得到新数组的长度为n。</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据hash值计算待插入元素的数组下标索引i（对2取模可转化成位运算）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果i位置无元素，则直接创建Node节点进行赋值插入</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// i位置有元素，说明出现了哈希冲突</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 键key相等则直接进行值覆盖</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 待插入的键不等于下标i处存储的头节点的键</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 判断为红黑树节点，则执行红黑树的插入逻辑</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则为链表结构，进行遍历，binCount用来统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 对e进行赋值</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遍历到尾节点了，e = null</span></span><br><span class="line">                    <span class="comment">// 尾插法插入新元素</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断链表长度binCount &gt;= 7</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 此次循环是第8次，binCount=7，尾插法插入新元素后链表长度为8，调用treeifyBin尝试转换成红黑树</span></span><br><span class="line">                        <span class="comment">// 在treeifyBin方法中，会首先判断tab数组的长度是否小于MIN_TREEIFY_CAPACITY=64，如果小于，则进行resize扩容结束；否则执行树化逻辑。</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 找到了键key相等的节点，结束循环。e = p.next</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 未找到key相等的节点或未遍历到尾部，此时e = p.next，推动链表的遍历。</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的判断中e的值不为null的情况：即链表中找到了key相等的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 进行值value的覆盖</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 回调钩子，子类LinkedHashMap进行了重写</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改次数加一</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">// 容量达到阀值进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 回调钩子</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个<code>put</code>方法的执行流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/jdk/hashmap_put.png" alt="HashMap的put过程"></p><h2 id="如何优雅地进行扩容？"><a href="#如何优雅地进行扩容？" class="headerlink" title="如何优雅地进行扩容？"></a>如何优雅地进行扩容？</h2><p>出现扩容的情况有三种：</p><ol><li>哈希表为空且第一次执行<code>put</code>方法时，会先进行扩容再存储元素。</li><li>当出现哈希冲突，执行尾插法插入元素后，如果链表长度大于<code>8</code>，且数组长度小于<code>MIN_TREEIFY_CAPACITY=64</code>，执行扩容逻辑。</li><li>新插入一个键后（元素直接插入、哈希冲突链表尾插、红黑树插入），<code>++size &gt; threshold</code>容量达到阀值，执行扩容逻辑。</li></ol><p>下面我们来看下扩容<code>resize</code>的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 使用oldTab接收旧的数组table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 如果oldTab为null引用，说明是第一次调用put方法时进行的扩容，则oldCap旧容量为0；否则为旧数组长度。</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧阀值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 定义新容量和新阀值（扩容之后的）</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧容量大于0，则原数组有元素，不是第一次调用put</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 旧容量超过最大容量，已无法进行扩容</span></span><br><span class="line">            <span class="comment">// 设置阀值为最大整型数值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 返回旧数组</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算新容量：oldCap的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 新容量小于最大容量，且旧容量大于等于默认初始容量，则阀值也为原来的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧阀值大于0，说明是调用带参构造器创建的HashMap，且此时旧阀值等于带参构造器中指定的初始容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 第一次调用put才会走到这个if分支</span></span><br><span class="line">        <span class="comment">// 新容量等于带参构造器中指定的容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 其它情况：调用无参构造器创建的HashMap</span></span><br><span class="line">        <span class="comment">// 新容量为：默认初始容量</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 新阀值为：默认加载因子 * 默认初始容量</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用put时，走的上面的else if (oldThr &gt; 0)分支，新阀值未进行赋值，所以等于0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算新阀值：新容量 * 加载因子</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 范围控制，转换成int</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置阀值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 开辟新容量长度的数组空间</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// table引用指向新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果是第一次调用put时执行，oldTab为null。</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 非首次put方法，原table数组中存在元素，执行rehash</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 遍历旧table数组</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放旧table的引用 help gc</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 无哈希冲突</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 新数组newTab赋值</span></span><br><span class="line">                    <span class="comment">// newCap为2的整数幂，hash &amp; 2^n - 1 即对2取模，求出数组下标。</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树逻辑</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 哈希冲突，有链表，将整个链表分隔成两个部分</span></span><br><span class="line">                    <span class="comment">// loHead/loTail链接出一个不需要移动位置的链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead/hiTail链接出一个需要移动位置的链表</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 哈希码 &amp; 旧容量</span></span><br><span class="line">                        <span class="comment">// 结果为0，表示该元素的下标索引值在扩容后不会发生变化</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 链接原链表每一个元素至loHead头节点</span></span><br><span class="line">                            <span class="comment">// 第一次执行do-while循环</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 赋值loHead头节点</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">// 非第一次执行do-while</span></span><br><span class="line">                                <span class="comment">// 链接至loTail</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 如果是第一次执行do-while，则loTail=loHead指向头节点</span></span><br><span class="line">                            <span class="comment">// 否则表示loTail右移一位</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 否则，结果不为0，则该元素的下标索引值在扩容后会改变</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 同样地链接逻辑</span></span><br><span class="line">                            <span class="comment">// 第一次执行do-while循环</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">// 赋值hiHead头节点</span></span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">// 非第一次执行do-while</span></span><br><span class="line">                                <span class="comment">// 链接至hiTail</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            <span class="comment">// 如果是第一次执行do-while，则hiTail=hiHead指向头节点</span></span><br><span class="line">                            <span class="comment">// 否则表示hiTail右移一位</span></span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 执行完do-while循环后，loTail和hiTail都指向出现哈希冲突的原链表的尾部</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 下标索引不需要移动，链表loHead整体移动</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 下标索引需要移动到j + oldCap位置，链表hiHead整体移动</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩容后的新table数组</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在有哈希冲突时，对链表中的元素并没有进行<code>rehash</code>操作，而是将冲突的链表分隔为两个链表，通过计算<code>e.hash &amp; oldCap</code>，如果结果的高一位为<code>0</code>，则表示该链表节点不需要移动位置，链接至<code>loHead</code>节点；如果结果的高一位为<code>1</code>，则表示该链表节点需要移动位置，链接至<code>hiHead</code>节点。<code>do-while</code>循环结束后，以<code>loHead</code>节点为头节点的链表不需要移动数组下标；而以<code>hiHead</code>节点为头节点的链表需要向右移动旧容量<code>oldCap</code>个位置。原链表各节点之间的相对位置未发生改变。</p><h2 id="如何获取元素？"><a href="#如何获取元素？" class="headerlink" title="如何获取元素？"></a>如何获取元素？</h2><p>相比于<code>put</code>插入，<code>get</code>获取元素的逻辑就相对简单了。正常从<code>HashMap</code>中获取元素的最好时间复杂度是常数<code>O(1)</code>。在哈希冲突的情况下：最坏时间复杂度是<code>O(n)</code>，最好时间复杂度是<code>O(log n)</code>。</p><p>下面我们来看下<code>get</code>方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; first, e;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//  table数组已经初始化，且数组中有元素，且key所在下标索引位置有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 第一个key相等，直接返回该节点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// key在后面的链表（红黑树）节点中</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 执行红黑树的查询逻辑，时间复杂度O(log n)</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 遍历链表找到相等的key，返回对应节点。</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在<code>put</code>插入的时候计算下标的方式为<code>(n - 1) &amp; hash</code>，所以<code>get</code>查询的时候以同样方式计算下标，如果该下标位置无元素，那么待查询的<code>key</code>一定不在<code>HashMap</code>中，直接返回<code>null</code>；反之，如果该下标位置有元素，那么则寻找与待查询的<code>key</code>相等的键。</p><p>如何判断<code>key</code>相等？</p><p>在<code>HashMap</code>中，所有判断<code>key</code>是否相等的逻辑都是：先比较<code>hashCode</code>是否相等，再比较<code>equals</code>是否相等。</p><p>这就是为什么建议在重写<code>equals</code>方法的同时最好去重写<code>hashCode</code>方法的一个原因。</p><p>两个<code>key</code>如果<code>hashCode</code>相等，<code>equals</code>不一定不等。</p><h2 id="线程不安全问题是如何产生的？"><a href="#线程不安全问题是如何产生的？" class="headerlink" title="线程不安全问题是如何产生的？"></a>线程不安全问题是如何产生的？</h2><p>对于<code>JDK7</code>，在多线程进行扩容时会产生死循环问题，由于<code>JDK7</code>已成为历史，本文不再赘述，可以参考网上的一些解释。</p><p>而对于<code>JDK8</code>，我们可以看看上文中分析的<code>put</code>插入方法，针对第二个<code>if</code>条件分支，如果未发生哈希冲突，则创建新节点直接进行赋值插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>以上代码在<code>JDK8#HashMap.java</code>源码中分别是第<code>630</code>行和第<code>631</code>行。</p><p>此处如果多个线程同时对同一个<code>HashMap</code>执行<code>put</code>方法，根据<code>hash</code>计算出的下标<code>i</code>相同且<code>i</code>下标处恰好为<code>null</code>没有元素，同时多个线程恰好刚执行完第<code>630</code>行的<code>if</code>条件判断但还未执行第<code>631</code>行的赋值插入。这个时候，如果多个线程按先后顺序往下执行，那么后执行的线程就会覆盖先执行的线程在<code>i</code>下标处插入的值。</p><p>当然在日常的业务开发中，基本上不会使用到<code>HashMap</code>作为成员变量，更多的是用作局部变量进行传参，而且现在已经不推荐使用<code>HashMap</code>进行传参了，除了一些早期项目，或者使用了<code>MyBatis</code>的早期版本<code>ibatis</code>的项目，基本上很少会用到<code>HashMap</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有关<code>HashMap</code>，其实到这里就已经足够了，再往下深入，就是红黑树的查询和插入逻辑了，涉及到红黑树的数据结构和算法，比较复杂。面试如果遇到问红黑树的实现细节的，大可以去反问面试官会不会。</p><p>后面有空会专门写一篇文章讲讲红黑树。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="2020/07/23/javase/jvm/gc-algorithm/"/>
      <url>2020/07/23/javase/jvm/gc-algorithm/</url>
      
        <content type="html"><![CDATA[<p>现代虚拟机的垃圾收集器大多基于分代收集理论，基于该理论，堆内存被划分出各种不同的区域，不同的区域有着不同的垃圾收集算法。</p><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>分代收集理论建立在两个分代假说之上：</p><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的。</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将堆内存划分出不同的区域，然后将回收对象依据其年龄（一次垃圾回收，如果对象未被回收，则其年龄加一）分配到不同的区域进行存储。</p><p>显然，应该将大多数朝生夕死的对象集中在一起，在垃圾回收时只需关注如何保留少量存活的对象，而不是去标记那些大量将被回收的对象；将那些难以消亡的对象也集中在一起，减少对它们回收的频率。这样就有效的在时间和空间开销上做了权衡。</p><p>在堆内存划分出不同的区域之后，垃圾收集器才可以每次只回收其中某个区域的内存——因而才有了<code>Minor GC</code>、<code>Major GC</code>和<code>Full GC</code>回收类型的区分；针对不同区域也采用了适当的垃圾收集算法。</p><p>一切看似美好，但区域划分后会存在一个明显的问题：对象都不是孤立存在的，很可能存在跨代引用。</p><p>现代虚拟机一般都会将堆内存划分出新生代（<code>Young Generation</code>）和老年代（<code>Old Generation</code>）两个基本区域，对于新生代的回收称为<code>Minor GC</code>，但新生代的对象完全有可能被老年代所引用，同样，老年代的对象也完全有可能被新生代所引用，为了找出对应区域中的存活对象，不得不在固定的<code>GC Roots</code>之外，额外遍历老年代或新生代来确保可达性分析的正确性。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会对内存回收带来很大的性能负担。于是有了第三个分代假说：</p><ul><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>这个假说可以认为是前两个分代假说的推论：存在互相引用关系的两个对象，倾向于同时生存或同时死亡的。如果某个新生代对象存在跨代引用，由于老年代对象是难以消亡的，该引用会使新生代对象在被回收时存活下来，随后慢慢晋升至老年代，这时跨代引用就不存在了。</p><p>依据这条假说，我们就不应该再为了少量的跨代引用去扫描整个老年代，也不必浪费空间去记录每一个对象是否存在以及存在哪些跨代引用，只需在新生代上建立一个全局的称为记忆集（<code>Reference Set</code>）的数据结构，这个结构把老年代划分为若干小块，此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Roots</code>进行扫描。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，增加了一定的运行时开销，但跟在收集时扫描整个老年代相比是划算的。</p><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a><code>GC</code>分类</h2><ul><li>新生代收集（<code>Minor GC/Young GC</code>）：对新生代收集。</li><li>老年代收集（<code>Major GC/Old GC</code>）：对老年代收集。目前只有<code>CMS</code>收集器会有单独收集老年代的行为。</li><li>混合收集（<code>Mixed GC</code>）：对整个新生代以及部分老年代收集。目前只有<code>G1</code>收集器会有这种行为。</li><li>整堆收集（<code>Full GC</code>）：对整个堆内存和方法区收集。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ol><li>标记-清除算法</li></ol><p>该算法分为“标记”和“清除”两个阶段：首先使用可达性分析算法标记出所有需要回收的对象，标记完成后统一回收掉所有被标记的对象；也可以反过来，标记所有存活对象，统一回收未被标记的对象。</p><p>缺点：执行效率不稳定，如果堆中存在大量对象需要进行回收，则需要进行大量标记和清除的动作，执行效率随对象数量增长而降低；第二个是内存空间的碎片化问题，标记清除后会产生大量不连续的内存碎片。内存碎片太多会导致当需要分配大对象时无法找到连续的内存空间而不得不提前触发再一次的垃圾回收。</p><ol start="2"><li>标记-复制算法</li></ol><p>为了解决标记-清除算法在面对大量可回收对象时执行效率低的问题，有“大佬”提出了一种称为“半区复制”的垃圾收集算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完的时候才将其存活着的对象复制到另外一块内存上，然后再把已使用过的内存一次性清除。如果第一半内存中多数对象是存活的，那这种算法将会产生大量的内存间复制的开销，但对于多数对象是可回收状态时，算法就只需复制少量的存活对象，而且每次都是针对一半内存进行回收，内存碎片问题几乎不会出现。这种算法实现容易，执行效率也非常高，但其代价是可用内存缩小为了原来的一半。空间利用率太低。</p><p>现代虚拟机大多采用了该算法去回收新生代，有研究表明：新生代中朝生夕死的对象有<code>98%</code>都熬不过第一轮垃圾收集。因此并不需要将新生代划分为大小相等的两块，更好的做法是将新生代划分为一块较大的<code>Eden</code>区域和两块较小的<code>Survivor</code>空间，每次内存分配时只使用<code>Eden</code>区域和其中一块<code>Survivor</code>区域。当发生垃圾回收时，将<code>Eden</code>区和<code>Survivor</code>区存活的对象一次性复制到另一块<code>Survivor</code>区域上，然后直接回收掉<code>Eden</code>区和那块使用过的<code>Survivor</code>区。<code>HotSpot</code>虚拟机默认<code>Eden</code>和<code>Survivor</code>区域的大小比例是<code>8 : 1</code>，也就是说新生代中可用的内存空间为整个新生代的<code>90%</code>，这样空间利用率就达到了<code>90%</code>，虽然还有<code>10%</code>的另一块<code>Survivor</code>区域被浪费，但已经比较理想了。当然，任何人都不能保证研究在实际情况中的正确性，无法保证每次对新生代的回收都只有不多于<code>10%</code>的对象存活，于是存在一个兜底的安全设计：当另一块<code>Survivor</code>区域空间不足以容纳一次<code>Young GC</code>之后存活的对象时，就需要其它内存区域（大多指老年代）进行内存分配担保，将多余的存活对象直接复制到老年代。</p><ol start="3"><li>标记整理</li></ol><p>标记-复制算法在对象存活率较高时就会产生大量的内存间复制开销，优化过后的算法也需要浪费<code>10%</code>的空间，且需要其它空间进行内存分配担保。对于老年代来说，大部分对象都是难以消亡的，所以该算法并不适用于老年代。</p><p>针对老年代对象难以消亡的特征，有人提出了另一种有针对性的“标记-整理”算法，标记过程仍然采用的是可达性分析算法，但标记完成后并不是立刻进行回收，而是让所有存活对象都向内存空间一端移动，然后去清理边界以外的内存。</p><p>标记整理算法和标记清除算法的本质差异在于是否移动存活的对象，标记清除算法是不移动的，而标记整理算法是移动的。</p><p>是否移动存活对象是一个优缺点并存的风险决策。如果移动对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有引用是一个极为负重的操作，而且这种移动对象操作必须全程暂停用户线程才能执行，这个暂停被称为<code>Stop The World</code>。如果不移动对象，那必然会造成内存碎片问题，而要解决内存碎片问题，就需要依赖更为复杂的内存分配器和内存访问器来解决，无疑加重了内存访问的负担，使程序的吞吐量降低。所以，无论是否移动对象都存在弊端，移动则出现<code>Stop The World</code>；不移动则可以忽略<code>Stop The World</code>的时间，但会产生内存碎片问题，且程序吞吐量降低。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解<code>Java</code>虚拟机：<code>JVM</code>高级特性与最佳实践（第<code>3</code>版）》 - 周志明</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器</title>
      <link href="2020/07/23/javase/jvm/gcer/"/>
      <url>2020/07/23/javase/jvm/gcer/</url>
      
        <content type="html"><![CDATA[<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实践者。根据分代收集理论，<code>HotSpot</code>虚拟机提供了多种作用于不同分代的垃圾收集器，它们是不同时代的思想汇聚。</p><h2 id="Serial新生代收集器"><a href="#Serial新生代收集器" class="headerlink" title="Serial新生代收集器"></a><code>Serial</code>新生代收集器</h2><p>最基础且历史最悠久的收集器，曾是<code>HotSpot</code>虚拟机新生代区域的唯一选择。它选用的是标记-复制算法，单线程收集，当它开始工作时，其它工作线程必须挂起，直到它回收内存完毕。<code>Stop The World</code>无法避免。但好处是单线程工作，对于核数较少的处理器来说，没有线程的上下文切换开销，收集效率高，适用于客户端模式的虚拟机。</p><h2 id="Serial-Old老年代收集器"><a href="#Serial-Old老年代收集器" class="headerlink" title="Serial Old老年代收集器"></a><code>Serial Old</code>老年代收集器</h2><p>与<code>Serial</code>新生代收集器配合使用，回收老年代，同样使用单线程收集，选用的是标记-整理算法，适用于客户端模式的虚拟机。</p><h2 id="ParNew新生代收集器"><a href="#ParNew新生代收集器" class="headerlink" title="ParNew新生代收集器"></a><code>ParNew</code>新生代收集器</h2><p><code>ParNew</code>新生代收集器实质是<code>Serial</code>收集器的多线程并行版本，在多核处理器的虚拟机上效率会大幅提高。选用的同样是标记-复制算法。它的特点是：除了<code>Serial</code>收集器外，目前只有它能与<code>CMS</code>收集器配合工作。大部分服务端模式的虚拟机选用该收集器回收新生代。</p><h2 id="CMS老年代收集器"><a href="#CMS老年代收集器" class="headerlink" title="CMS老年代收集器"></a><code>CMS</code>老年代收集器</h2><p><code>CMS (Concurrent Mark Sweep：并发标记-清除)</code>收集器是一种以获取最短回收停顿时间（<code>Stop The World</code>）为目标的收集器。它的回收过程分为四个阶段：</p><ul><li>初始标记（<code>CMS initial mark</code>）</li><li>并发标记（<code>CMS concurrent mark</code>）</li><li>重新标记（<code>CMS remark</code>）</li><li>并发清除（<code>CMS concurrent sweep</code>）</li></ul><ol><li>初始标记：标记<code>GC Roots</code>能直接关联到的对象，速度很快，但存在<code>Stop The World</code>停顿。</li><li>并发标记：从<code>GC Roots</code>的直接关联对象开始遍历整个对象图，耗时较长，但遍历线程与用户线程可并发执行。无<code>Stop The World</code>停顿。</li><li>重新标记：修正并发标记阶段，用户线程并发执行时导致标记产生变动的那一部分对象的标记记录（增量更新），存在<code>Stop The World</code>停顿，且一般比初始标记阶段停顿时间长。</li><li>并发清除：清理删除掉标记阶段判断为不可达的对象，清理线程可与用户线程并发执行。</li></ol><p>由于存在并发标记和并发清除阶段，用户线程在并发执行期间完全有可能产生新的垃圾对象，但这部分对象出现在标记过程结束之后，本次回收无法进行处理，只能等到下一次老年代内存回收时才能被清理掉，这部分垃圾被称为“浮动垃圾”。</p><p>在用户线程和收集器线程并发执行期间，是可能会有对象需要进入老年代的，这时就需要老年代预留一定的内存空间。在<code>Java5</code>的虚拟机中，默认设置是老年代内存使用了<code>68%</code>后就会触发<code>CMS</code>收集器回收老年代。这是一个比较保守的值，可以使用参数<code>-XX: CMSInitiatingOccu-pancyFraction</code>来调整这个默认值。到了<code>Java6</code>时，默认设置提高到了<code>92%</code>，但这又会存在一个问题，如果<code>CMS</code>收集器在并发期间，预留的内存无法满足用户线程的需要，就会出现一次“并发失败”，这时，虚拟机采用降级保护方案，挂起用户线程（<code>Stop The World</code>），临时启用<code>Serial Old</code>老年代收集器重新进行老年代的回收。总的来说，<code>-XX: CMSInitiatingOccu-pancyFraction</code>这个参数设置的太高会容易出现“并发失败”问题，性能不增反降；太低又会导致内存利用率不高，且回收频率会上升。所以，用于生产环境时应谨慎调整。</p><p>标记-清除算法不可避免的问题就是内存碎片问题，当老年代内存碎片过多时，没有连续空间来容纳大对象，即使还有很多内存没有使用，还是会触发<code>Full GC</code>。<code>CMS</code>收集器提供了一个<code>-XX: +UseCMS-CompactAtFullCollection</code>开关参数（默认开启，<code>Java9</code>废弃）用于在<code>CMS</code>收集器不得不进行<code>Full GC</code>时开启内存碎片的整理过程，此过程需要移动对象，无法进行并发，出现<code>Stop The World</code>停顿。同时<code>CMS</code>收集器还提供了<code>-XX: CMSFullGCsBefore-Compaction</code>参数（默认值为<code>0</code>：每次<code>Full GC</code>都进行碎片整理）要求收集器在执行过指定次数不整理碎片的<code>Full GC</code>后，下一次进入<code>Full GC</code>前先进行碎片整理。</p><h2 id="Parallel-Scavenge新生代收集器"><a href="#Parallel-Scavenge新生代收集器" class="headerlink" title="Parallel Scavenge新生代收集器"></a><code>Parallel Scavenge</code>新生代收集器</h2><p>吞吐量优先收集器。采用标记-复制算法。提供开关参数<code>-XX: +UseAdaptiveSizePolicy</code>让虚拟机根据当前系统的运行情况收集性能监控信息，动态调整新生代大小、<code>Eden</code>和<code>Survivor</code>区域比例等参数以提供最合适的停顿时间或最大吞吐量。</p><h2 id="Parallel-Old老年代收集器"><a href="#Parallel-Old老年代收集器" class="headerlink" title="Parallel Old老年代收集器"></a><code>Parallel Old</code>老年代收集器</h2><p>吞吐量优先收集器。采用标记-整理算法，多线程并发收集。与<code>Parallel Scavenge</code>新生代收集器搭配使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解<code>Java</code>虚拟机：<code>JVM</code>高级特性与最佳实践（第<code>3</code>版）》 - 周志明</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回收前的自救</title>
      <link href="2020/07/20/javase/jvm/finalize-before-gc/"/>
      <url>2020/07/20/javase/jvm/finalize-before-gc/</url>
      
        <content type="html"><![CDATA[<p>即使在可达性分析算法中被判定为不可达的对象，也不是“非死不可”的，还有一种自救的方法。</p><p>要宣告一个对象已死，至少要经历两次标记过程：在被可达性分析算法判定为不可达后会被标记一次；随后会对不可达对象进行筛选，筛选条件是该对象是否有必要执行<code>finalize()</code>方法，如果对象没有重写<code>finalize()</code>方法，或者<code>finalize()</code>在上一次垃圾回收时被调用过，则该对象没有必要执行<code>finalize()</code>方法，会被第二次标记。对象即被判定为了“死亡”。</p><p>如果对象被判定为有必要执行<code>finalize()</code>方法，虚拟机会将该对象放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一个由虚拟机自动创建的、低调度优先级的<code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法。这里的执行是虚拟机会触发该方法的开始执行，但不会等待它们执行结束。原因是该方法的方法体是经过重写的，无法保证立刻执行结束（等待或死循环的情况），很可能造成<code>F-Queue</code>队列中的其它对象永远处于等待状态，导致整个垃圾回收系统崩溃。</p><p><code>finalize()</code>方法是对象逃离死亡的最后一次机会，触发执行后，垃圾收集器将对<code>F-Queue</code>队列中的对象进行第二次小规模标记，如果对象要在<code>finalize()</code>方法中拯救自己——只需重新与引用链上的任何一个对象建立关联即可，例如将自身（<code>this</code>）赋值给某个类变量或者某个对象的成员变量，那在下一次垃圾回收时该对象将被移出“即将回收”的集合；如果该对象此时还未逃脱，那基本可以说它已经“死了”。</p><p>对象自救代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGc SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize&quot;</span>);</span><br><span class="line">        <span class="comment">// 将this赋值给当前类的静态变量进行自救</span></span><br><span class="line">        FinalizeEscapeGc.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGc();</span><br><span class="line">        <span class="comment">// 第一次会进行自救</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// Finalizer线程优先级较低，暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次被判定为“死亡”</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// Finalizer线程优先级较低，暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize</span><br><span class="line">alive</span><br><span class="line">dead</span><br></pre></td></tr></table></figure><p>可看到<code>finalize()</code>方法被执行了，且第一次“自救成功”，第二次则彻底“死亡”。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解<code>Java</code>虚拟机：<code>JVM</code>高级特性与最佳实践（第<code>3</code>版）》 - 周志明</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象是“生”是“死”</title>
      <link href="2020/07/20/javase/jvm/object-is-alive-or-dead/"/>
      <url>2020/07/20/javase/jvm/object-is-alive-or-dead/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>垃圾收集器对堆内存进行回收时，首先要判断堆中的对象是否还存活。</p><p>对象是“生存”还是“死亡”？这是一个问题。经典的判断算法是引用计数法，但存在一定缺陷。现代虚拟机是通过可达性分析算法判断对象是否存活。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用计数法是一个很好理解的算法。在对象中添加一个引用计数器，每当有一个引用指向该对象时，就将计数器值加一；当引用失效时，计数器值减一。任何时刻计数器值为零的对象可认为是“死亡”的。</p><p>一切都看似很正常，但实际上存在循环引用的问题。请看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：<code>testGc()</code>方法被调用时，<code>JVM</code>同步创建一个栈帧压入当前执行线程的虚拟机栈中，随后，虚拟机栈中存在两个引用<code>objA</code>和<code>objB</code>分别指向堆内的两个<code>new ReferenceCountingGc()</code>对象，然后，堆内两个对象的成员变量<code>instance</code>互相指向对方，再然后，将虚拟机栈内的引用指向<code>null</code>，最后触发<code>gc</code>。此时，堆内的这两个对象互相引用着对方，引用计数器的值不为零，但它们已经无法再由程序进行访问了，所以如果采用引用计数算法进行垃圾回收，这两个对象将无法被回收，即会出现内存泄露问题。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>现代标准虚拟机都是采用可达性分析算法判断对象是否存活。基本思路是通过一系列称为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到<code>GC Roots</code>间没有任何引用链相连，则称该对象是不可达的，即需要被回收。</p><p>在<code>Java</code>技术体系里，固定可作为<code>GC Roots</code>的对象包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的局部变量表）中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，即一个<code>Java</code>类的引用类型静态变量。</li><li>在方法区中常量引用的对象，例如字符串常量池中的引用。</li><li>在本地方法栈中本地<code>Native</code>方法引用的对象。</li><li>虚拟机内部的引用，例如基本数据类型对应的<code>Class</code>对象；一些常驻的异常类对象，例如<code>NullPointException</code>和<code>OutOfMemoryError</code>等，另外还有系统类加载器类对象。</li><li>所有被同步锁（<code>synchronized</code>）持有的对象。</li><li>反应虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调和本地代码缓存等。</li></ul><p>以上是固定作为<code>GC Roots</code>节点集的对象，但虚拟机还会根据所选垃圾收集器和当前进行垃圾回收的内存区域，可以将一些其它对象“临时性”地加入节点集，共同组成完整的<code>GC Roots</code>集合，确保可达性分析的正确性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解<code>Java</code>虚拟机：<code>JVM</code>高级特性与最佳实践（第<code>3</code>版）》 - 周志明</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机是如何运行字节码的</title>
      <link href="2020/07/20/javase/jvm/run-class/"/>
      <url>2020/07/20/javase/jvm/run-class/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么Java程序要在虚拟机上运行？"><a href="#为什么Java程序要在虚拟机上运行？" class="headerlink" title="为什么Java程序要在虚拟机上运行？"></a>为什么<code>Java</code>程序要在虚拟机上运行？</h2><p><code>Java</code>程序的运行离不开<code>Java</code>运行时环境，又称为<code>JRE</code>，它是<code>Java</code>程序的最小可运行环境，包含<code>Java</code>虚拟机和<code>Java</code>的核心类库。我们每天都在接触的<code>JDK</code>实际上就包含了<code>JRE</code>，同时在<code>/bin</code>目录下还有一些其它的小工具等。</p><p>它们的范围大小比较关系是：<code>JDK</code> &gt; <code>JRE</code> &gt; <code>JVM</code>。</p><p>对于虚拟机来说，它所能运行的是以<code>.class</code>结尾的字节码文件，我们平时写的<code>.java</code>源文件都需要经过编译器编译成字节码。</p><p>通俗一点说，虚拟机只认字节码，不管你是不是<code>Java</code>语言，只要你能编译成字节码就能在我的虚拟机上运行，例如Scala语言，它可以被编译成字节码运行在<code>Java</code>虚拟机上，且可以调用<code>Java</code>的所有类库。</p><p>字节码的意义在于什么呢？在于只要有了字节码，就可以在不同平台的虚拟机实现上运行，即：“一次编译，到处运行”。</p><p>虚拟机的另一个特点是它能够进行自动内存管理和垃圾回收，不像<code>C++</code>语言那样需要开发者手动进行内存的分配与回收，这一点有利也有弊，“利”是方便了开发者，无需过多关注内存，将精力放在程序的业务逻辑上；“弊”是可能会由于开发者的小失误，导致内存溢出，从而使程序崩溃。于是内存管理和垃圾回收出现了一些可以调优的地方。</p><h2 id="虚拟机是如何运行字节码的？"><a href="#虚拟机是如何运行字节码的？" class="headerlink" title="虚拟机是如何运行字节码的？"></a>虚拟机是如何运行字节码的？</h2><p>从虚拟机视角看，执行<code>Java</code>代码首先需要将它被编译而成的<code>.class</code>字节码文件加载到<code>Java</code>虚拟机中，加载后的<code>Java</code>类会被存放至方法区中，实际运行时，虚拟机会执行方法区内的代码。</p><p>对于虚拟机来说，在实际运行时会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有些区域的生命周期和虚拟机进程一致，而有些区域的生命周期和用户线程保持一致。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>根据《<code>Java</code>虚拟机规范》的规定，运行时期虚拟机内部区域划分如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/jvm/runtime-data-area.png" alt="运行时数据区"></p><p>这也是我们常说的<code>JVM</code>内存模型。下面我们对每个区域进行详细说明。</p><ol><li>程序计数器</li></ol><p>这是一块比较小的内存区域，简单的理解就是记录了当前线程正在运行的字节码的行数。对于单核<code>CPU</code>来说，实现多线程的方式是进行线程上下文切换，线程在运行过程中被挂起，当再次切换回来时需要回到之前运行的位置，程序计数器就是来记录该位置的一块内存区域，每个线程各自记录各自的，不会出现<code>OutOfMemoryError</code>错误，它是线程隔离的数据区。</p><ol start="2"><li>虚拟机栈</li></ol><p>虚拟机栈描述的是<code>Java</code>方法执行的线程内存模型，在运行过程中，每当调用一个<code>Java</code>方法，虚拟机会在当前线程的虚拟机栈中同步创建一个栈帧用来存储该方法的信息，包括局部变量表、操作数栈、动态连接和方法出口等信息。当退出当前调用的方法时，虚拟机栈会弹出该栈帧，无论是正常返回还是异常退出。也就是说，每一个<code>Java</code>方法的调用到结束都对应着一个栈帧在当前线程的虚拟机栈中入栈和出栈的过程。</p><p>局部变量表存放了编译期可知的<code>Java</code>基本数据类型、对象引用和<code>returnAddress</code>类型（指向方法<code>return</code>返回后将要执行的字节码指令的地址）。其中基本数据类型（<code>boolean</code>/<code>byte</code>/<code>char</code>/<code>short</code>/<code>int</code>/<code>float</code>/<code>long</code>/<code>double</code>）在局部变量表中以局部变量槽的形式表示，长度为<code>64</code>的<code>double</code>和<code>long</code>类型会占用两个变量槽，其余的都只会占用一个变量槽。当一个方法开始执行时，栈帧中的局部变量表内存大小就已经确定了，不会在运行期间动态改变。</p><p>如果线程请求的栈深度大于虚拟机栈所允许的深度（递归调用），将抛出<code>StackOverflowError</code>异常；如果线程申请栈空间时空间不足，则会抛出<code>OutOfMemoryError</code>异常。</p><ol start="3"><li>本地方法栈</li></ol><p>本地方法栈描述的是本地<code>Native</code>方法执行的线程模型，其作用与虚拟机栈一致。</p><ol start="4"><li>堆</li></ol><p>堆内存是虚拟机管理的内存中最大的一块，其生命周期和虚拟机进程保持一致。有一句话是这样说的：“<code>new</code>出来的对象都在堆上”。堆内存是垃圾收集器所管理的内存区域，现代垃圾收集器大部分是基于分代收集理论设计的，所以堆内存又被细分为“新生代”、“老年代”、“永久代”、“Eden区”、“From Survivor区”和“To Survivor区”。再次细划出这些区域的原因只是为了更好的的分配和回收内存。</p><p>堆内存是支持扩展的，可通过参数<code>-Xmx</code>（最大堆内存）和<code>-Xms</code>（最小堆内存）设置。为了避免<code>GC</code>后堆内存重新分配，通常将两者的值设为一样。</p><ol start="5"><li>方法区</li></ol><p>方法区是存放字节码的内存区域，当一个字节码文件被加载后，会将其对应类型信息、常量、静态变量和即时编译器编译后的代码缓存等数据保存至方法区。</p><p>说到方法区，不得不说到永久代的概念，在虚拟机的早期实现中，标准<code>HotSpot</code>虚拟机的垃圾收集器所管理的内存区域包含了方法区，所以方法区又被称为永久代，但实际上<code>HotSpot</code>虚拟机只是用永久代来实现方法区，为了省去专门为方法区提供内存管理的工作。在<code>Java6</code>时代，永久代就被放弃了，改为使用本地内存来实现方法区。到<code>Java7</code>时，原本存放在永久代的字符串常量池和静态变量被移动到堆内存中。而到了<code>Java8</code>时，永久代完全被抛弃，取而代之的是本地内存中的元空间，原本存在于永久代中的类型信息和代码缓存等数据被移到了元空间中。</p><ol start="6"><li>运行时常量池</li></ol><p>运行时常量池属于方法区的一部分，它存放的是常量池表，包含字面量和符号引用。该内存区域可以在运行期动态改变，常用的是<code>String</code>类的<code>intern()</code>方法，受方法区内存大小限制，该区域也会抛出<code>OutOfMemoryError</code>异常。</p><h3 id="字节码如何被执行？"><a href="#字节码如何被执行？" class="headerlink" title="字节码如何被执行？"></a>字节码如何被执行？</h3><p>对于<code>HotSpot</code>虚拟机来说，它所做的工作是将字节码翻译成机器码。而翻译有两种形式：第一种是解释执行，逐条将字节码翻译成机器码并执行；第二种是即时编译，将一个方法所包含的所有字节码翻译成机器码后再执行。</p><p>前者的优点是无需等待编译，而后者的优点是实际运行速度更快。<code>HotSpot</code>虚拟机采用了混合模式，综合两种形式，先解释执行字节码，通过热点代码探测技术发现热点代码后，以方法为单位进行即时编译。</p><p><code>HotSpot</code>虚拟机包含多个即时编译器：<code>C1</code>和<code>C2</code>等。</p><p><code>C1</code>又叫做<code>Client</code>编译器，面向的是对启动性能有要求的客户端<code>GUI</code>程序，采用的优化手段相对简单，因此编译时间较短。</p><p><code>C2</code>又叫做<code>Server</code>编译器，面向的是对峰值性能有要求的服务端程序，采用的优化手段相对复杂，因此编译时间较长，但生成的机器码的执行效率更高。</p><p>从<code>Java7</code>开始，<code>HotSpot</code>采用分层编译：热点方法首先会被<code>C1</code>编译，然后热点方法中的热点会进一步被<code>C2</code>编译。为了不影响程序的正常运行，热点方法的编译是放在子线程中进行的。<code>HotSpot</code>会根据<code>CPU</code>的核数设置即时编译的线程数，并按照<code>1:2</code>的比例分配给<code>C1</code>和<code>C2</code>编译器。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解<code>Java</code>虚拟机：<code>JVM</code>高级特性与最佳实践（第<code>3</code>版）》 - 周志明</li><li>《深入拆解<code>Java</code>虚拟机》 - 极客时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何为引用</title>
      <link href="2020/07/20/javase/jvm/what-is-quote/"/>
      <url>2020/07/20/javase/jvm/what-is-quote/</url>
      
        <content type="html"><![CDATA[<p>无论是通过引用计数算法还是通过可达性分析算法判断对象是否存活都离不开“引用”这个概念，那到底什么是“引用”呢？</p><p><code>Java</code>语言中狭隘的“引用”定义是：如果<code>Reference</code>类型的数据中存储的数值代表的是另一块内存区域的起始地址，就称该<code>Reference</code>数据是代表某块内存（某个对象）的引用。在这种定义下，一个对象只存在两种状态：“被引用”/“未被引用”。这样的定义很严谨，但却缺少了一点灵活的空间，就像这个社会一样，不是所有人都值得活着，那些人民子弟兵值得永远存在，但那些犯罪的恶徒多活一秒都是对社会的污染。在<code>Java</code>中也是一样，堆上的对象不是所有的都是必须的，当内存空间出现紧张时，一些对象将会被抛弃。</p><p>在<code>JDK 1.2</code>版本后，<code>Java</code>中的引用分为四种类型：强引用（<code>Strongly Reference</code>）、软引用（<code>Soft Reference</code>）、弱引用（<code>Weak Reference</code>）和虚引用（<code>Phantom Reference</code>），这四种引用强度依次减弱。</p><ol><li>强引用（<code>Strongly Reference</code>）</li></ol><p>强引用是狭隘的引用定义，被引用的对象只会出现两种状态：“被引用”和“未被引用”。这种引用关系很常见，即类似于<code>Object obj = new Object()</code>这种直接赋值的，只要强引用关系还在，堆内的对象就永远不会被回收。</p><ol start="2"><li>软引用（<code>Soft Reference</code>）</li></ol><p>软引用描述的是还有用，但不是必须的一类对象。只被软引用关联着的对象在虚拟机将要发生内存溢出前，会将这类对象列进回收范围之中进行二次回收，如果将它们回收完成后内存还是不足，才会抛出内存溢出异常。<code>Java</code>中提供<code>SoftReference</code>类实现软引用。</p><ol start="3"><li>弱引用（<code>Weak Reference</code>）</li></ol><p>弱引用描述的也是那些非必须对象，但它的强度比软引用要弱一点，被弱引用关联着的对象只能活到下一次垃圾回收发生的时刻。当垃圾回收开始工作时，无论内存是否充足，都会回收掉弱引用的对象。<code>Java</code>中提供了<code>WeakReference</code>类实现弱引用。</p><ol start="4"><li>虚引用（<code>Phantom Reference</code>）</li></ol><p>虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会影响该对象的生存周期，也无法通过虚引用得到一个实例对象。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被垃圾回收时收到一个系统通知。<code>Java</code>中提供了<code>PhantomReference</code>类实现虚引用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解<code>Java</code>虚拟机：<code>JVM</code>高级特性与最佳实践（第<code>3</code>版）》 - 周志明</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勇闯算法-在行列都排好序的矩阵中找指定的数</title>
      <link href="2020/07/14/algorithm/coding-interview-guide/arraysandmatrices/solution01/"/>
      <url>2020/07/14/algorithm/coding-interview-guide/arraysandmatrices/solution01/</url>
      
        <content type="html"><![CDATA[<p>题目来源：《程序员代码面试指南-IT名企算法与数据结构最优解》-左程云著</p><p>牛客网在线<code>OJ</code>系统地址：<a href="https://www.nowcoder.com/practice/b929be9dbbaa489a91afa3fec195c228?tpId=101&tqId=33069&tPage=1&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking">传送门</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个<code>N × M</code>的整型矩阵<code>matrix</code>和一个整数<code>K</code>，<code>matrix</code>的每一行每一列都是排好序的。实现一个函数，判断<code>K</code>是否在<code>matrix</code>中。</p><blockquote><p>要求：</p><p>时间复杂度为<code>O(N + M)</code>，额外空间复杂度为<code>O(1)</code>。</p></blockquote><p>备注：</p><p>1 ⩽ N, M ⩽1000</p><p>0 ⩽ K, 矩阵中的数 ⩽ 10^9^</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行有三个整数<code>N</code>，<code>M</code>，<code>K</code>；</p><p>接下来<code>N</code>行，每行<code>M</code>个整数为输入的矩阵。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>若<code>K</code>存在于矩阵中输出<code>&quot;Yes&quot;</code>，否则输出<code>&quot;No&quot;</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4 5</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 5 6</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4 233</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 5 6</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>由于矩阵中的行和列都是排好序的，我们可以知道最后一列是每一行的最大值，最后一行是每一列的最大值。整个矩阵的最大值在右下角。</p><p>要想减少时间复杂度，我们必须能够快速排除某些行或列，基于最后一列或行是每一行或列的最大值的特点，我们可以从矩阵右上角或左下角开始查找，如果不是指定的数，我们就可以排除掉一行或一列了。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><h3 id="思路一：从矩阵右上角开始查找"><a href="#思路一：从矩阵右上角开始查找" class="headerlink" title="思路一：从矩阵右上角开始查找"></a>思路一：从矩阵右上角开始查找</h3><ol><li>从矩阵最右上角的数开始查找（<code>row=0,col=M-1</code>：第<code>0</code>行，第<code>M-1</code>列）。</li><li>比较当前数<code>matrix[row][col]</code>与<code>K</code>的关系：</li></ol><ul><li>如果等于<code>K</code>，则找到了，返回<code>&quot;Yes&quot;</code>，整个过程结束。</li><li>如果大于<code>K</code>，则该列被排除，令<code>col=col-1</code>，重复步骤<code>2</code>。</li><li>如果小于<code>K</code>，则该行被排除，令<code>row=row+1</code>，重复步骤<code>2</code>。</li></ul><ol start="3"><li>如果找到越界都没有找到与<code>K</code>相等的数，则返回<code>&quot;No&quot;</code>，整个过程结束。</li></ol><h3 id="思路二：从矩阵左下角开始查找"><a href="#思路二：从矩阵左下角开始查找" class="headerlink" title="思路二：从矩阵左下角开始查找"></a>思路二：从矩阵左下角开始查找</h3><ol><li>从矩阵最左上角的数开始查找（<code>row=N-1,col=0</code>：第<code>N-1</code>行，第<code>0</code>列）。</li><li>比较当前数<code>matrix[row][col]</code>与<code>K</code>的关系：</li></ol><ul><li>如果等于<code>K</code>，则找到了，返回<code>&quot;Yes&quot;</code>，整个过程结束。</li><li>如果大于<code>K</code>，则该行被排除，令<code>row=row-1</code>，重复步骤<code>2</code>。</li><li>如果小于<code>K</code>，则该列被排除，令<code>col=col+1</code>，重复步骤<code>2</code>。</li></ul><ol start="3"><li>如果找到越界都没有找到与<code>K</code>相等的数，则返回<code>&quot;No&quot;</code>，整个过程结束。</li></ol><h2 id="代码实现（Java）"><a href="#代码实现（Java）" class="headerlink" title="代码实现（Java）"></a>代码实现（<code>Java</code>）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// receive input params</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">        <span class="comment">// build matrix</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                matrix[i][j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do check</span></span><br><span class="line">        <span class="keyword">boolean</span> containsOne = isContainsOne(matrix, k);</span><br><span class="line">        System.out.println(containsOne ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// boolean containsTwo = isContainsTwo(matrix, k);</span></span><br><span class="line">        <span class="comment">// System.out.println(containsTwo ? &quot;Yes&quot; : &quot;No&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断方式一：双重for循环</span></span><br><span class="line"><span class="comment">     * 外层循环矩阵每一行</span></span><br><span class="line"><span class="comment">     * 内层循环矩阵每一列</span></span><br><span class="line"><span class="comment">     * 相等直接返回true；</span></span><br><span class="line"><span class="comment">     * 若小于k，则排除当前行，结束内层循环，遍历下一行。</span></span><br><span class="line"><span class="comment">     * 若大于k，则排除当前列，j--，内存循环进入下一次。</span></span><br><span class="line"><span class="comment">     * 若双重循环完成都未找到k，则返回false。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainsOne</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> value = ints[j];</span><br><span class="line">                <span class="keyword">if</span> (value == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断方式二：while循环</span></span><br><span class="line"><span class="comment">     * 越界条件：行遍历完或列遍历完</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContainsTwo</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span> (value == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; k) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 程序员代码面试指南-IT名企算法与数据结构最优解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员代码面试指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-第242题：有效的字母异位词</title>
      <link href="2020/07/14/algorithm/leetcode/easy/242/"/>
      <url>2020/07/14/algorithm/leetcode/easy/242/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串<code>s</code>和<code>t</code> ，编写一个函数来判断<code>t</code>是否是<code>s</code>的字母异位词。</p><p>示例<code>1</code>:</p><p>输入: <code>s = &quot;anagram&quot;, t = &quot;nagaram&quot;</code><br>输出: <code>true</code></p><p>示例<code>2</code>:</p><p>输入: <code>s = &quot;rat&quot;, t = &quot;car&quot;</code><br>输出: <code>false</code></p><p>说明: 你可以假设字符串只包含小写字母。</p><p>进阶: 如果输入字符串包含<code>Unicode</code>字符怎么办？你能否调整你的解法来应对这种情况？</p><p>来源：力扣（<code>LeetCode</code>）<br>链接：<code>https://leetcode-cn.com/problems/valid-anagram</code><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>思路：首先考虑特殊情况，如果字符串<code>s</code>和<code>t</code>都为空字符串，则可认为它们互为字母异位词；如果字符串<code>s</code>和<code>t</code>连长度都不相等，则一定不为字母异位词。然后再考虑如何进行判断，两个字符串中都只包含<code>26</code>个小写的英文字母，如果两个字符串是字母异位词，那么一定满足：每一个小写英文字母在字符串<code>s</code>中出现的次数等于在字符串<code>t</code>中出现的次数。于是，我们只需分别对每一个小写英文字母在两个字符串中出现的次数进行计数，然后比较是否相等即可。</p><p>具体到代码实现层面，由于两个字符串互为字母异位词的前提条件是其长度相等，所以在计数时我们可以同时对两个字符串进行遍历；另一方面，分别计数可以转换成对第一个字符串<code>s</code>进行计数累加，而对另一个字符串<code>t</code>进行计数递减，最终如果每一个小写英文字母的累计结果为<code>0</code>，则可明确这两个字符串互为字母异位词，只要出现一个小写英文字母的累计结果不为<code>0</code>，则不满足条件。</p><p>如何对每一个小写英文字母进行计数？可定义一个长度为<code>26</code>的<code>int</code>数组，字母<code>a</code>到<code>z</code>依次对应下标索引<code>0</code>到<code>25</code>。在遍历字符串<code>s</code>时，每次遇到<code>a</code>则将索引<code>0</code>位置的值加一，以此类推；而当遍历字符串<code>t</code>时，每次遇到<code>a</code>则将索引<code>0</code>位置的值减一。直到遍历完成，判断数组中的所有元素是否都为<code>0</code>，如果是，则<code>s</code>和<code>t</code>互为字母异位词，否则不是。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 空字符串情况</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span> &amp;&amp; t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 长度不相等情况</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符串转字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] tc = t.toCharArray();</span><br><span class="line">    <span class="comment">// 定义字母计数器</span></span><br><span class="line">    <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 同时遍历两个字符数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,length = sc.length;i &lt; length;i++) &#123;</span><br><span class="line">        <span class="comment">// 字母对应下标位置的值加一</span></span><br><span class="line">        counter[sc[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="comment">// 字母对应下标位置的值减一</span></span><br><span class="line">        counter[tc[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : counter) &#123;</span><br><span class="line">        <span class="comment">// 存在一个计数不为0的则可确定不是字母异位词</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶问题：</p><p>如果输入字符串包含<code>Unicode</code>字符怎么办？</p><p>思路：<code>Unicode</code>字符可定义<code>100</code>万个以上的唯一字符，如果还选择使用数组来计数，那么需要开辟出一块非常大的内存空间，而且最后遍历数组也是非常耗时的。于是我们可以考虑使用哈希表来计数，可以适应任意的字符范围，另外最后遍历哈希表判断计数结果时，可将哈希表中的数据去重，即转换成一个无序不重复的<code>Set</code>集合，利用空间换时间，如果该集合中只存在一个元素且值为<code>0</code>，则字符串<code>s</code>和<code>t</code>互为字母异位词，否则不是。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 空字符串情况</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span> &amp;&amp; t.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 字符串长度不相等</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符串转字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] tc = t.toCharArray();</span><br><span class="line">    <span class="comment">// 哈希表计数器</span></span><br><span class="line">    Map&lt;Character,Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历第一个字符串s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,sLength = s.length();i &lt; sLength;i++) &#123;</span><br><span class="line">        Integer val = counter.get(sc[i]);</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符已存在于哈希表中，则计数加一</span></span><br><span class="line">            val += <span class="number">1</span>;</span><br><span class="line">            counter.put(sc[i],val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前字符第一次出现，则计数为1</span></span><br><span class="line">            counter.put(sc[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历第二个字符串t</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>,tLength = t.length();j &lt; tLength;j++) &#123;</span><br><span class="line">        Integer val = counter.get(tc[j]);</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符已存在于哈希表中，则计数减一</span></span><br><span class="line">            val -= <span class="number">1</span>;</span><br><span class="line">            counter.put(tc[j],val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前字符第一次出现，已经可以断定不是字母异位词</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方案一：遍历哈希表计数器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    Iterator&lt;Map.Entry&lt;Character,Integer&gt;&gt; iterator = counter.entrySet().iterator();</span></span><br><span class="line"><span class="comment">    while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">        Map.Entry&lt;Character,Integer&gt; entry = iterator.next();</span></span><br><span class="line"><span class="comment">        // 如果计数结果不等于0，则不是字母异位词</span></span><br><span class="line"><span class="comment">        if (entry.getValue() != 0) &#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="comment">// 方案二：将哈希表转成无序不重复的Set集合</span></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(counter.values());</span><br><span class="line">    <span class="comment">// 如果Set集合中的元素个数不为1，或者唯一一个元素的值不为0，则可确定不是字母异位词。</span></span><br><span class="line">    <span class="keyword">if</span> (set.size() != <span class="number">1</span> || !set.contains(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 简单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题解-链表标签：链表相交</title>
      <link href="2020/07/14/algorithm/leetcode/tag/linkedlist/intersection-of-two-linked-lists-lcci/"/>
      <url>2020/07/14/algorithm/leetcode/tag/linkedlist/intersection-of-two-linked-lists-lcci/</url>
      
        <content type="html"><![CDATA[<p>题目：给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第<code>k</code>个节点与另一个链表的第<code>j</code>个节点是同一节点（引用完全相同），则这两个链表相交。</p><p>示例 <code>1</code>：</p><p>输入：<code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</code></p><p>输出：<code>Reference of the node with value = 8</code></p><p>输入解释：相交节点的值为 <code>8</code> （注意，如果两个列表相交则不能为 <code>0</code>）。从各自的表头开始算起，链表 <code>A</code> 为 <code>[4,1,8,4,5]</code>，链表 <code>B</code> 为 <code>[5,0,1,8,4,5]</code>。在 <code>A</code> 中，相交节点前有 <code>2</code> 个节点；在 <code>B</code> 中，相交节点前有 <code>3</code> 个节点。</p><p>示例 <code>2</code>：</p><p>输入：<code>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</code></p><p>输出：<code>Reference of the node with value = 2</code></p><p>输入解释：相交节点的值为 <code>2</code> （注意，如果两个列表相交则不能为 <code>0</code>）。从各自的表头开始算起，链表 <code>A</code> 为 <code>[0,9,1,2,4]</code>，链表 <code>B</code> 为 <code>[3,2,4]</code>。在 <code>A</code> 中，相交节点前有 <code>3</code> 个节点；在 <code>B</code> 中，相交节点前有 <code>1</code> 个节点。</p><p>示例 <code>3</code>：</p><p>输入：<code>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</code></p><p>输出：<code>null</code></p><p>输入解释：从各自的表头开始算起，链表 <code>A</code> 为 <code>[2,6,4]</code>，链表 <code>B</code> 为 <code>[1,5]</code>。由于这两个链表不相交，所以 <code>intersectVal</code> 必须为 <code>0</code>，而 <code>skipA</code> 和 <code>skipB</code> 可以是任意值。<br>解释：这两个链表不相交，因此返回 <code>null</code>。</p><p>注意：</p><p>如果两个链表没有交点，返回 <code>null</code> 。</p><p>在返回结果后，两个链表仍须保持原有的结构。</p><p>可假定整个链表结构中没有循环。</p><p>程序尽量满足 <code>O(n)</code> 时间复杂度，且仅用 <code>O(1)</code> 内存。</p><p>来源：力扣（<code>LeetCode</code>）</p><p>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci</a></p><p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>思路：若两个链表相交，那么情况一定是如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/algorithm/leetcode/intersection-of-two-linked-lists-lcci-01.png" alt="intersection-of-two-linked-lists-lcci-01.png"></p><p>相交的节点后面，两个链表完全重合，那么如何找到相交的节点呢？如果两个链表长度一样，那么同时遍历两个链表，当遇到引用相等的节点时就是两个链表相交的节点。但如果两个链表长度不一样呢？假设我们能够基于两个长度不同的链表构造出长度一样的两个链表，那么就可以找到相交的节点。那问题转换成如何构造长度一样的链表？如果两个链表的长度相差<code>x</code>个节点，先用一个指针遍历较长的链表<code>x</code>次，这时如果将该指针指向的节点作为头节点，跟另一个较短长度的链表就构成了长度一样的两个链表。然后同时进行遍历，直到遇到引用相等的节点即为头节点。如果整个过程都未遇到引用相等的节点，则可断定两个链表不相交。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分别计算两个链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">    ListNode a = headA;</span><br><span class="line">    ListNode b = headB;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        a = a.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 较长链表先遍历长度之差步</span></span><br><span class="line">    ListNode x = headA;</span><br><span class="line">    ListNode y = headB;</span><br><span class="line">    <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = x.next;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = lenB - lenA;</span><br><span class="line">        <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            y = y.next;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时以x、y为头节点的两个链表长度一样，同时进行遍历，如果遇到引用相等的节点，则一定是相交的节点。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; y != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x.next;</span><br><span class="line">        y = y.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历结束，可断定两个不相交。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务的特性和隔离级别</title>
      <link href="2020/07/12/database/mysql/transaction-characteristics-and-isolation-levels/"/>
      <url>2020/07/12/database/mysql/transaction-characteristics-and-isolation-levels/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>提起数据库，那不得不说到事务，但事务并不是<code>MySQL</code>数据库的专属，而是<code>SQL</code>语言的特性，事务就是一组原子性的<code>SQL</code>查询。该组查询语句要么全部执行成功，要么全部执行失败。如果其中有任何一条语句执行失败或因为数据库奔溃等其它原因无法执行，那么所有语句都不会执行。</p><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>事务的特性就是我们俗称的<code>ACID</code>，下面依次进行解释：</p><ol><li><code>A</code>：原子性（<code>Atomicity</code>）</li></ol><p>一个事务必须是一个不可分割的最小执行单元，整个事务中的所有操作要么全部执行成功，要么全部执行失败后回滚，对于一个事务而言，不可能出现其中一部分操作执行成功，另一部分操作执行失败的情况，这就是事务的原子性。</p><ol start="2"><li><code>C</code>：一致性（<code>consistency</code>）</li></ol><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。例如银行转账，用户<code>A</code>的账户向用户<code>B</code>的账户转账<code>100</code>元人民币，在这个事务中，首先会从用户<code>A</code>的账户中扣减<code>100</code>元，然后给用户<code>B</code>的账户增加<code>100</code>元，由于事务的原子性的保证，即使在从用户<code>A</code>的账户中扣减<code>100</code>元后数据库系统奔溃，用户<code>A</code>的账户上也不会损失<code>100</code>元，因为事务没有最终进行提交，用户<code>A</code>的账户扣减不会保存至数据库中，同时由于系统奔溃，用户<code>B</code>的账户也不会增加金额。也就是说，经过一次事务，整个账户系统中的金额总数不会改变，这就是事务的一致性。</p><ol start="3"><li><code>I</code>：隔离性（<code>isolation</code>）</li></ol><p>隔离性是指多个客户端并发访问数据库时，一个客户端的事务不能被其它客户端的事务所干扰，并发事务之间要做到事务隔离。</p><p>隔离性需要结合事务的隔离级别来说，下文会对事务的隔离级别进行展开说明。</p><p>通常的隔离性是：一个事务中的修改在最终提交事务之前，对其它事务是不可见的。还是银行转账的例子，在用户<code>A</code>给用户<code>B</code>转账的事务提交之前，如果用户<code>A</code>还向另一个用户<code>C</code>转账，这时候看用户<code>A</code>的账户是还未扣减<code>100</code>元的，这就是事务的隔离性。</p><ol start="4"><li><code>D</code>：持久性（<code>durability</code>）</li></ol><p>一旦事务提交，则该事务中所做的所有修改都将永久保存至数据库中，会被持久化至磁盘上，即使此时系统发生奔溃，事务中发生修改的数据也不会丢失。</p><p>在<code>MySQL</code>中，事务的实现在引擎层。<code>MySQL</code>是一个支持多引擎的系统，但并不是所有引擎都支持事务，例如<code>MySQL</code>原生的<code>MyISAM</code>引擎就不支持事务，而我们熟知的<code>InnoDB</code>引擎则是支持事务的。</p><h2 id="并发访问的问题"><a href="#并发访问的问题" class="headerlink" title="并发访问的问题"></a>并发访问的问题</h2><p>当多个事务并发执行的时候，就会出现并发问题，为了解决这些问题，提出了隔离级别的概念，每一种隔离级别都可以解决一个并发问题。</p><p>事务的并发执行存在以下三种问题：</p><ol><li>脏读</li></ol><p>一个事务读到了另一个事务中未提交的数据。</p><ol start="2"><li>不可重复读</li></ol><p>假设存在这样一个事务，首先查询一条记录，然后修改该条记录的值，再次查询该条记录，那么对于这个事务而言，两次查询到的记录的值不一致，这被称为不可重复读。</p><ol start="3"><li>幻读</li></ol><p>假设存在这样一个事务，首先条件查询某个范围内的记录，此时某个并发执行的其它事务在该范围内插入了新的记录，当之前的事务再次以相同的条件范围查询时，就会查询到新插入的行（称为幻行）。<code>InnoDB</code>引擎通过多版本并发控制（<code>MVCC</code>）来解决幻读的问题。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>每一种隔离级别都解决了一个并发问题，但必须明白，问题解决的越多，效率就会越低。因此很多时候我们需要根据实际业务场景来选择合适的隔离级别。</p><p><code>SQL</code>标准的事务隔离级别包括：读未提交（<code>read uncommitted</code>）、读已提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>serializable</code>）。</p><ol><li>读未提交（<code>read uncommitted</code>）</li></ol><p>可读取其它事务中未提交的数据，不能解决任何并发问题。</p><ol start="2"><li>读已提交（<code>read committed</code>）</li></ol><p>只能读取其它事务中已提交的数据，可以解决脏读问题。</p><ol start="3"><li>可重复读（<code>repeatable read</code>）</li></ol><p>一个事务执行过程中能读取到的数据，总是跟这个事务在启动时读到的数据保持一致。可以解决脏读和不可重复读问题。</p><p>实现原理是在事务启动时创建一个视图，整个事务存在期间都会查询该视图。</p><ol start="4"><li>串行化（<code>serializable</code>）</li></ol><p>最高的事务隔离级别，使用读写锁强制所有操作串行排队执行，解决了所有的并发问题。但其效率也最为低下。对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突时，后启动的事务必须等待前一个事务执行完并提交后，才能执行。</p><p>不同隔离级别之间的性能比较（从高到低）：读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 串行化。</p><p>性能越高，并发安全性越低。<code>MySQL</code>在<code>5.0</code>版本之后开始，选择可重复读做为默认的隔离级别。</p><blockquote><p><code>MySQL</code>为什么选择可重复读作为默认的隔离级别？</p><p><a href="/2020/07/12/database/mysql/why-does-mysql-choose-repeatable-read-as-the-default-isolation-level/">传送门</a></p></blockquote><h2 id="深入理解事务隔离级别"><a href="#深入理解事务隔离级别" class="headerlink" title="深入理解事务隔离级别"></a>深入理解事务隔离级别</h2><p>这里我们用一个例子来尝试理解事务的隔离级别。</p><p>初始化表<code>T</code>，插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `T` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `T` (`num`) <span class="keyword">values</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>假设有两个事务的执行顺序如以下表格所示：</p><table><thead><tr><th align="center">时间轴</th><th align="center">事务1</th><th align="center">事务2</th></tr></thead><tbody><tr><td align="center">t0</td><td align="center">begin</td><td align="center">begin</td></tr><tr><td align="center">t1</td><td align="center">select num from <code>T</code> where id = 1;</td><td align="center"></td></tr><tr><td align="center">t2</td><td align="center"></td><td align="center">select num from <code>T</code> where id = 1;</td></tr><tr><td align="center">t3</td><td align="center"></td><td align="center">update <code>T</code> set num = 2 where id = 1;</td></tr><tr><td align="center">t4</td><td align="center">select num from <code>T</code> where id = 1;</td><td align="center"></td></tr><tr><td align="center">t5</td><td align="center"></td><td align="center">commit;</td></tr><tr><td align="center">t6</td><td align="center">select num from <code>T</code> where id = 1;</td><td align="center"></td></tr><tr><td align="center">t7</td><td align="center">commit;</td><td align="center"></td></tr><tr><td align="center">t8</td><td align="center">select num from <code>T</code> where id = 1;</td><td align="center"></td></tr></tbody></table><p><code>t1</code>时刻事务<code>1</code>查询得到的<code>num</code>值为<code>1</code>。</p><p>设<code>t4</code>时刻事务<code>1</code>查询得到的<code>num</code>值为<code>N1</code>，<code>t6</code>时刻事务<code>1</code>查询得到的<code>num</code>值为<code>N2</code>，<code>t8</code>时刻事务<code>1</code>查询得到的<code>num</code>值为<code>N3</code>。</p><p>在不同隔离级别下，<code>N1</code>、<code>N2</code>和<code>N3</code>的值会一样吗？分别是多少？</p><ol><li>读未提交隔离级别下：</li></ol><p>事务<code>1</code>可读到事务<code>2</code>中未提交数据，于是<code>N1=N2=N3=2</code>。</p><ol start="2"><li>读已提交隔离级别下：</li></ol><p>事务<code>1</code>只能读到事务<code>2</code>中已提交的数据，于是<code>N1=1, N2=2, N3=2</code>。</p><ol start="3"><li>可重复读隔离级别下：</li></ol><p>事务<code>1</code>中读到的数据总是跟该事务刚启动时读到的数据保持一致，于是<code>N1=1, N2=1, N3=2</code>。</p><ol start="4"><li>串行化隔离级别下：</li></ol><p>对同一行数据的操作强制排队执行。<code>t1</code>时刻事务<code>1</code>加读锁；<code>t2</code>时刻事务<code>2</code>加读锁；<code>t3</code>时刻事务<code>2</code>尝试加写锁，进入阻塞状态，等待事务<code>1</code>提交后才会执行<code>update</code>；<code>t8</code>时刻事务<code>2</code>已提交。于是<code>N1=1, N2=1, N3=2</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务的四大特性：<code>ACID</code>；</p><p>事务的并发问题：脏读、不可重复读和幻读。</p><p>事务的隔离级别：读未提交、读已提交（解决了脏读）、可重复读（解决了不可重复读）和串行化（解决了幻读，无并发问题）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《MySQL实战45讲》 - 极客时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL为什么选择可重复读作为默认的隔离级别？</title>
      <link href="2020/07/12/database/mysql/why-does-mysql-choose-repeatable-read-as-the-default-isolation-level/"/>
      <url>2020/07/12/database/mysql/why-does-mysql-choose-repeatable-read-as-the-default-isolation-level/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在<code>Oracle</code>和<code>SqlServer</code>关系型数据库中，默认的事务隔离级别是读已提交。为什么<code>MySQL</code>的默认隔离级别选择可重复读呢？</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>这个问题得从主从复制说起，<code>MySQL</code>的主从复制是基于<code>binlog</code>复制的。</p><p><code>binlog</code>有以下三种格式：</p><ul><li><code>Statement</code>：记录修改的<code>SQL</code>语句。</li><li><code>Row</code>：记录每一行数据的变更。</li><li><code>Mixed</code>：<code>Statement</code>和<code>Row</code>模式的混合。</li></ul><p><code>MySQL</code>在<code>5.0</code>版本之前，<code>binlog</code>只支持<code>Statement</code>格式，在读已提交隔离级别下，这种格式的主从复制是存在问题的。</p><p>我们来看下面的例子：</p><p>创建一张<code>S</code>表，并初始化一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `S` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `val` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `S` (`val`) <span class="keyword">values</span> (<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>假设此时我们的<code>MySQL</code>是<code>5.0</code>版本，<code>binlog</code>为<code>Statement</code>格式，且隔离级别为读已提交。在主从架构下，主库上执行以下事务：</p><table><thead><tr><th align="center">Statement1</th><th align="center">Statement2</th></tr></thead><tbody><tr><td align="center">begin</td><td align="center">begin</td></tr><tr><td align="center">delete from <code>S</code> where id &lt; 5;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">insert into <code>S</code> (<code>val</code>) values (‘java’);</td></tr><tr><td align="center"></td><td align="center">commit;</td></tr><tr><td align="center">commit;</td><td align="center"></td></tr></tbody></table><p>此时在主库上执行<code>select * from S</code>，会输出一条记录<code>java</code>；而在从库执行该语句会输出<code>Empty Set</code>。</p><p>主从库数据出现了不一致。那原因是什么呢？</p><p>在主库上，<code>Statement1</code>的删除先执行，在其提交事务之前<code>Statement2</code>插入数据并提交，<code>Statement2</code>插入的数据不会被删除，最后<code>Statement1</code>事务提交，也就是先删除后插入，表中留下了<code>Statement2</code>事务中插入的数据。在这个过程中，由于<code>Statement2</code>先提交，<code>binlog</code>先将插入记录下来，然后记录后提交的删除。同步到从库上时，就是先插入后删除。所以导致了主从数据不一致。</p><p>那么如何解决该问题呢？</p><p>方案一：使用可重复读隔离级别，该级别下引入间隙锁，在<code>Statement1</code>执行删除时，间隙锁会锁住一个<code>id</code>区间（这个区间范围有一定的规则），在这个区间内的操作都会阻塞，所以<code>Statement2</code>执行插入会被阻塞住，直到<code>Statement1</code>事务提交才执行。</p><p>方案二：将<code>binlog</code>的格式修改为<code>Row</code>格式，基于行的复制，这样就保证了删除和插入的执行顺序。但该特性在<code>5.0</code>版本之后才引入，所以，<code>MySQL</code>为了保证主从同步数据一致性，将默认隔离级别设置为可重复读。</p><p>间隙锁的存在，导致可重复读隔离级别出现死锁的几率变大，一旦出现死锁，对业务的影响将是不可预料的，所以，实际业务开发中，并不推荐使用默认的可重复读隔离级别，而是推荐使用读已提交隔离级别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于间隙锁，我将单独写一篇博客进行详细介绍。这里只需理解到会锁住一个区间即可，在这个区间内的操作都会阻塞。</p><p><code>MySQL</code>的早期版本没有间隙锁，在读已提交隔离级别下主从同步会出现数据不一致的情况，所以将默认的隔离级别设为了读已提交。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/rjzheng/p/10510174.html">https://www.cnblogs.com/rjzheng/p/10510174.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java，你不得不学的java.lang.String类</title>
      <link href="2020/06/29/javase/base/string/"/>
      <url>2020/06/29/javase/base/string/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>Java</code>开发中，我们从头至尾都在与<code>String</code>打交道。还记得我们敲下的第一行代码吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这是我们所有开发人员梦开始的地方。那年，青涩的我们在课堂上敲下这第一行代码，殊不知，它竟会影响我们每个人的一生。</p></blockquote><h2 id="java-lang-String类简介"><a href="#java-lang-String类简介" class="headerlink" title="java.lang.String类简介"></a><code>java.lang.String</code>类简介</h2><p>对于部分刚学习<code>Java</code>的初学者来说，当问到<code>Java</code>中有哪些基本数据类型时，可能会回答出<code>String</code>字符串。</p><p>但事实上，<code>String</code>是一个引用类型。</p><blockquote><p><code>Java</code>中的基本类型有以下八种：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>char</code>、<code>float</code>、<code>double</code>和<code>boolean</code>。</p></blockquote><h2 id="和equals-区别"><a href="#和equals-区别" class="headerlink" title="==和equals()区别"></a><code>==</code>和<code>equals()</code>区别</h2><p>我们先来看这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String a = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; World&quot;</span> + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明的你是否已经知道了这段代码的运行结果呢？</p><p>运行结果：<code>true</code>。</p><p>如果你立刻知道了结果且懂其原理，那么这一个知识点可以跳过；如果还有一点含糊，那就请仔细往下看。</p><p>要解释这个运行结果的原理，需要知道下面三个问题：</p><ul><li><code>==</code>和<code>equals()</code>是如何进行比较的？</li><li>上述代码中的变量<code>a</code>和<code>b</code>在内存中是什么样的？</li><li>编译时的优化方案。</li></ul><h3 id="的比较方案"><a href="#的比较方案" class="headerlink" title="==的比较方案"></a><code>==</code>的比较方案</h3><p>在<code>Java</code>语言中，<code>==</code>运算符用于比较两个内存单元上的内容是否一样，实际是比较两个数字，在计算机内部就是<code>0</code>和<code>1</code>。</p><p>对于七种基本数据类型（<code>boolean</code>除外），就是直接比较两者的数值是否相等。</p><p>而对于引用类型，例如示例中的<code>String</code>引用类型，比较的是“引用的值”，实际就是两者的内存地址值。</p><p>如果两个引用进行<code>==</code>比较，比较的是两个引用对象的内存地址值是否相等，实际上就是判断两个引用所指向的对象是否存储在同一个内存区域上。如果是，则返回<code>true</code>；否则返回<code>false</code>。</p><blockquote><p>举一个不太恰当的比喻：大家都考上了心仪的大学，现在比较哪些人考上了同一所大学。</p></blockquote><h3 id="equals-方法的比较方案"><a href="#equals-方法的比较方案" class="headerlink" title="equals()方法的比较方案"></a><code>equals()</code>方法的比较方案</h3><p>对于<code>equals()</code>方法，它的源头来自于<code>Object</code>类。在<code>Java</code>中，任何对象都隐式的继承了<code>java.lang.Object</code>类。所以任何对象都可以调用<code>equals()</code>方法进行比较。</p><p>而在<code>java.lang.Object</code>类中，<code>equals()</code>方法的实现是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用了<code>==</code>运算符比较。这意味着：如果调用<code>equals()</code>方法进行比较的类及其显式使用<code>extends</code>关键字继承的父类列表中都没有重写过<code>equals()</code>方法，那么调用<code>equals()</code>方法就等同于使用<code>==</code>运算符进行比较。</p><p><code>equals()</code>方法之所以存在于<code>Object</code>类中，就是希望子类去重写，以实现比较对象相等的功能。</p><p><code>java.lang.String</code>类就重写了<code>equals()</code>方法，因为对于字符串来说，只要字符串内容相同，则可认为这两个字符串是“相等”的。</p><blockquote><p>两个对象“相等”并不意味着对象的所有属性都要相等，需要根据对象的具体业务场景进行具体分析。</p><p>例如，两个罗技牌鼠标，它们的属性除了品牌、型号、尺寸和价格外，还有如生产地区、售卖方式等属性，但是我们可能只需要对比它们的品牌、型号和尺寸等属性，在这个范围内其余的属性不需关心。也就是说，两个对象的值是否相等需要根据对象的业务场景决定，而不是有一个唯一的标准来比较。</p><p>所以，<code>Object</code>类提供了<code>equals()</code>方法来让各个类选择重写，用以实现符合自身业务场景的对象相等比较。</p></blockquote><h3 id="上述代码中的变量a和b在内存中的结构"><a href="#上述代码中的变量a和b在内存中的结构" class="headerlink" title="上述代码中的变量a和b在内存中的结构"></a>上述代码中的变量<code>a</code>和<code>b</code>在内存中的结构</h3><p>在<code>Java</code>中，对象在内存中的存储通常是：栈中的引用指向堆内的对象。对于字符串对象来说，还有一个字符串常量池用来存储字符串对象（它是一个<code>JVM</code>级别的字符串缓存），也就是会出现栈中的引用指向常量池中的对象。</p><blockquote><p>在<code>Java6</code>之前，字符串常量池位于方法区内；</p><p>而在<code>Java7</code>中，字符串常量池被移到了堆内存中；</p><p>在<code>Java8</code>中，提出了元空间的概念，字符串常量池也随之移动到了元空间。</p></blockquote><h3 id="编译时的优化"><a href="#编译时的优化" class="headerlink" title="编译时的优化"></a>编译时的优化</h3><p>变量<code>a</code>是通过<code>+</code>拼接字面量进行赋值的，在编译期，<code>String a = &quot;Hello&quot; + &quot; World&quot; + &quot;!&quot;;</code>就已经被编译成<code>String a = &quot;Hello World!&quot;;</code>了，为什么会这样呢？因为字面量的值是确定的，运行时不再需要任何计算，也就没有使用<code>+</code>运算符的必要了，编译器也这么觉得：“这不是在脱裤子放屁吗”？所以在编译期运算符就被去除了。于是<code>a</code>和<code>b</code>的赋值是完全一样的。</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>对于变量<code>a</code>和<code>b</code>这种使用字面量创建字符串的方式，在创建变量<code>a</code>时，<code>JVM</code>首先会去字符串常量池中查找<code>&quot;Hello World!&quot;</code>这个字符串对象，如果不存在，则在字符串常量池中创建一个<code>&quot;Hello World!&quot;</code>对象，然后将常量池中<code>&quot;Hello World!&quot;</code>这个对象的引用地址赋给栈中的引用<code>a</code>，这样栈中的引用<code>a</code>就指向了常量池中的<code>&quot;Hello World!&quot;</code>对象；如果已经存在，则不会再次创建新对象，直接将已有的<code>&quot;Hello World!&quot;</code>对象的地址返回，赋给栈中的引用<code>b</code>，于是，栈中的引用<code>b</code>也指向了常量池中的<code>&quot;Hello World!&quot;</code>对象。</p><p>常量池中的<code>&quot;Hello World!&quot;</code>对象只有一份，于是使用<code>==</code>运算符比较变量<code>a</code>和<code>b</code>会返回<code>true</code>。</p><h2 id="编译器的优化"><a href="#编译器的优化" class="headerlink" title="编译器的优化"></a>编译器的优化</h2><p>我们再来看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String m = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String n = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String x = m + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String y = n + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String z = getA() + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String compare = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(x == compare);</span><br><span class="line">    System.out.println(y == compare);</span><br><span class="line">    System.out.println(z == compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你心中有答案吗？知道每个答案的原理吗？</p><p>如果还没有，下面的内容你应该仔细阅读。</p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>首先，第一个输出，变量<code>x</code>与<code>compare</code>比较，变量<code>x</code>等于局部变量<code>m</code>加上字符串<code>&quot;b&quot;</code>，虽然局部变量<code>m</code>也指向了一个字面量<code>&quot;a&quot;</code>，但是这个引用关系并未进行“强制约束”，在运行期，可通过字节码增强技术来动态改变该引用的指向，所以编译器并未直接将其优化成<code>&quot;ab&quot;</code>。而是将其优化成了<code>StringBuilder</code>的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">temp.append(m).append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">String x = temp.toString();</span><br></pre></td></tr></table></figure><p>使用<code>new</code>关键字创建的<code>StringBuilder</code>对象位于堆内存中，于是变量<code>x</code>指向了堆中的对象。而局部变量<code>compare</code>指向字面量<code>&quot;ab&quot;</code>，按照前文的叙述，<code>JVM</code>将会先去字符串常量池寻找<code>&quot;ab&quot;</code>字符串对象，如果找到，则会直接返回常量池中地址返回，赋给引用<code>compare</code>。</p><p>变量<code>x</code>指向堆内存，而变量<code>compare</code>指向常量池内存，所以使用<code>==</code>运算符比较的结果为<code>false</code>。</p><p>第二个输出，变量<code>y</code>与<code>compare</code>比较，变量<code>y</code>等于局部变量<code>n</code>加上字符串<code>&quot;b&quot;</code>，虽然与变量<code>x</code>十分类似，但是，请注意局部变量<code>n</code>前面声明的<code>final</code>关键字，它具有不可变性，即<code>n</code>只会被赋值一次。保证了局部变量<code>n</code>始终指向字面量<code>&quot;a&quot;</code>所在的内存地址，按照程序的逻辑顺序，字面量<code>&quot;a&quot;</code>此时已经存在于字符串常量池中了，所以局部变量<code>n</code>始终指向常量池中<code>&quot;a&quot;</code>所在的内存地址。这个引用关系是无法进行修改的。所以编译器将变量<code>y</code>直接优化成了<code>&quot;ab&quot;</code>。</p><p>第三个输出，变量<code>z</code>与<code>compare</code>比较，变量<code>z</code>由一个方法的返回值加上字符串<code>&quot;b&quot;</code>组成，虽然方法内返回一个常量的引用，但是编译器并不会看方法内返回了什么，因为方法内部的行为是未知的，可能会出现多重递归，而且递归过后也不一定会返回固定的常量值。所以编译器不会将变量<code>z</code>优化成<code>&quot;ab&quot;</code>。</p><p>编译器的代码优化一定是在编译期就能确定优化后不会改变原有功能，类似于<code>final</code>引用，这个引用只会被赋值一次。只有在编译阶段能确定这个引用被赋值的内容，编译器才可能进行编译期优化，不要和运行期的动作关联到一起，编译期能确定的内容只来源于常量池，使用<code>new</code>关键字创建对象属于运行期的动作。同样地，方法的返回值也是不能确定的，运行期的方法可能会返回不同的值。</p><h2 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String#intern()方法"></a><code>String#intern()</code>方法</h2><p>有了上面的知识后，我们再来看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String b = a + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String c = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String d = <span class="keyword">new</span> String(b);</span><br><span class="line">    System.out.println(b == c);</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.println(c == d.intern());</span><br><span class="line">    System.out.println(b.intern() == d.intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码增加了<code>intern()</code>方法的调用，其输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>对于前两个输出，你应该能知道答案。第一个输出在上一个例子中讲过了，输出为<code>false</code>；第二个输出，变量<code>c</code>在常量池中，变量<code>d</code>在堆中，输出为<code>false</code>。</p><p>对于后两个输出，如果你不了解<code>intern()</code>方法的作用，恐怕不能给出合理的解释。</p><p>当调用<code>String</code>类的<code>intern()</code>方法时，<code>JVM</code>会在常量池中通过<code>equals()</code>方法查找是否存在值相等的字符串，如果存在，则直接返回常量池中的地址；否则，则会将该字符串加入常量池（开辟新的内存空间），然后返回常量池中新开辟的这块内存空间地址。所以，只要是值相等（<code>equals()</code>方法比较相等）的字符串，当调用<code>intern()</code>方法时，都会得到常量池中对应字符串的引用地址，所以使用<code>==</code>运算符比较会返回<code>true</code>。</p><p>对于第三个输出，变量<code>c</code>使用字面量赋值，得到的是常量池中的引用；而变量<code>d</code>使用<code>new</code>关键字创建了一个堆中对象，但调用<code>intern()</code>方法后发现常量池中已经存在了<code>&quot;ab&quot;</code>，所以返回常量池的引用地址，于是使用<code>==</code>运算符比较返回<code>true</code>。</p><p>对于第四个输出，变量<code>b</code>和<code>d</code>都调用了<code>intern()</code>方法，得到的都是常量池中的引用地址，自然使用<code>==</code>运算符比较返回<code>true</code>。</p><h2 id="StringBuilder对象"><a href="#StringBuilder对象" class="headerlink" title="StringBuilder对象"></a><code>StringBuilder</code>对象</h2><p>在阿里巴巴开发手册中，推荐在<code>for</code>循环体内使用<code>StringBuilder</code>对象的<code>append()</code>方法进行字符串拼接，而不是<code>+</code>号。</p><p>手册中给出的反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">str = str + <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有给出正例，有些人在理解上可能出现了一些偏差，于是出现了以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;start&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(str)</span><br><span class="line">      .append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">str = sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这也是反例，只不过是手册中给出的反例经过编译器编译之后的。</p><p>阿里巴巴的这个推荐的初衷是不要在循环体内使用<code>+</code>号，因为<code>+</code>号会被编译器优化成<code>StringBuilder</code>对象，所以它的建议实际是不要在循环体内创建<code>StringBuilder</code>对象。</p><p>正确的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">String str = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">sb.append(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">str = sb.toString();</span><br></pre></td></tr></table></figure><p>为什么这样建议？使用<code>+</code>有什么不好的地方？</p><p>使用<code>+</code>号实际是在循环体内创建了<code>StringBuilder</code>对象，调用<code>append()</code>方法拼接后重新给引用<code>str</code>赋值，这会导致<code>str</code>指向的字符串越来越大，到达一定程度后会进入老年代，甚至出现<code>OOM</code>。同时每次循环都会创建一个<code>StringBuilder</code>对象，在一次循环结束后，该对象就会变成垃圾等待回收，导致内存开销增大。</p><p>而正确的写法会在循环体外预先创建一个<code>StringBuilder</code>对象，每次循环中都调用该对象的<code>append()</code>方法拼接字符串，避免了内存开销大的情况。</p><p>小结：要明确的一点是，不是<code>+</code>号操作本身慢，而是在循环体中每次循环都会创建对象导致内存开销变大，每一次循环后，创建的对象变成了垃圾引发<code>GC</code>进行垃圾回收，导致程序变慢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于<code>String</code>类，本文只是抛砖引玉，很多细节并未提及，例如<code>StringBuilder</code>在进行<code>append</code>时的扩容，在拼接大字符串和小字符串时如何合理使用让内存利用率更高，还包括<code>StringBuffer</code>同步类等其它字符串相关的内容。总之，字符串是开发中必定会使用到的数据类型，如果涉及到字符串操作，请一定要考虑到效率问题，从小的细节入手精心雕琢代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>勇闯算法-递归法拿下反转链表的三杀</title>
      <link href="2020/06/04/algorithm/base/recursive-reverse-link/"/>
      <url>2020/06/04/algorithm/base/recursive-reverse-link/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编程语言：<code>Java（JDK8）</code></p><p>单链表节点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于反转链表，有迭代和递归两种实现方式，本文使用递归实现反转。</p><p>首先介绍递归的思想，然后从最基本的反转整个单链表开始，由浅入深，最终拿下反转链表的“三杀”！</p><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><blockquote><p>任何一个问题，如果能够用迭代解决，那么一定可以转换成递归。  —— 某算法大神</p></blockquote><p>我们很难去证明大神的说法不正确，但我们可以先假设他的理论成立。先强行让自己接受。</p><p>恩！没错！能够用迭代解决就一定能用递归解决！</p><p>是不是有递归“内味”了？先假设条件成立，把主要逻辑走通。</p><p>那么到底如何将迭代转换成递归呢？</p><p>迭代是遍历，一个一个地进行迭代处理；</p><p>而递归呢？在处理第一个的时候要先假设后面的全部都处理完了，只需处理第一个，所以，只要第一个处理完了，整个就处理完了（感觉完全无法接受啊）。</p><p>“假设”始终是假设，但是它能让我们的当前逻辑走通。在第一次的假设中，我们可以进行第二次地假设，假设后面的数据的第一个之后的数据全都处理完了，则只需处理此时的第一个。这样不停地假设下去，直到假设到整体的最后一个数据，这个时候没有数据让我们假设了，不能再“骗自己”了！要拿出点真本事来！我们对整体的最后一个数据进行真实的处理，这个时候我们发现，倒数第二个数据的假设成立了！多米偌骨牌效应！之前所有的假设都成立了！问题解决了！</p><h2 id="First-Blood：反转整个单链表"><a href="#First-Blood：反转整个单链表" class="headerlink" title="First Blood：反转整个单链表"></a><code>First Blood</code>：反转整个单链表</h2><p>首先用递归来解决最基本的整个单链表的反转。（“对面辅助开始搞事情了”）</p><p>例如：单链表为：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，那么反转之后的单链表为：<code>null &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5</code>。</p><p>对应上面的递归思想：在反转第一个节点的时候，先假设后面的节点全都反转完了，返回了反转后的头节点，它就是整个单链表反转完成后的头节点，于是我们只需将第一个节点进行反转，整个链表的反转就完成了。在第一次假设中，同样进行假设，不停地假设，直到最后一个节点，后面没有节点让我们进行假设了，我们进行真实的反转。这时之前所有的假设像多米偌骨牌一样地成立了，整个单链表反转完成！</p><p>好像无法理解？没关系，按递归的思想，先假设自己理解了。我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 不能再“骗自己”了</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 假设后面的节点全都反转完成，返回了反转后的头节点，即为整个单链表反转后的头节点</span></span><br><span class="line">    ListNode reverseHead = reverse(head.next);</span><br><span class="line">    <span class="comment">// 反转第一个节点</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回反转后的头节点</span></span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reverse</code>函数的定义是这样的：输入一个节点<code>head</code>，将以<code>head</code>为头节点的链表反转，返回反转后的头节点。</p><p>我们要反转的链表为：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>：</p><p><code>reverse(1)</code>：输入第一个节点<code>1</code>时；</p><p>假设后面的节点已经反转完成并返回了反转后的头节点：<code>ListNode reverseHead = reverse(head.next);</code></p><p>后面的节点反转后的结果为：<code>null &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5</code>，返回的头节点<code>reverseHead</code>为<code>5</code>；</p><p>此时我们只需要对节点<code>1</code>进行反转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将节点1的下一个节点2的指针域指向节点1</span><br><span class="line">head.next.next &#x3D; head;</span><br><span class="line">&#x2F;&#x2F; 将节点1的下一个节点指向null</span><br><span class="line">head.next &#x3D; null;</span><br></pre></td></tr></table></figure><p>整个链表的反转就完成了！</p><p>但是我们不能“骗自己”！<code>reverse</code>函数不停地进行假设，当它接收到原链表的最后一个节点时，没有节点进行假设了，必须去反转！</p><p>由于只有一个节点，反转后还是自身，所以我们只需返回该节点，即为反转后的头节点。这时我们惊奇的发现前面所有的假设都成立了！</p><p>这就是所谓的递归的出口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (head.next &#x3D;&#x3D; null)</span><br><span class="line">    return head;</span><br></pre></td></tr></table></figure><p>我们画张图来看下整个流程。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/algorithm/base/reverselink-01.png" alt="reverselink-01.png"></p><p>我们的递归算法只需要关注原链表的第一个节点（头节点）和最后一个节点（尾节点），也就是递归开始的节点和无法再进行假设的节点。在递归函数中，首先要处理尾节点，因为这是不可再假设的节点；当处理头节点时，我们进行假设，假设头节点之后的所有节点都已完成反转同时返回了反转后的新头节点，然后对头节点进行反转，此时就完成了整个单链表的反转。</p><p>学会了递归思想后，我们就可以愉快的开始“三杀”之旅了！</p><h2 id="Double-Kill：反转单链表的前N个节点"><a href="#Double-Kill：反转单链表的前N个节点" class="headerlink" title="Double Kill：反转单链表的前N个节点"></a><code>Double Kill</code>：反转单链表的前<code>N</code>个节点</h2><p>有了上面的“一血”，“双杀”简直就是白送！（“辅助死了，<code>ADC</code>开始送了”）</p><p>我们要实现的函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 将单链表的前n个节点进行反转。（n &lt;&#x3D; 单链表长度）</span><br><span class="line"> * @param head 单链表头节点</span><br><span class="line"> * @param n 前n个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode reverseN(ListNode head,int n) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>假设我们要反转单链表的前<code>3</code>个元素，那我们要实现的效果如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/algorithm/base/reverselink-02.png" alt="reverselink-02.png"></p><p>按照递归思想，我们只需要关注递归开始的节点和无法再进行假设的节点：即头节点和第<code>N</code>个节点。</p><p>对于原单链表的头节点，先假设其后面的<code>N - 1</code>个节点已经反转完成并返回了反转后的新头节点，此时我们只需要反转头节点，将头节点指向第<code>N + 1</code>个节点，链表前<code>N</code>个节点的反转就完成了。但是此时第<code>N + 1</code>个节点我们无法得知。</p><p>由于单链表的特性，我们只有遍历到第<code>N</code>个节点时才能得到第<code>N + 1</code>个节点，那我们有必要单独对链表进行遍历获取第<code>N + 1</code>个节点吗？</p><p>完全没必要！因为我们的递归算法本身一开始就要处理第“<code>N</code>”个节点，因为它是无法再进行假设的节点，所以，递归函数中第一步处理第“<code>N</code>”个节点时要记录下第<code>N + 1</code>个节点（使用全局变量）。注意：这里的第<code>N</code>个节点是针对原单链表而言的；对于最后一个无法再进行假设的假设来说：<code>N = 1</code>。</p><p>于是我们就可以完成对原链表头节点的反转。从而完成整个单链表的前<code>N</code>个节点反转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 记录原链表的第N+1个节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">static ListNode nNext;</span><br><span class="line"></span><br><span class="line">public static ListNode reverseN(ListNode head,int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 记录原链表的第 n + 1 个节点</span><br><span class="line">        nNext &#x3D; head.next;</span><br><span class="line">        &#x2F;&#x2F; 无法再进行假设了，返回反转后的头节点</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 假设后面节点的前 N - 1 个节点已经完成了反转，并返回了反转后的新头节点</span><br><span class="line">    ListNode reverseHead &#x3D; reverseN(head.next,n - 1);</span><br><span class="line">    &#x2F;&#x2F; 反转原链表的头节点</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; nNext;</span><br><span class="line">    &#x2F;&#x2F; 返回反转后的新头节点</span><br><span class="line">    return reverseHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“双杀”拿下，不知道你有没有掌握到递归的套路？（“此时对面打野赶到下路，即将送出三杀”）</p><h2 id="Triple-Kill：反转单链表的第m个到第n个节点"><a href="#Triple-Kill：反转单链表的第m个到第n个节点" class="headerlink" title="Triple Kill：反转单链表的第m个到第n个节点"></a><code>Triple Kill</code>：反转单链表的第<code>m</code>个到第<code>n</code>个节点</h2><p>给定单链表的索引区间<code>[m,n]</code>（约定不越界），反转此区间内的节点。（“敌方打野正在路上”）</p><p>已知条件为：单链表的头节点和区间<code>m</code>、<code>n</code>的值，我们要实现的函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转从m到n之间的节点。1 &lt;= m &lt; n &lt;= 链表长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 反转开始节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 反转结束节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseBetweenMToN</span><span class="params">(ListNode head,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>例如：单链表为：<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</code>，<code>m = 2, n = 4</code>，那么反转之后的单链表为：<code>1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; null</code>。</p><p>按照递归的思想，我们在处理头节点<code>head</code>时，先假设后面的节点已经反转完成并返回了反转后的新头节点，那么只需将头节点的指针域指向反转后的新头节点就完成了需求。</p><p>对于去除头节点<code>head</code>之后的链表，我们需要反转的是从<code>m - 1</code>到<code>n - 1</code>区间内的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.next = reverseBetweenMToN(head.next,m - <span class="number">1</span>,n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p>那按照递归思想，我们什么时候不能再“骗自己”了呢？当假设到原链表的第<code>m</code>个节点时，对于这个假设来说，是这个假设的第<code>1</code>个节点，此时这个假设需要反转从第<code>1</code>个到第<code>n - m + 1 = n</code>个节点，这不正是<code>Double Kill</code>中的反转单链表的前<code>N</code>个节点吗？</p><p>于是递归函数完整实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseBetweenMToN</span><span class="params">(ListNode head,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head,n);</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = reverseBetweenMToN(head.next,m - <span class="number">1</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“三杀”拿下！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>掌握递归的思想很重要：处理第一个时，先假设后面的全部都处理完了，只需处理第一个；不停地假设，直到不能再假设的时候，开始真正进行处理；这样前面所有的假设就像多米偌骨牌效应一样全都成立了，最终，问题就解决了。</p><p>递归虽好，但却不如迭代法高效，虽然时间复杂度都为<code>O(N)</code>，但因为递归需要申请额外的栈空间，所以其空间复杂度为<code>O(N)</code>，而迭代法的空间复杂度仅为<code>O(1)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之ArrayList</title>
      <link href="2020/06/01/javase/base/arraylist/"/>
      <url>2020/06/01/javase/base/arraylist/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ArrayList</code>底层数据结构是动态数组，与普通的数组相比，它的容量可以动态增长。在添加的元素数量达到一定值时，会触发自动扩容机制，保证集合的可用性。</p><p>它继承了<code>AbstractList</code>抽象类，并实现了<code>List</code>、<a href="/2020/04/26/javase/base/randomaccess/"><code>RandomAccess</code></a>、<a href="/2020/04/26/javase/base/cloneable/"><code>Cloneable</code></a> 和 <a href="/2020/03/21/javase/base/serializable/"><code>java.io.Serializable</code></a>接口。</p><blockquote><p><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/java-se/src/main/java/com/sunchaser/javase/collect/reimpllist"><code>AbstractList</code>抽象类已经实现了<code>List</code>接口，为什么<code>ArrayList</code>还要去实现<code>List</code>接口？</a></p></blockquote><p>由于底层由数组存储元素，其取指定下标位置元素、在集合尾部插入元素和求数组长度的时间复杂度为<code>O(1)</code>；而在指定索引位置插入和删除元素的时间复杂度为<code>O(n)</code>。</p><h2 id="使用分析"><a href="#使用分析" class="headerlink" title="使用分析"></a><span id="useAnalysis">使用分析</span></h2><p>在开发中，我们会经常使用<code>ArrayList</code>来存储对象，例如对数据库批量插入/修改的入参实体集合、数据库的列表查询结果集转换成前端视图模型对象等。一般来说，我们的使用形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 连续添加10个元素</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;j&quot;</span>);</span><br><span class="line"><span class="comment">// 添加第11个元素</span></span><br><span class="line">list.add(<span class="string">&quot;k&quot;</span>);</span><br><span class="line"><span class="comment">// do other</span></span><br></pre></td></tr></table></figure><p>这样使用似乎没有任何问题，但这却不是一个匠心程序员该写出来的代码。</p><p>为什么这么说呢？我们知道<code>ArrayList</code>底层是动态数组，那这个数组什么时候进行动态呢？换句话说，数组什么时候会进行扩容？又扩容到多少呢？</p><p>以上代码执行完后到底有没有进行扩容？这些都是问题，让我们带着这些问题来看下面的源码。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空ArrayList实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享的空数组实例，用于默认大小的空实例。</span></span><br><span class="line"><span class="comment"> * 将该成员变量与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时需要填充多少。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList的元素的数组缓冲区。ArrayList的容量是此数组缓冲区的长度。</span></span><br><span class="line"><span class="comment"> * 添加第一个元素时，任何具有elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment"> * 非私有成员以简化嵌套类访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的大小（它包含的元素个数）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配的最大数组大小。某些VM在数组中保留一些标头字。</span></span><br><span class="line"><span class="comment"> * 尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出VM限制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p>构造一个初始容量为<code>10</code>的空列表。将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>空列表赋给存储元素的<code>elementData</code>数组缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><p><code>1</code>、 构造一个具有指定初始容量的空列表。入参<code>initialCapacity</code>为列表的指定初始容量，如果为负数则抛出<code>IllegalArgumentException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建initialCapacity大小的Object类数组。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定容量为0，赋值静态空数组成员变量。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 负数抛出异常。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2</code>、 构造一个包含指定集合元素的列表，其顺序由集合的迭代器返回。入参<code>c</code>集合中的元素将被放入此列表，如果集合为<code>null</code>则抛出<code>NullPointerException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合转数组赋值给elementData</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 集合元素个数不为0。</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray方法返回的可能不是Object[]数组，此处判断如果不为Object[]类型则转换成Object[]类型。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 赋值静态空数组成员变量。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组拷贝方法"><a href="#数组拷贝方法" class="headerlink" title="数组拷贝方法"></a>数组拷贝方法</h3><p>由于<code>ArrayList</code>底层使用数组进行元素存储，其很多实现都是对数组进行直接操作。所以在看其它方法之前，很有必要先弄懂一些数组的方法。</p><p><code>java.util.Arrays</code>是<code>JDK</code>提供的一个数组工具类，在<code>ArrayList</code>中大量使用了它的一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original 待拷贝数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength 拷贝后新数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original 待拷贝数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength 拷贝后新数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newType 数组元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 传入的newType类型是否是Object类型，是则创建Object数组，否则创建指定类型数组。</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// native方法</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="comment">// 返回创建的新长度的数组</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将src数组中srcPos索引及其之后的length个元素分别拷贝至dest数组中destPos索引及其之后的length个位置上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos 源数组拷贝开始位置索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos 目标数组拷贝开始位置索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 拷贝的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p><code>ArrayList</code>提供了两个重载的<code>add</code>插入方法。第一个是将指定元素添加至列表末尾；第二个是将指定元素添加至指定位置；同时还提供了两个重载的<code>addAll</code>方法，用来批量插入。</p><h4 id="插入至列表末尾"><a href="#插入至列表末尾" class="headerlink" title="插入至列表末尾"></a>插入至列表末尾</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我们可以对<a href="#useAnalysis"><code>使用分析</code></a>中的示例代码进行分析了：</p><p>首先使用<code>new</code>关键字调用无参构造器初始化一个<code>ArrayList</code>集合对象，我们知道其实质是将<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>空列表赋给存储元素的<code>elementData</code>数组缓冲区。创建出的<code>list</code>对象的<code>size</code>成员变量初始化为<code>0</code>，然后调用<code>list</code>对象的<code>add</code>方法添加元素。</p><p>第一次调用：<code>list.add(&quot;a&quot;);</code></p><p>在<code>add</code>方法中首先调用<code>ensureCapacityInternal</code>方法，确保内部容量，然后将传入的元素赋值给<code>elementData</code>数据域末尾。最后返回<code>true</code>。</p><p>确保内部容量<code>ensureCapacityInternal</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次调用<code>add</code>方法时：<code>elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（构造器中初始化），<code>minCapacity = size + 1</code>（其值为<code>1</code>）。</p><p>调用<code>calculateCapacity(elementData, minCapacity)</code>方法计算容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new ArrayList&lt;&gt;() 时，初始化为 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>elementData</code>等于<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，返回<code>DEFAULT_CAPACITY</code>（其值为<code>10</code>）和<code>minCapacity</code>（其值为<code>1</code>）中较大的值，即返回<code>10</code>。</p><p>随即调用了<code>ensureExplicitCapacity(10)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先增加当前集合的修改次数。然后判断计算出的容量是否超出了当前<code>elementData</code>数组长度，如果超过则进行<code>grow</code>扩容。</p><p>在第一次调用<code>add</code>方法时显然超过了，进行扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 新容量小于传入的计算出的容量，则新容量为传入容量。</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 新容量超过了最大值，则计算最大容量</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 数组内容拷贝</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容流程为：</p><ul><li>获取旧容量<code>oldCapacity</code>；</li><li>计算新容量，利用位运算（速度远超整除运算）得到旧容量的一半再加上旧容量，即扩容<code>1.5</code>倍；</li><li>检查新容量是否小于传入的计算容量<code>minCapacity</code>，如果小于，则将传入的容量作为新容量；</li><li>检查得到的新容量是否大于<code>ArrayList</code>定义的所能容纳的最大容量：<code>Integer,MAX_VALUE - 8</code>；</li><li>如果大于，则调用<code>hugeCapacity(minCapacity)</code>计算最大容量：如果<code>minCapacity</code>大于<code>Integer.MAX_VALUE - 8</code>，则最大容量为<code>Integer.MAX_VALUE</code>，否则为<code>Integer.MAX_VALUE - 8</code>。</li><li>最后调用<code>Arrays.copyOf(elementData, newCapacity)</code>进行数组拷贝，得到一个以新容量为长度的数组对象并赋值给<code>elementData</code>。</li></ul><p>第一次调用<code>add</code>方法时，旧容量<code>oldCapacity = 0</code>，通过位运算计算出的新容量也为<code>0</code>，所以最后新容量<code>newCapacity = minCapacity</code>，等于<code>10</code>。</p><blockquote><p>所以我们使用<code>new</code>关键字调用无参构造器创建<code>ArrayList</code>对象时，实际上只初始化了一个空数组，在第一次调用<code>add</code>方法时才会进行空数组的扩容。</p></blockquote><p>扩容完成后，<code>elementData</code>数组容量充足，可以往其末尾添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[size++] = e;</span><br></pre></td></tr></table></figure><p>像<a href="#useAnalysis"><code>使用分析</code></a>中的示例代码一样，我们不断地向其中添加元素，当添加的元素个数不超过<code>10</code>时，<code>ensureExplicitCapacity(int minCapacity)</code>方法判断<code>minCapacity - elementData.length</code>始终小于<code>0</code>（经过第一次扩容后<code>elementData.length</code>的值为<code>10</code>），不会进行<code>grow</code>扩容; 而当添加至第<code>11</code>个元素<code>k</code>时，情况发生变化：</p><ul><li><code>calculateCapacity(elementData, minCapacity)</code>方法直接返回<code>minCapacity = 11</code>；</li><li>然后调用<code>ensureExplicitCapacity(int minCapacity)</code>方法，此时<code>elementData</code>数组长度为<code>10</code>，<code>minCapacity - elementData.length</code>大于<code>0</code>，将再次进行<code>grow</code>扩容。</li></ul><p>而扩容的流程我们知道，会调用<code>Arrays.copyOf(elementData, newCapacity)</code>方法进行数组拷贝，会有性能损耗。</p><p>所以，具有匠心的代码应该像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量的构造</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 连续添加10个元素</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;j&quot;</span>);</span><br><span class="line"><span class="comment">// 添加第11个元素</span></span><br><span class="line">list.add(<span class="string">&quot;k&quot;</span>);</span><br><span class="line"><span class="comment">// do other</span></span><br></pre></td></tr></table></figure><p>调用指定初始容量的构造器，在创建<code>list</code>对象时就会对<code>elementData</code>数组进行初始化，而不是在第一次调用<code>add</code>方法时。</p><p>所以如果能提前预估到集合容量，尽量提前指定容量，避免频繁的扩容带来的性能损耗。</p><blockquote><p>根据使用场景，如果集合的数据量不好预估，且只会对其进行增删操作，则不建议使用<code>ArrayList</code>集合，而是建议使用<code>LinkedList</code>集合。</p></blockquote><h4 id="插入至指定位置"><a href="#插入至指定位置" class="headerlink" title="插入至指定位置"></a>插入至指定位置</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 待插入元素的指定的位置的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 待插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 确保容量，修改modCount值</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 数组拷贝：将[index,size)索引区间的元素整体向后移动一个单位，将集合的`index`位置留空。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 给index索引位置赋值为待插入元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将一个集合全部元素插入至当前集合末尾"><a href="#将一个集合全部元素插入至当前集合末尾" class="headerlink" title="将一个集合全部元素插入至当前集合末尾"></a>将一个集合全部元素插入至当前集合末尾</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 集合转数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 待添加元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 确保容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 数组拷贝</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 传入集合无元素则返回false，否则返回true。</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将传入的集合<code>c</code>转为<code>Object[]</code>对象数组，调用<code>Collection</code>的<code>toArray()</code>方法，不管是哪种集合的实现，最终都会返回一个数组。以下是<code>ArrayList</code>类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用工具类的方法<code>Arrays.copyOf</code>方法进行数组拷贝，返回一个<code>Object[]</code>数组。</p><h4 id="从当前集合指定索引位置开始，将一个集合全部元素插入"><a href="#从当前集合指定索引位置开始，将一个集合全部元素插入" class="headerlink" title="从当前集合指定索引位置开始，将一个集合全部元素插入"></a>从当前集合指定索引位置开始，将一个集合全部元素插入</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 待插入集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 集合转Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 待插入集合元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 确保容量</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 不是从末尾添加，则将[index,size)索引上的元素整体向后移动numMoved个单位。</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// Object数组拷贝至elementData</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 传入集合无元素则返回false，否则返回true。</span></span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除集合中的元素有多种情况：删除指定索引位置元素/删除指定元素/删除指定索引范围内的元素/删除全部元素/指定条件删除（<code>Java8</code>新增）等。</p><h4 id="删除指定索引位置元素"><a href="#删除指定索引位置元素" class="headerlink" title="删除指定索引位置元素"></a>删除指定索引位置元素</h4><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定索引位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取旧的index索引位置元素值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动元素：[index+1,size)索引区间的元素整体向前移动一个单位。</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 清除末尾索引原有的引用，减小集合大小</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回被删除的元素值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么判断<code>size - index - 1 &gt; 0</code>？</p><p>答：集合大小<code>size</code>是从<code>1</code>开始计算，而数组下标索引<code>index</code>是从<code>0</code>开始计算。</p></blockquote><h4 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h4><p>由于<code>ArrayList</code>集合中的元素可以重复，指定的元素可能在集合中出现多次，所以该方法删除的是指定元素在集合中第一次出现位置的元素。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null：==运算符比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非null：equals方法比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fori</code>循环是从索引为<code>0</code>开始遍历，所以删除的是具有最低索引的元素。</p></blockquote><p>我们来看下<code>fastRemove(index);</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 移动元素：[index+1,size)索引区间元素整体向前移动一位。</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 清除末尾索引原有的引用，减小集合大小</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除指定索引范围内的元素"><a href="#删除指定索引范围内的元素" class="headerlink" title="删除指定索引范围内的元素"></a>删除指定索引范围内的元素</h4><p>该方法为<code>ArrayList</code>类中受保护的方法，外部无法直接进行调用。由<code>JDK</code>集合框架内部进行使用。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定 fromIndex 小于 toIndex，否则，进行元素移动时会出现索引越界。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 开始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">    <span class="comment">// 移动元素：[toIndex,size)索引区间元素整体向前移动toIndex - fromIndex个单位。</span></span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 计算新的数组大小</span></span><br><span class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 清除删除的索引位置原有的引用</span></span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定新的数组大小</span></span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除全部元素"><a href="#删除全部元素" class="headerlink" title="删除全部元素"></a>删除全部元素</h4><p>有两种情况：一种是删除当前集合全部元素，方法为<code>clear()</code>；另一种是从当前集合中删除指定集合中包含的所有元素，方法为<code>removeAll(Collection&lt;?&gt; c)</code>。</p><p><code>clear()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 清除所有索引位置的引用对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小置0</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeAll(Collection&lt;?&gt; c)</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，调用<code>Java8</code>提供的<code>Objects.requireNonNull(c);</code>方法对传入的集合<code>c</code>进行非空校验。</p><p>然后，调用私有方法<code>batchRemove(c, false)</code>，传入集合<code>c</code>和布尔值<code>false</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写一个简单的<code>demo</code>来看下其过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; removeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    removeList.add(<span class="number">1</span>);</span><br><span class="line">    removeList.add(<span class="number">2</span>);</span><br><span class="line">    removeList.add(<span class="number">3</span>);</span><br><span class="line">    removeList.add(<span class="number">4</span>);</span><br><span class="line">    removeList.add(<span class="number">5</span>);</span><br><span class="line">    removeList.add(<span class="number">6</span>);</span><br><span class="line">    List&lt;Integer&gt; beRemovedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    beRemovedList.add(<span class="number">3</span>);</span><br><span class="line">    beRemovedList.add(<span class="number">4</span>);</span><br><span class="line">    beRemovedList.add(<span class="number">6</span>);</span><br><span class="line">    System.out.println(removeList);</span><br><span class="line">    System.out.println(beRemovedList);</span><br><span class="line">    removeList.removeAll(beRemovedList);</span><br><span class="line">    System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>创建一个<code>removeList</code>集合并初始化六个元素，再创建一个待删除的<code>beRemovedList</code>集合并初始化三个元素（在<code>removeList</code>中）。</p><p>下面我们来分析<code>removeAll</code>方法的具体执行流程：</p><p>当我们调用<code>removeList.removeAll(beRemovedList);</code>时，会先对<code>beRemovedList</code>进行非空校验，然后调用<code>batchRemove</code>方法：</p><p>1、使用局部最终变量<code>elementData</code>指向当前集合（<code>removeList</code>）的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br></pre></td></tr></table></figure><p>2、定义两个索引并初始化为<code>0</code>，以及定义一个布尔值用来记录当前集合是否被修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>3、从<code>r</code>到<code>size</code>进行遍历，判断传入的集合<code>c</code>是否包含<code>r</code>位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">    <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">        elementData[w++] = elementData[r];</span><br></pre></td></tr></table></figure><p>我们对着我们的<code>demo</code>程序进行分析，<code>c = &#123;3, 4, 6&#125;</code>，<code>elementData = &#123;1, 2, 3, 4, 5, 6&#125;</code>，<code>size=6</code>，<code>complement = false</code>。</p><p>每次循环<code>r</code>的值增一，循环结束的条件为<code>r &lt; size</code>不成立，即当<code>r = size</code>时循环结束。</p><ul><li>第一次循环：<code>r = 0</code>，<code>elementData[r] = 1</code>，<code>c.contains(1) = false</code>。<code>if</code>条件成立，<code>w = 0</code>。将<code>elementData[r]</code>赋值给<code>elementData[w++]</code>：即将当前不在<code>c</code>集合中的元素赋值到集合的第<code>0</code>位置，随后<code>w</code>增一。此时<code>elementData</code>的第<code>0</code>位置元素为：<code>1</code>。</li><li>第二次循环：<code>r = 1</code>，<code>elementData[r] = 2</code>，<code>c.contains(2) = false</code>。<code>if</code>条件成立，<code>w = 1</code>。将<code>elementData[r]</code>赋值给<code>elementData[w++]</code>：即将当前不在<code>c</code>集合中的元素赋值到集合的第<code>1</code>位置，随后<code>w</code>增一。此时<code>elementData</code>的第<code>1</code>位置元素为：<code>2</code>。</li><li>第三次循环：<code>r = 2</code>，<code>elementData[r] = 3</code>，<code>c.contains(3) = true</code>。<code>if</code>条件不成立，<code>w</code>的值为<code>2</code>，不做任何操作。</li><li>第四次循环：<code>r = 3</code>，<code>elementData[r] = 4</code>，<code>c.contains(4) = true</code>。<code>if</code>条件不成立，<code>w</code>的值为<code>2</code>，不做任何操作。</li><li>第五次循环：<code>r = 4</code>，<code>elementData[r] = 5</code>，<code>c.contains(5) = false</code>。<code>if</code>条件成立，<code>w = 2</code>，将<code>elementData[r]</code>赋值给<code>elementData[w++]</code>：即将当前不在<code>c</code>集合中的元素赋值到集合的第<code>2</code>位置，随后<code>w</code>增一。此时<code>elementData</code>的第<code>2</code>位置元素为：<code>5</code>。</li><li>第六次循环：<code>r = 5</code>，<code>elementData[r] = 6</code>，<code>c.contains(6) = true</code>。<code>if</code>条件不成立，<code>w</code>的值为<code>3</code>，不做任何操作。</li></ul><p>循环结束，<code>w = 3</code>，<code>elementData = &#123;1, 2, 5, ......&#125;</code>，<code>r = 6</code>。</p><p>接下来我们来看下<code>finally</code>块中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line"><span class="comment">// even if c.contains() throws.</span></span><br><span class="line"><span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">    System.arraycopy(elementData, r,elementData, w,size - r);</span><br><span class="line">    w += size - r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    modCount += size - w;</span><br><span class="line">    size = w;</span><br><span class="line">    modified = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于我们的<code>demo</code>程序：</p><p>此时<code>r = size</code>，第一个<code>if</code>块不进入。</p><p>此时<code>(w = 3) != (size = 6)</code>，进入第二个<code>if</code>块，将索引从<code>w</code>到<code>size - 1</code>位置的元素置为<code>null</code>，释放对原来元素的引用。</p><p>接下来是一些收尾工作：</p><ul><li>记录修改次数，修改（移除）了<code>size - w</code>个元素；</li><li>将集合大小设为<code>w</code>：为在<code>for</code>循环中给<code>elementData</code>域赋值的元素个数。</li><li>设置修改标记为<code>true</code>，此处是<code>c</code>集合中的元素全部从集合中删除。</li></ul><p>最后，<code>batchRemove</code>方法返回<code>modified</code>布尔值：表示是否当前集合中删除了指定集合<code>c</code>中包含的所有元素。</p><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>修改方法只有一个：修改指定索引位置的元素为新的元素。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定的新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 获取index索引位置的旧元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 赋值为新的指定元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h3><p>由于<code>ArrayList</code>底层由<code>elementData</code>数组存储元素，所以支持按数组下标访问：即随机快速访问。其查询的时间复杂度为<code>O(1)</code>，这也是为什么<code>ArrayList</code>实现<code>RandomAccess</code>的原因：标记该类支持随机快速访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 按数组下标取值</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><h4 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a><code>clone</code>方法</h4><p><a href="/2020/04/26/javase/base/cloneable">传送门</a></p><h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a><code>size</code>方法</h4><p>获取集合大小：返回成员变量<code>size</code>。</p><h4 id="isEmpty方法"><a href="#isEmpty方法" class="headerlink" title="isEmpty方法"></a><code>isEmpty</code>方法</h4><p>判断集合是否为空集合：返回<code>size == 0</code>得到的值。</p><h4 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a><span id="indexOf"><code>indexOf</code>方法</span></h4><p>返回指定元素在当前集合中第一次出现的位置索引。如果当前集合中不包含此元素，返回<code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null：使用==运算符比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非null：使用equals方法比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前往后遍历，<code>null</code>值使用<code>==</code>运算符进行比较，其它对象使用<code>equals</code>方法比较。</p><h4 id="lastIndexOf方法"><a href="#lastIndexOf方法" class="headerlink" title="lastIndexOf方法"></a><code>lastIndexOf</code>方法</h4><p>返回指定元素在当前集合中最后一次出现的位置索引。如果当前集合中不包含此元素，返回<code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从后往前遍历，<code>null</code>值使用<code>==</code>运算符进行比较，其它对象使用<code>equals</code>方法比较。</p><h4 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a><code>contains</code>方法</h4><p>判断指定元素是否在集合中。调用的是<a href="#indexOf"><code>indexOf(o)</code></a>方法，判断其返回值是否大于等于<code>0</code>，等于<code>-1</code>说明不在集合中。</p><h4 id="iterator方法"><a href="#iterator方法" class="headerlink" title="iterator方法"></a><code>iterator</code>方法</h4><p>该方法是迭代器设计模式的体现。使用了<code>new</code>关键字创建了一个私有内部类<code>Itr</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有内部类<code>Itr</code>实现了<code>java.util.Iterator</code>迭代器接口。其成员变量有三个：</p><ul><li><code>cursor</code>：游标（下一个要返回元素的索引）。</li><li><code>lastRet</code>：初始化为<code>-1</code>，最后一个被返回元素的索引；如果集合中本来没有任何元素则返回<code>-1</code>。</li><li><code>expectedModCount</code>：期望的修改次数。初始化为当前集合的<code>modCount</code>。</li></ul><p>只有一个无参构造函数。</p><p>我们知道使用迭代器对<code>ArrayList</code>进行遍历的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; iteratorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">iteratorList.add(<span class="number">1</span>);</span><br><span class="line">iteratorList.add(<span class="number">2</span>);</span><br><span class="line">iteratorList.add(<span class="number">3</span>);</span><br><span class="line">iteratorList.add(<span class="number">4</span>);</span><br><span class="line">iteratorList.add(<span class="number">5</span>);</span><br><span class="line">iteratorList.add(<span class="number">6</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iterator = iteratorList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Integer next = iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中关键的两个方法为：<code>hasNext()</code>和<code>next()</code>。接下来我们着重来看下这两个方法。</p><p>首先调用<code>iteratorList</code>对象的<code>iterator()</code>方法得到一个迭代器对象，经过上面的分析我们可知这实际是一个<code>Itr</code>对象。</p><p>其<code>hasNext()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回当前游标<code>cursor</code>是否不等于集合大小<code>size</code>。如果不等于<code>size</code>，说明还有下一个元素。可继续迭代。否则迭代完成。</p><p><code>next()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fail-fast机制</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 获取当前游标</span></span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="comment">// 当前游标超过集合大小则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="comment">// 获取存储元素的数组对象</span></span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="comment">// 当前游标超出数组长度：与hasNext方法中的判断出现了矛盾。并发修改：fail-fast机制</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="comment">// 校验通过，游标加一</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最后一个被返回元素的索引赋值为旧的游标i，返回旧的游标对应的元素。</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>Itr</code>类中使用<code>this</code>指代的是当前<code>Itr</code>对象，使用<code>ArrayList.this</code>指代的是集合对象。</p></blockquote><blockquote><p>为什么<code>ArrayList</code>使用迭代器遍历没有普通<code>fori</code>循环遍历效率高？</p><p>答：经过以上代码的分析，原因显而易见：使用迭代器遍历，首先需要使用<code>new</code>关键字创建一个<code>Itr</code>对象，创建对象需要耗时（一次）；其次，中间有多次条件判断并且有局部变量产生，以及一个加<code>1</code>操作，这也需要耗费时间（多次：每次调用<code>next</code>方法）。</p></blockquote><h2 id="Demo实战"><a href="#Demo实战" class="headerlink" title="Demo实战"></a><code>Demo</code>实战</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.collect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        ArrayList&lt;String&gt; addList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合尾部插入</span></span><br><span class="line">        addList.add(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合指定索引位置插入</span></span><br><span class="line">        addList.add(<span class="number">1</span>,<span class="string">&quot;指定位置1&quot;</span>);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合指定索引位置插入：索引位置无元素且不是尾部：索引越界。</span></span><br><span class="line">        <span class="comment">// addList.add(10,&quot;指定位置2&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待插入集合初始化</span></span><br><span class="line">        ArrayList&lt;String&gt; toBeAddList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        toBeAddList.add(<span class="string">&quot;测试2&quot;</span>);</span><br><span class="line">        toBeAddList.add(<span class="string">&quot;测试3&quot;</span>);</span><br><span class="line">        toBeAddList.add(<span class="string">&quot;测试4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待指定索引位置插入集合初始化</span></span><br><span class="line">        ArrayList&lt;String&gt; toBeAddIndexList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        toBeAddIndexList.add(<span class="string">&quot;测试5&quot;</span>);</span><br><span class="line">        toBeAddIndexList.add(<span class="string">&quot;测试6&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个集合全部元素插入至当前集合末尾</span></span><br><span class="line">        addList.addAll(toBeAddList);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前集合指定索引位置开始，将一个集合全部元素插入</span></span><br><span class="line">        addList.addAll(<span class="number">1</span>,toBeAddIndexList);</span><br><span class="line">        System.out.println(addList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        List&lt;Integer&gt; removeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        removeList.add(<span class="number">1</span>);</span><br><span class="line">        removeList.add(<span class="number">2</span>);</span><br><span class="line">        removeList.add(<span class="number">6</span>);</span><br><span class="line">        removeList.add(<span class="number">3</span>);</span><br><span class="line">        removeList.add(<span class="number">4</span>);</span><br><span class="line">        removeList.add(<span class="number">5</span>);</span><br><span class="line">        removeList.add(<span class="number">6</span>);</span><br><span class="line">        removeList.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定索引位置元素</span></span><br><span class="line">        removeList.remove(<span class="number">1</span>);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定元素在集合中第一次出现位置的元素</span></span><br><span class="line">        removeList.remove(<span class="keyword">new</span> Integer(<span class="number">6</span>));</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除元素集合</span></span><br><span class="line">        List&lt;Integer&gt; beRemovedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        beRemovedList.add(<span class="number">2</span>);</span><br><span class="line">        beRemovedList.add(<span class="number">3</span>);</span><br><span class="line">        beRemovedList.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line">        System.out.println(beRemovedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前集合中删除指定集合中包含的所有元素</span></span><br><span class="line">        <span class="keyword">boolean</span> b = removeList.removeAll(beRemovedList);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除全部元素</span></span><br><span class="line">        removeList.clear();</span><br><span class="line">        System.out.println(removeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改元素集合初始化</span></span><br><span class="line">        ArrayList&lt;Integer&gt; operatorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        operatorList.add(<span class="number">1</span>);</span><br><span class="line">        operatorList.add(<span class="number">2</span>);</span><br><span class="line">        operatorList.add(<span class="number">3</span>);</span><br><span class="line">        operatorList.add(<span class="number">2</span>);</span><br><span class="line">        operatorList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(operatorList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改元素，将索引为1的元素修改为6</span></span><br><span class="line">        operatorList.set(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(operatorList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询元素</span></span><br><span class="line">        Integer integer = operatorList.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        Object clone = operatorList.clone();</span><br><span class="line">        System.out.println(clone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size</span></span><br><span class="line">        System.out.println(operatorList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// isEmpty</span></span><br><span class="line">        System.out.println(operatorList.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// indexOf</span></span><br><span class="line">        System.out.println(operatorList.indexOf(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lastIndexOf</span></span><br><span class="line">        System.out.println(operatorList.lastIndexOf(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// contains</span></span><br><span class="line">        System.out.println(operatorList.contains(<span class="number">3</span>));</span><br><span class="line">        System.out.println(operatorList.contains(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器设计模式</span></span><br><span class="line">        List&lt;Integer&gt; iteratorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        iteratorList.add(<span class="number">1</span>);</span><br><span class="line">        iteratorList.add(<span class="number">2</span>);</span><br><span class="line">        iteratorList.add(<span class="number">3</span>);</span><br><span class="line">        iteratorList.add(<span class="number">4</span>);</span><br><span class="line">        iteratorList.add(<span class="number">5</span>);</span><br><span class="line">        iteratorList.add(<span class="number">6</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = iteratorList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通fori循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = iteratorList.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(iteratorList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// forEach遍历，底层实现为迭代器</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : iteratorList) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ArrayList</code>集合是我们在工作中用到的最多的集合，我们必须熟练掌握其特性。</p><p>通过上面的源码分析可知，<code>ArrayList</code>集合查找效率非常高。顺序添加元素至末尾效率也很高，但需要确保不扩容，否则进行数组拷贝很耗时。所以我们在创建<code>ArrayList</code>对象时，如果可以预估到集合中元素个数，最好指定初始容量，以避免在插入时扩容带来的性能损耗。</p><p>本文<code>Demo</code>实战代码见：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/java-se/src/main/java/com/sunchaser/javase/collect/ArrayListTest.java">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之AbstractSequentialList</title>
      <link href="2020/05/27/javase/base/abstract-sequential-list/"/>
      <url>2020/05/27/javase/base/abstract-sequential-list/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>AbstractSequentialList</code>类是一个抽象类，它继承了<code>AbstractList</code>抽象类。同样提供了有序集合的骨架实现，但是它是最大程度地减少了支持顺序访问数据的实现类所需的工作。如果需要随机访问数据，优先使用<code>AbstractList</code>抽象类。</p><p>从某种意义上说，该类与<code>AbstractList</code>抽象类相反，该类实现了随机访问方法，而不是像<code>AbstractList</code>抽象类一样抛出异常。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>该抽象类提供了有序集合的骨架实现。让实现类支持顺序访问。</p><p>如果要实现集合，只需继承该类并实现该类的<code>listIterator()</code>抽象方法和<code>AbstractCollection#size()</code>方法；</p><p>如果要实现不可修改的集合，只需继承该类并实现列表迭代器<code>ListIterator</code>的<code>hasNext</code>/<code>next</code>/<code>hasPrevious</code>/<code>previous</code>/<code>index</code>方法。</p><p>如果要实现可修改的集合，在实现不可修改集合的基础上，需要另外实现列表迭代器的<code>set</code>方法；对于可变大小的集合，还需要实现列表迭代器的<code>remove</code>和<code>add</code>方法。</p><p>此外，实现类同样应该遵循<code>Collection</code>接口中提出的规范：必须提供两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数的构造器。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractSequentialList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个使用<code>protected</code>修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是一个骨架实现，并不提供顺序访问集合的完整功能。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>按正确的顺序返回此列表的列表迭代器，其开始索引为入参<code>index</code>。该类中的其它方法都是基于此抽象方法返回的列表迭代器实现的。</p><h3 id="已实现方法"><a href="#已实现方法" class="headerlink" title="已实现方法"></a>已实现方法</h3><p>所有的已实现方法都传入了索引值，对于客户端而言，看似是随机访问，但内部实现却是顺序访问。</p><h4 id="获取指定索引位置的元素"><a href="#获取指定索引位置的元素" class="headerlink" title="获取指定索引位置的元素"></a>获取指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>index</code>索引开始的列表迭代器后调用其<code>next</code>方法获取<code>index</code>索引位置元素返回。</p><h4 id="用指定元素替换指定索引位置的元素"><a href="#用指定元素替换指定索引位置的元素" class="headerlink" title="用指定元素替换指定索引位置的元素"></a>用指定元素替换指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E oldVal = e.next();</span><br><span class="line">        e.set(element);</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取<code>index</code>索引开始的列表迭代器后调用其<code>next</code>方法获取<code>index</code>索引位置的旧值，然后调用列表迭代器的<code>set</code>方法，覆盖<code>next</code>方法最后返回的<code>index</code>索引位置的元素，最后返回旧值。</p><h4 id="在指定索引位置插入指定元素"><a href="#在指定索引位置插入指定元素" class="headerlink" title="在指定索引位置插入指定元素"></a>在指定索引位置插入指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listIterator(index).add(element);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现会将当前位于<code>index</code>位置的元素（如果有的话）和后续所有元素右移一位（索引增一）。</p><p>首先获取<code>index</code>索引开始的列表迭代器，然后调用列表迭代器的<code>add</code>方法插入指定的元素。</p><p>所以列表迭代器必须实现<code>add</code>方法，否则该方法将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="删除指定索引位置的元素"><a href="#删除指定索引位置的元素" class="headerlink" title="删除指定索引位置的元素"></a>删除指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E outCast = e.next();</span><br><span class="line">        e.remove();</span><br><span class="line">        <span class="keyword">return</span> outCast;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现会将<code>index</code>索引位置后续所有元素左移一位（索引减一）。</p><p>首先获取<code>index</code>索引开始的列表迭代器，然后获取<code>index</code>索引位置的旧元素，再调用列表迭代器的<code>remove</code>方法删除元素，最后返回旧元素。</p><p>所以列表迭代器必须实现<code>remove</code>方法，否则该方法将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="在指定索引位置插入指定集合"><a href="#在指定索引位置插入指定集合" class="headerlink" title="在指定索引位置插入指定集合"></a>在指定索引位置插入指定集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        ListIterator&lt;E&gt; e1 = listIterator(index);</span><br><span class="line">        Iterator&lt;? extends E&gt; e2 = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (e2.hasNext()) &#123;</span><br><span class="line">            e1.add(e2.next());</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现会将当前位于<code>index</code>索引位置及其后续所有元素右移，指定集合中的元素将以其迭代器返回的顺序显示在当前集合中。</p><p>分别获取当前集合的列表迭代器和指定集合的普通迭代器，迭代指定集合，依次将元素<code>add</code>至当前集合中。</p><p>所以列表迭代器必须实现<code>add</code>方法，否则该方法将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="获取普通迭代器"><a href="#获取普通迭代器" class="headerlink" title="获取普通迭代器"></a>获取普通迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用当前类的抽象方法<code>listIterator()</code>，返回列表迭代器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该抽象类提供了顺序访问集合的骨架实现，是<code>LinkedList</code>集合的直接父类。所有实现依托于该类的<code>listIterator()</code>抽象方法。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之LinkedList</title>
      <link href="2020/05/27/javase/base/linkedlist/"/>
      <url>2020/05/27/javase/base/linkedlist/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>LinkedList</code>的底层实现是双向链表，在学习其源码之前，我们首先要搞懂链表的原理。</p><h2 id="单链表简介"><a href="#单链表简介" class="headerlink" title="单链表简介"></a>单链表简介</h2><p>单链表中的数据是以节点的形式来表示的，每个节点存储了当前节点的元素值（数据域）和下一个节点（后继节点）的地址值（指针域）。每个节点的内存空间可以是不连续的，它通过每个节点的指针域将各个节点连接起来。</p><p>每个节点只有一个指针域的链表称为单链表。如果想要遍历单链表，则必须从头节点开始迭代。</p><h2 id="双向链表简介"><a href="#双向链表简介" class="headerlink" title="双向链表简介"></a>双向链表简介</h2><p>双向链表与单链表相比，它的每个节点在单链表的基础上还存储了上一个节点（前驱节点）的地址值。也就是说，我们从任一节点开始，都可以遍历整个链表。</p><h2 id="循环链表简介"><a href="#循环链表简介" class="headerlink" title="循环链表简介"></a>循环链表简介</h2><p>单链表和双链表都可以构造成循环链表，只需将最后一个节点的后继结点指针域指向头节点，形成一个环。因此，从循环链表的任意一个节点开始，都可以遍历整个链表。</p><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a><code>LinkedList</code>简介</h2><p><code>LinkedList</code>类是基于双向链表实现的，它继承了<code>AbstractSequentialList</code>顺序访问集合抽象模板类，实现了有序集合接口<code>List</code>和双端队列接口<code>Deque</code>。所以，<code>LinkedList</code>即可以作为集合使用，同时可以用作双端队列，还可以用作栈。这是一个非常优秀的实现类。</p><h2 id="LinkedList特性"><a href="#LinkedList特性" class="headerlink" title="LinkedList特性"></a><code>LinkedList</code>特性</h2><p>由于<code>LinkedList</code>类继承自<code>AbstractSequentialList</code>抽象类，而<code>AbstractSequentialList</code>抽象类又继承自<code>AbstractList</code>抽象类。于是<code>LinkedList</code>类得到了<code>AbstractList</code>抽象类的<code>modCount</code>字段。基于该字段实现了<code>fail-fast</code>机制。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义集合的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向双向链表第一个节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向双向链表最后一个节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br></pre></td></tr></table></figure><h3 id="Node节点类"><a href="#Node节点类" class="headerlink" title="Node节点类"></a><code>Node</code>节点类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 数据域</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>遵循了<code>Collection</code>接口的规范：提供了两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参构造器：构造一个包含指定集合中元素的链表，其顺序为指定集合迭代器返回的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参构造器中没有任何操作。</p><p>带参构造器中首先调用了无参构造器，然后调用<code>addAll(c)</code>方法构造链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该<code>addAll(c)</code>方法是将指定集合<code>c</code>添加至此列表末尾，由于是在构造器中调用，所以<code>size</code>为初始值<code>0</code>。</p><p>我们来看下重载的<code>addAll(size,c)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合转Object数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// pred： 插入位置的前驱节点（索引：index - 1）</span></span><br><span class="line">    <span class="comment">// succ： 插入位置的后继节点（索引：index + 1）</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="comment">// 插入位置为末尾</span></span><br><span class="line">        <span class="comment">// 后继节点为null</span></span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 前驱节点为 last</span></span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入位置不在末尾，在链表中间</span></span><br><span class="line">        <span class="comment">// 后继节点为 node(index)</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        <span class="comment">// 前驱节点为后继节点succ的前驱节点</span></span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代Object数组a</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="comment">// 强制类型转换</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">        <span class="comment">// 创建一个新的节点newNode：其前驱节点为pred，节点数据域为此次迭代元素e，后继节点为null</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 前驱节点为null：链表初始为空链表；新节点newNode为头节点</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 前驱节点不为null：将pred的后继节点指向newNode</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        <span class="comment">// 将前驱节点置为newNode，以便下次迭代链接节点。</span></span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 后继节点为null：初始插入位置为链表末尾：将last置为最后一次迭代的pred，即为链表末尾元素。</span></span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 后继节点不为null：从链表中间进行插入：将最后一次迭代的pred元素的后继节点指向succ。</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">        <span class="comment">// 将succ的前驱节点指向pred。</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是将指定集合插入至指定索引位置，指定索引位置的元素（如果有的话）和后续所有元素都将右移。</p><p>分为两种情况：</p><p>1、 从链表尾部插入</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/jdk/linkedlistaddfromlast.gif" alt="从链表尾部插入"></p><p>初始条件为：</p><ul><li>初始链表为：<code>[L,I,N]</code></li><li>指定索引位置：<code>index：3</code></li><li>待插入元素集合：<code>collection：[K,E,D]</code></li><li>插入位置的前驱节点：<code>pred：N</code></li><li>插入位置的后继节点：<code>succ：null</code></li></ul><p>插入过程：</p><p>迭代开始：</p><ul><li>待插入集合转数组：<code>a：[K,E,D]</code></li><li>第一次迭代：创建新节点<code>newNode</code>，值为<code>K</code>，前驱节点<code>pred</code>为<code>N</code>，后继节点<code>succ</code>为<code>null</code>，将N的后继节点指向<code>K</code>，将前驱节点<code>pred</code>引用<code>newNode:K</code>。</li><li>第二次迭代：创建新节点<code>newNode</code>，值为<code>E</code>，前驱节点<code>pred</code>为<code>K</code>，后继节点<code>succ</code>为<code>null</code>，将<code>K</code>的后继节点指向<code>E</code>， 将前驱节点<code>pred</code>引用<code>newNode:E</code>。</li><li>第三次迭代：创建新节点<code>newNode</code>，值为<code>D</code>，前驱节点<code>pred</code>为<code>E</code>，后继节点<code>succ</code>为<code>null</code>，将<code>E</code>的后继节点指向<code>D</code>，将前驱节点<code>pred</code>引用<code>newNode:D</code>。</li></ul><p>迭代完成。</p><p>此时后继节点<code>succ</code>仍指向<code>null</code>，前驱节点<code>pred</code>引用<code>newNode:D</code>，为链表末尾节点，将<code>last</code>引用置为<code>pred</code>。</p><p>集合大小增加了数组<code>a</code>的长度个；修改次数<code>modCount</code>增加。</p><p>2、 从链表中间插入</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/jdk/linkedlistaddfrommid.gif" alt="从链表中间插入"></p><p>初始条件为：</p><ul><li>初始链表为：<code>[L,I,N,D]</code></li><li>指定索引位置：<code>index：3</code></li><li>待插入元素集合：<code>collection：[K,E]</code></li><li>插入位置的前驱节点：<code>pred：N</code></li><li>插入位置的后继节点：<code>succ：D</code></li></ul><p>插入过程：</p><p>迭代开始：</p><ul><li>待插入集合转数组：<code>a：[K,E]</code></li><li>第一次迭代：创建新节点<code>newNode</code>，值为<code>K</code>，前驱节点<code>pred</code>为<code>N</code>，后继节点<code>succ</code>为<code>D</code>，将N的后继节点指向<code>K</code>，将前驱节点<code>pred</code>引用<code>newNode:K</code>。</li><li>第二次迭代：创建新节点<code>newNode</code>，值为<code>E</code>，前驱节点<code>pred</code>为<code>K</code>，后继节点<code>succ</code>为<code>D</code>，将<code>K</code>的后继节点指向<code>E</code>， 将前驱节点<code>pred</code>引用<code>newNode:E</code>。</li></ul><p>迭代完成。</p><p>此时后继节点<code>succ</code>仍指向<code>D</code>，前驱节点<code>pred</code>引用<code>newNode:E</code>，<code>last</code>引用仍指向<code>D</code>。</p><p>将<code>pred</code>的后继节点指向<code>D</code>，将<code>D</code>的前驱节点指向<code>E</code>。</p><p>集合大小增加了数组<code>a</code>的长度个；修改次数<code>modCount</code>增加。</p><h3 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h3><p><code>LinkedList</code>类中提供了一些默认或私有方法用来将一个指定元素连接至整个链表。</p><h4 id="连接指定元素作为头节点"><a href="#连接指定元素作为头节点" class="headerlink" title="连接指定元素作为头节点"></a><span id="linkFirst">连接指定元素作为头节点</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取链表头节点f</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 创建一个新的节点，其数据域为e，后继节点为链表头节点f。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 链表头节点引用指向新节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 旧的头节点为null：原链表为空链表。将尾节点引用last也指向新节点。</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 旧的头节点不为null：新节点将作为整个链表的新的头节点。将旧的头节点的前驱节点指向新节点。</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过头节点引用<code>first</code>获取当前链表头节点<code>f</code>，然后创建一个新的<code>Node</code>节点<code>newNode</code>，其数据域为指定元素<code>e</code>，后继节点为当前链表头节点<code>f</code>；</p><p>然后将头节点引用<code>first</code>指向<code>newNode</code>，判断旧的头节点<code>f</code>是否为<code>null</code>，如果是，则原链表为空链表，将尾节点引用<code>last</code>指向<code>newNode</code>；否则，将旧的头节点<code>f</code>的前驱节点指向<code>newNode</code>。</p><h4 id="连接指定元素作为尾节点"><a href="#连接指定元素作为尾节点" class="headerlink" title="连接指定元素作为尾节点"></a><span id="linkLast">连接指定元素作为尾节点</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取链表尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建一个新的节点，其数据域为e，前驱节点为链表尾节点l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 链表尾节点引用执行新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 旧的尾节点为null：原链表为空链表。将头节点引用也指向新节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 旧的尾节点不为null：新节点将作为整个链表的新的尾节点。将旧的尾节点的后继节点指向新节点。</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过尾节点引用<code>last</code>获取当前链表尾节点<code>l</code>，然后创建一个新的<code>Node</code>节点<code>newNode</code>，其数据域为指定元素<code>e</code>，前驱节点为当前链表尾节点<code>l</code>；</p><p>然后将尾节点引用<code>last</code>指向<code>newNode</code>，判断旧的尾节点<code>l</code>是否为<code>null</code>，如果是，则原链表为空链表，将头节点引用<code>first</code>指向<code>newNode</code>；否则，将旧的尾节点<code>l</code>的后继节点指向<code>newNode</code>。</p><h4 id="在指定节点之前连接指定元素"><a href="#在指定节点之前连接指定元素" class="headerlink" title="在指定节点之前连接指定元素"></a><span id="linkBefore">在指定节点之前连接指定元素</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点succ不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">// 获取指定节点的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 创建一个新的节点，其数据域为e，前驱节点为指定节点的前驱节点，后继节点为指定节点。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 指定节点的前驱节点指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 指定节点的旧的前驱节点为null：指定节点为原链表的头节点。新节点将作为新的头节点。</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 指定节点的旧的前驱节点不为null：将指定节点的旧的前驱节点的后继节点指向新节点。</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">// 集合大小增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点<code>succ</code>非空，否则将导致<code>NPE</code>问题。</p><p>首先获取指定节点的前驱节点<code>pred</code>，然后创建一个新的<code>Node</code>节点<code>newNode</code>，其前驱节点为<code>pred</code>，数据域为指定元素<code>e</code>，后继节点为指定节点<code>succ</code>。</p><p>将指定节点<code>succ</code>的前驱节点指向<code>newNode</code>，判断指定节点<code>succ</code>的旧的前驱节点<code>pred</code>是否为<code>null</code>，如果是，则指定节点<code>succ</code>为原链表的头节点，将头节点引用<code>first</code>指向<code>newNode</code>；否则，将旧的前驱节点<code>pred</code>的后继节点指向<code>newNode</code>。</p><h4 id="取消头节点的连接"><a href="#取消头节点的连接" class="headerlink" title="取消头节点的连接"></a>取消头节点的连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点f为链表头节点且不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">// 获取头节点的元素值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 获取头节点的后继节点：即将成为新的头节点。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 将原头节点的数据域和后继节点置为null。解除对其它对象的引用，便于GC清理。</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 将头节点引用指向next</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// next为null：原链表只有一个节点。将尾节点引用置为null。</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// next不为null：将next的前驱节点置为null。取消对原头节点的引用，便于GC清理。</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被剔除的节点元素值。</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点为链表的头节点且非空，否则将导致<code>NPE</code>问题。</p><p>获取头节点的数据域值<code>element</code>和后继节点<code>next</code>，将头节点的数据域和后继节点置为<code>null</code>。解除对原对象的引用，便于<code>GC</code>清理。</p><p>然后将头节点引用<code>first</code>指向<code>next</code>，判断<code>next</code>是否为<code>null</code>，如果是，则原链表只有一个节点，将尾节点引用<code>last</code>置为<code>null</code>；否则，将<code>next</code>节点的前驱节点置为<code>null</code>，取消对原链表头节点的引用。</p><h4 id="取消尾节点的连接"><a href="#取消尾节点的连接" class="headerlink" title="取消尾节点的连接"></a><span id="unlinkLast">取消尾节点的连接</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点l为链表尾节点且不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">// 获取尾节点的元素值</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 获取尾节点的前驱节点：即将成为新的尾节点。</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 将原尾节点的数据域和前驱节点置为null。解除对其它对象的引用，便于GC清理。</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 将尾节点引用指向prev</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// prev为null：原链表只有一个节点。将头节点引用置为null。</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// prev不为null：将prev的后继节点置为null。取消对原尾节点的引用，便于GC清理。</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被剔除的节点元素值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点为链表的尾节点且非空，否则将导致<code>NPE</code>问题。</p><p>获取尾节点的数据域值<code>element</code>和前驱节点<code>prev</code>，将尾节点的数据域和前驱节点置为<code>null</code>。解除对原对象的引用，便于<code>GC</code>清理。</p><p>然后将尾节点引用<code>last</code>指向<code>prev</code>，判断<code>prev</code>是否为<code>null</code>，如果是，则原链表只有一个节点，将头节点引用<code>first</code>置为<code>null</code>；否则，将<code>prev</code>节点的后继节点置为<code>null</code>，取消对原链表尾节点的引用。</p><h4 id="取消指定节点的连接"><a href="#取消指定节点的连接" class="headerlink" title="取消指定节点的连接"></a><span id="unlink">取消指定节点的连接</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定节点x不为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 获取指定节点x的数据域元素</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">// 获取指定节点x的后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取指定节点x的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定节点的前驱节点为null：指定节点为原链表头节点。指定节点的后继节点将作为新的头节点。</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将指定节点的前驱节点的后继节点指向指定节点的后继节点。</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 指定节点的前驱节点置为null</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定节点的后继节点为null：指定节点为原链表尾节点。指定节点的前驱节点将作为新的尾节点。</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将指定节点的后继节点的前驱节点指向指定节点的前驱节点。</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 指定节点的后继节点置为null</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定节点的数据域元素置为null</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集合大小减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被剔除的节点元素值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定节点<code>x</code>非空，否则将导致<code>NPE</code>问题。</p><p>分别获取指定节点<code>x</code>的数据域元素<code>element</code>、后继节点<code>next</code>和前驱节点<code>prev</code>。</p><p>如果前驱节点<code>prev</code>为<code>null</code>，则在原链表中，指定节点<code>x</code>为头节点，指定节点的后继节点<code>next</code>将作为新的头节点：将<code>first</code>引用指向后继节点<code>next</code>；否则将前驱节点<code>prev</code>的后继节点指向<code>next</code>，将指定元素<code>x</code>的前驱节点置为<code>null</code>。</p><p>如果后继节点<code>next</code>为<code>null</code>，则在原链表中，指定节点<code>x</code>为尾节点，指定节点的前驱节点<code>prev</code>将作为新的尾节点：将<code>last</code>引用指向前驱节点<code>prev</code>；否则将后继节点<code>next</code>的前驱节点指向<code>prev</code>，将指定元素<code>x</code>的后继节点置为<code>null</code>。</p><p>最后将指定节点<code>x</code>的数据域置为<code>null</code>，解除对象引用，便于<code>GC</code>清理。</p><h4 id="获取指定索引位置的Node节点"><a href="#获取指定索引位置的Node节点" class="headerlink" title="获取指定索引位置的Node节点"></a><span id="node">获取指定索引位置的<code>Node</code>节点</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约定指定索引合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 二分法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 指定索引在[0,size/2)之间</span></span><br><span class="line">        <span class="comment">// 获取头节点x</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 从0迭代到index，每次迭代将x赋值为x的后继节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="comment">// 迭代完成，x即为指定索引位置的节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定索引在[size/2,size]之间</span></span><br><span class="line">        <span class="comment">// 获取尾节点 </span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">// 从size-1迭代到index，每次迭代将x赋值为x的前驱节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="comment">// 迭代完成，x即为指定索引位置的节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定指定索引不会产生越界。</p><p>采用二分法的思想优化时间复杂度，如果指定索引<code>index</code>在<code>[0,size/2)</code>范围内，则从<code>0</code>迭代至<code>index - 1</code>，迭代之前获取头节点<code>x</code>，每次迭代将<code>x</code>赋值为<code>x</code>的后继节点，迭代完成时，<code>x</code>即为指定索引<code>index</code>位置的元素；如果指定索引<code>index</code>在[size/2,size)之间，则从<code>size - 1</code>迭代至<code>index + 1</code>，迭代之前获取尾节点<code>x</code>，每次迭代将<code>x</code>赋值为<code>x</code>的前驱节点，迭代完成时，<code>x</code>即为指定索引<code>index</code>位置的元素。</p><h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><p><code>LinkedList</code>继承了<code>AbstractSequentialList</code>有序集合顺序访问抽象模板类。对集合方法进行了实现，可以作为集合使用。</p><h4 id="添加指定元素至集合末尾"><a href="#添加指定元素至集合末尾" class="headerlink" title="添加指定元素至集合末尾"></a><span id="add">添加指定元素至集合末尾</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用内部方法linkLast(e)</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的最初来源是<code>Collection</code>接口中定义的<code>add(E e)</code>方法。</p><blockquote><p><code>AbstractSequentialList</code>抽象类继承了<code>AbstractList</code>抽象类，在<code>AbstractList</code>抽象类中已经实现了<code>add(E e)</code>方法。它只要求子类去实现<code>add(int index,E e)</code>方法即可实现<code>add(E e)</code>。在<code>LinkedList</code>类中已经提供了<code>add(int index,E e)</code>方法的实现，它为什么还要重写<code>add(E e)</code>方法呢？</p><p>理解：<code>LinkedList</code>作为一个优秀的实现类，它继承/实现了多个接口。在编码开发时，我们经常面向接口编程，例如：<code>List&lt;String&gt; list = new LinkedList&lt;&gt;()</code>。<code>LinkedList</code>类的对象会向上转型为<code>List</code>类。对于实例对象<code>list</code>来说，此时它是一个<code>List</code>，它所具有的方法是<code>List</code>接口中定义的方法，而不是<code>LinkedList</code>类中的方法，所以当我们调用<code>list.add(E e)</code>时，实际上调用的是<code>List</code>类中定义的<code>add(E e)</code>方法，而它的实现是在<code>LinkedList</code>类中。</p><p>也就是说，当我们想把<code>LinkedList</code>作为<code>List</code>集合使用时，我们可以写成：<code>List&lt;String&gt; list = new LinkedList&lt;&gt;()</code>。而当我们想把<code>LinkedList</code>当做<code>Queue</code>队列使用时，我们可以写成<code>Queue&lt;String&gt; queue = new LinkedList&lt;&gt;()</code>。它可以向上转型成任意的父接口（或父接口的父接口），向上转型后，实例对象只拥有转型后的接口中所定义的方法。所以，<code>LinkedList</code>类中对所有父接口中定义的方法都进行了实现，以便向上转型使用。</p><p>这体现了<code>Java</code>的多态机制。</p></blockquote><p>直接调用了内部方法<a href="#linkLast"><code>linkLast(e)</code></a>，在不出现异常的情况下固定返回<code>true</code>。</p><h4 id="在指定索引位置添加指定元素"><a href="#在指定索引位置添加指定元素" class="headerlink" title="在指定索引位置添加指定元素"></a>在指定索引位置添加指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 指定索引在集合末尾：调用内部方法连接指定元素至链表末尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 指定索引在集合中间：调用内部方法连接指定元素至指定索引位置的节点之前。</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后判断指定索引是否在集合末尾，如果是，则指定元素为链表的新尾节点，调用内部方法<a href="#linkLast"><code>linkLast(e)</code></a>，将指定元素连接至链表末尾；否则，调用内部方法<a href="#linkBefore"><code>linkBefore(e,node)</code></a>将指定元素连接至指定索引位置的节点之前。</p><h4 id="清空所有元素"><a href="#清空所有元素" class="headerlink" title="清空所有元素"></a>清空所有元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="comment">// 迭代：初始x为头节点；迭代结束的条件为：x为null。</span></span><br><span class="line">        <span class="comment">// 获取x的后继节点</span></span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="comment">// 当前x的数据域、后继节点和前驱节点都置为null</span></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// x赋值为其后继节点，进行下一次迭代。</span></span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除头尾节点引用</span></span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 重置集合大小</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代链表，<code>for</code>循环中获取原链表头节点<code>x</code>，迭代过程中对<code>x</code>进行重新赋值，迭代结束的条件为<code>x</code>为<code>null</code>。</p><p>每次迭代将当前迭代的节点<code>x</code>的数据域、后继节点和前驱节点都置为<code>null</code>，然后将<code>x</code>赋值为<code>x</code>的后继节点，进行下一次迭代，直至<code>x</code>为尾节点。</p><p>迭代完成后清除头尾节点<code>first</code>和<code>last</code>的引用，重置集合大小为<code>0</code>。</p><h4 id="获取指定元素在集合中第一次出现的索引位置"><a href="#获取指定元素在集合中第一次出现的索引位置" class="headerlink" title="获取指定元素在集合中第一次出现的索引位置"></a>获取指定元素在集合中第一次出现的索引位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引记录</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 迭代：获取链表头节点x，迭代结束的条件为x为null，每次迭代完成将x赋值为x的后继节点</span></span><br><span class="line">            <span class="comment">// 判断节点x的数据域是否为null：是则找到了指定元素的第一次出现，返回索引记录index；否则，索引增一。</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素不为null，采用equals方法比较是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 迭代的条件同指定元素为null的情况</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成仍未返回：集合中不存在指定元素，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个索引记录<code>index</code>初始为<code>0</code>，然后迭代链表，分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>则采用<code>==</code>运算符比较；非<code>null</code>则采用<code>equals</code>方法比较是否相等。从链表头节点开始迭代，一旦找到相等的元素，则返回索引<code>index</code>，否则索引增一。如果迭代完成仍未找到指定元素，则返回<code>-1</code>。</p><h4 id="获取指定元素在集合中最后一次出现的索引位置"><a href="#获取指定元素在集合中最后一次出现的索引位置" class="headerlink" title="获取指定元素在集合中最后一次出现的索引位置"></a>获取指定元素在集合中最后一次出现的索引位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 索引记录初始为集合大小size</span></span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null，采用==运算符比较</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="comment">// 迭代：获取链表尾节点x，迭代结束的条件为x为null，每次迭代后将x赋值为x的前驱节点</span></span><br><span class="line">            <span class="comment">// 首先索引记录减一</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="comment">// 判断节点x的数据域是否为null：是则找到了指定元素的最后一次出现，返回索引记录index；否则，进行下一次迭代。</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素不为null，采用equals方法比较是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="comment">// 迭代的条件同指定元素为null的情况</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成仍未返回：集合中不存在指定元素，返回-1。</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个索引记录<code>index</code>初始为集合大小<code>size</code>，然后迭代链表，分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>则采用<code>==</code>运算符比较；非<code>null</code>则采用<code>equals</code>方法比较是否相等。从链表尾节点开始迭代，迭代一开始就将索引记录减一，然后进行相等比较，一旦找到相等的元素，则返回索引<code>index</code>，否则进行下一次迭代。如果迭代完成仍未找到指定元素，则返回<code>-1</code>。</p><h4 id="判断指定元素是否在集合中至少出现一次"><a href="#判断指定元素是否在集合中至少出现一次" class="headerlink" title="判断指定元素是否在集合中至少出现一次"></a>判断指定元素是否在集合中至少出现一次</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上调用的是<code>indexOf</code>方法寻找指定元素的索引位置，如果返回<code>-1</code>则集合中不存在该指定元素，否则表示指定元素在集合中至少出现过一次。</p><h4 id="获取指定索引位置的元素"><a href="#获取指定索引位置的元素" class="headerlink" title="获取指定索引位置的元素"></a>获取指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 调用内部方法node(index)获取指定索引位置的节点，取出数据域item返回。</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后调用内部方法<a href="#node"><code>node(index)</code></a>获取指定索引位置的节点，取出其数据域<code>item</code>返回。</p><h4 id="剔除指定索引位置的元素"><a href="#剔除指定索引位置的元素" class="headerlink" title="剔除指定索引位置的元素"></a><span id="remove">剔除指定索引位置的元素</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验指定索引是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 调用内部方法node获取指定索引位置节点，再调用内部方法unlink取消此节点的连接</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后调用内部方法<a href="#node"><code>node(index)</code></a>获取指定索引位置的节点，最后调用内部方法<a href="#unlink"><code>unlink(node)</code></a>取消此节点的连接。</p><h4 id="剔除指定元素的第一次出现"><a href="#剔除指定元素的第一次出现" class="headerlink" title="剔除指定元素的第一次出现"></a><span id="remove">剔除指定元素的第一次出现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null：从头节点x开始迭代，迭代结束的条件为x为null，每次迭代将x赋值为x的后继节点。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果找到了null元素，则调用内部方法unlink剔除x元素的连接。</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素非null</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 迭代的条件同指定元素为null的情况，使用equals比较当前迭代元素x与指定元素是否相等。</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成都未返回，则集合中无该元素，返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代链表，分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>采用<code>==</code>运算符进行比较，非<code>null</code>则采用<code>equals</code>方法比较是否相等。从链表头节点开始迭代，一旦找到相等的元素，则调用内部方法<a href="#unlink"><code>unlink(node)</code></a>取消该节点的连接，返回<code>true</code>。如果迭代完成时都未找到相等的元素，则返回<code>false</code>。</p><h4 id="覆盖指定索引位置的元素"><a href="#覆盖指定索引位置的元素" class="headerlink" title="覆盖指定索引位置的元素"></a>覆盖指定索引位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验指定索引是否越界</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 获取指定索引位置节点x</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 取出x的数据域</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    <span class="comment">// 给x的数据域赋值为指定元素</span></span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="comment">// 返回x节点旧的数据域</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验指定索引是否越界，然后调用内部方法<a href="#node"><code>node(index)</code></a>获取指定索引位置的节点<code>x</code>，取出节点<code>x</code>的数据域，然后为<code>x</code>的数据域重新赋值为指定元素，最后返回节点<code>x</code>旧的数据域。</p><h4 id="获取集合中元素个数"><a href="#获取集合中元素个数" class="headerlink" title="获取集合中元素个数"></a>获取集合中元素个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回<code>size</code>成员变量。</p><h4 id="转换成Object数组"><a href="#转换成Object数组" class="headerlink" title="转换成Object数组"></a>转换成<code>Object</code>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// 定义size长度的数组</span></span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从头节点x开始迭代，迭代结束的条件为x=null，每次迭代完成将x赋值为x的后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        <span class="comment">// 填充数组</span></span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="comment">// 返回数组</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个<code>size</code>长度的<code>Object</code>数组，然后从链表头节点开始迭代，每次迭代向<code>Object</code>数组中填充一个元素，迭代完成时数组中的元素即为链表中的全部元素，最后返回数组。</p><h4 id="转换成指定类型数组"><a href="#转换成指定类型数组" class="headerlink" title="转换成指定类型数组"></a>转换成指定类型数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">// 指定数组长度是否小于链表长度</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// 小于：重新分配一个size长度数组</span></span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回数组容器</span></span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="comment">// 迭代链表，填充元素。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="comment">// 迭代完成，如果指定数组的长度大于链表长度，则将返回数组容器中size索引位置的元素置为null</span></span><br><span class="line">    <span class="comment">// null元素之前为原链表元素，null元素之后为原指定数组元素。</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 数组返回。此时数组中元素类型已由Object强转成泛型T</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参为泛型数组<code>a</code>，判断入参数组长度是否小于链表长度，小于则重新分配一个链表长度<code>size</code>大小的数组空间。迭代链表，将元素填充至数组，迭代完成时，如果是重新分配的数组空间，则数组中的元素恰好全部为链表中的元素；否则数组中的元素多于链表中的元素，将<code>size</code>索引位置的元素置为<code>null</code>，此时，<code>null</code>元素之前为原链表元素，之后为原入参数组元素。最后返回将<code>Object</code>数组强转成泛型数组。</p><p>此方法可用于将集合中的元素类型转换为指定类型并转换成数组。</p><h3 id="双端队列方法"><a href="#双端队列方法" class="headerlink" title="双端队列方法"></a>双端队列方法</h3><p><code>LinkedList</code>实现了<code>Deque</code>双端队列接口，提供了双端队列的基本实现。</p><h4 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h4><h5 id="入队首"><a href="#入队首" class="headerlink" title="入队首"></a>入队首</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用内部方法<a href="#linkFirst"><code>linkFirst(e)</code></a>连接指定元素<code>e</code>作为新的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是调用了内部方法<a href="#linkFirst"><code>linkFirst(e)</code></a>连接指定元素<code>e</code>作为新的头节点。然后返回特殊值<code>true</code>。</p><h5 id="入队尾"><a href="#入队尾" class="headerlink" title="入队尾"></a>入队尾</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用内部方法<a href="#linkLast"><code>linkLast(e)</code></a>连接指定元素<code>e</code>作为新的尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是调用了内部方法<a href="#linkLast"><code>linkLast(e)</code></a>连接指定元素<code>e</code>作为新的尾节点。然后返回特殊值<code>true</code>。</p><h4 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h4><h5 id="从队首出队列"><a href="#从队首出队列" class="headerlink" title="从队首出队列"></a>从队首出队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。</p><p>否则调用内部方法<a href="#unlinkFirst"><code>unlinkFirst(e)</code></a>剔除头节点的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则调用内部方法<a href="#unlinkFirst"><code>unlinkFirst(e)</code></a>剔除头节点的连接。</p><p>此实现符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>removeFirst()</code>方法抛出异常，而<code>pollFirst()</code>方法返回特殊值<code>null</code>。</p><h5 id="从队尾出队列"><a href="#从队尾出队列" class="headerlink" title="从队尾出队列"></a>从队尾出队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。</p><p>否则调用内部方法<a href="#unlinkLast"><code>unlinkLast(e)</code></a>剔除尾节点的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则调用内部方法<a href="#unlinkLast"><code>unlinkLast(e)</code></a>剔除尾节点的连接。</p><p>此实现也符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>removeLast()</code>方法抛出异常，而<code>pollLast()</code>方法返回特殊值<code>null</code>。</p><h5 id="查询队首元素"><a href="#查询队首元素" class="headerlink" title="查询队首元素"></a><span id="getFirst">查询队首元素</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。否则返回头节点的数据域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则返回头节点的数据域。</p><p>此实现也符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>getFirst()</code>方法抛出异常，而<code>peekFirst()</code>方法返回特殊值<code>null</code>。</p><h5 id="查询队尾元素"><a href="#查询队尾元素" class="headerlink" title="查询队尾元素"></a>查询队尾元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，抛出<code>NoSuchElementException</code>异常。否则返回尾节点的数据域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先获取链表尾节点，如果尾节点为<code>null</code>，则为空队列，返回<code>null</code>，不会抛出异常；否则返回尾节点的数据域。</p><p>此实现也符合<code>Deque</code>接口中的定义：当队列为空队列时，<code>getLast()</code>方法抛出异常，而<code>peekLast()</code>方法返回特殊值<code>null</code>。</p><h5 id="删除第一次出现的指定元素"><a href="#删除第一次出现的指定元素" class="headerlink" title="删除第一次出现的指定元素"></a>删除第一次出现的指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用集合方法<a href="#remove"><code>remove(o)</code></a>剔除指定元素的第一次出现。</p><h5 id="删除最后一次出现的指定元素"><a href="#删除最后一次出现的指定元素" class="headerlink" title="删除最后一次出现的指定元素"></a>删除最后一次出现的指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 指定元素为null</span></span><br><span class="line">        <span class="comment">// 从尾节点开始迭代链表，一旦找到数据域为null的节点，则调用内部方法unlink剔除该节点的连接。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定元素非null，使用equals比较元素是否相等</span></span><br><span class="line">        <span class="comment">// 迭代的条件同指定元素为null的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代完成仍未找到，返回false。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为指定元素为<code>null</code>和非<code>null</code>两种情况，为<code>null</code>采用<code>==</code>运算符比较，非<code>null</code>采用<code>equals</code>方法比较。从尾节点开始迭代，一旦找到数据域与指定元素相等的节点，则调用内部方法<a href="#unlink"><code>unlink</code></a>剔除该节点的连接。</p><h3 id="普通队列方法"><a href="#普通队列方法" class="headerlink" title="普通队列方法"></a>普通队列方法</h3><p><code>Deque</code>双端队列接口中同样声明了普通队列<code>Queue</code>接口中定义的一系列方法。<code>LinkedList</code>类也对其进行了实现。</p><p><code>Queue</code>接口中定义的方法如下：</p><table><thead><tr><th align="left">action</th><th align="left">throws exception</th><th align="left">returns special value</th></tr></thead><tbody><tr><td align="left">insert</td><td align="left">add(e)</td><td align="left">offer(e)</td></tr><tr><td align="left">remove</td><td align="left">remove()</td><td align="left">poll()</td></tr><tr><td align="left">get head</td><td align="left">element()</td><td align="left">peek()</td></tr></tbody></table><p>它有三组共六个方法，在<code>Queue</code>接口的声明中约定了每组方法中有一个是失败时抛出指定异常，另一个是返回特殊值<code>null</code>或<code>false</code>。</p><p><code>LinkedList</code>类却没有完全遵守<code>Queue</code>接口的约定，所有方法在执行失败时均未抛出指定异常。这是为什么呢？</p><p>在我看来，<code>LinkedList</code>的实现初衷是作为<code>List</code>集合使用（这点可从类名体现出来，它是一种<code>List</code>）。由于其底层数据结构是双向链表，它可以用来实现队列等其它数据结构，所以设计者让<code>LinkedList</code>类实现了队列接口。</p><blockquote><p>是因为双向链表这种数据结构可以用来实现队列，所以才实现队列接口。而不是因为实现了队列接口，才决定使用双向链表这种数据结构。</p></blockquote><h4 id="从队尾入队列"><a href="#从队尾入队列" class="headerlink" title="从队尾入队列"></a>从队尾入队列</h4><p>第一个方法是<code>add(e)</code>，实际上这也是在<code>List</code>接口中定义的方法，它的实现既符合列表的定义，又符合队列的定义。</p><p>详情见集合方法中的<a href="#add"><code>add(e)</code></a>。</p><p>第二个方法是<code>offer(e)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了<a href="#add"><code>add(e)</code></a>方法。</p><h4 id="从队首出队列-1"><a href="#从队首出队列-1" class="headerlink" title="从队首出队列"></a>从队首出队列</h4><p>第一个方法是<code>remove()</code>，该方法同样也定义在了<code>List</code>接口中，详情见集合方法中的<a href="#remove"><code>remove</code></a>。</p><p>第二个方法是<code>poll()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回特殊值<code>null</code>；否则调用内部方法<a href="#unlinkFirst"><code>unlinkFirst(f)</code></a>剔除头节点的连接。这符合<code>Queue</code>接口中<code>poll</code>方法的定义。</p><h4 id="查询队首元素-1"><a href="#查询队首元素-1" class="headerlink" title="查询队首元素"></a>查询队首元素</h4><p>第一个方法是<code>element()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用双端队列的<a href="#getFirst"><code>getFirst()</code></a>方法查询队首元素。</p><p>第二个方法是<code>peek()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取链表头节点，如果头节点为<code>null</code>，则为空队列，返回特殊值<code>null</code>；否则返回头节点的数据域。这符合<code>Queue</code>接口中<code>peek</code>方法的定义。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><code>LinkedList</code>类只提供了列表迭代器的实现，基类<code>AbstractSequentialList</code>类中提供的普通迭代器实现也是列表迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验索引是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 返回从index位置开始的迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器<code>ListItr</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后一次通过迭代器返回的节点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前迭代器所持有的节点对象，它将作为迭代的依据，调用previous方法将返回其前驱节点；调用next方法将返回其后继节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前迭代器所持有的节点对象的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fail-fast机制的期望修改次数，初始化为AbstractList#modCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带参构造器，构造指定索引位置的列表迭代器。由外部校验索引合法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        <span class="comment">// index = size 是合法的，便于从后向前迭代。此时next为尾节点last的后继节点null，可以调用previous方法迭代尾节点。</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否迭代到了列表末尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前nextIndex索引位置的节点元素，且索引右移一位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fail-fast</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 记录最后一次通过迭代器返回的节点对象</span></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        <span class="comment">// 当前迭代器所持有的节点对象 赋值 为其后继节点</span></span><br><span class="line">        next = next.next;</span><br><span class="line">        <span class="comment">// 索引右移</span></span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="comment">// 返回元素值</span></span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否迭代到了列表开头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前nextIndex索引位置的节点元素，且索引左移一位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fail-fast机制</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">// 如果next为null，则初始化该迭代器对象时，构造方法中传入的index=size。</span></span><br><span class="line">        <span class="comment">// 表示从列表尾部开始迭代，将next赋值为尾节点last；否则赋值为其前驱节点。</span></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前迭代索引，其值由构造器初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前迭代索引前一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安全地从列表中删除上一次迭代方法（next/previous）返回的节点。</span></span><br><span class="line"><span class="comment">     * 迭代过程中只能调用该方法修改列表，否则将引发fail-fast机制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fail-fast机制</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 迭代状态校验：调用此remove方法之前必须先调用迭代方法。</span></span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上次迭代返回节点的后继节点</span></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        <span class="comment">// 剔除lastReturned节点的连接（会导致AbstractList#modCount增加）</span></span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="comment">// 从后往前（previous）迭代时，next = lastReturned成立</span></span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            <span class="comment">// 当前迭代器所持有的节点对象赋值为上次迭代返回节点的后继节点</span></span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 从前往后（next）迭代时，进入else分支，迭代索引减一。</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        <span class="comment">// 重置迭代器迭代状态，下次调用迭代方法之前不可再调用remove方法。</span></span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 期望修改次数增加</span></span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖上次迭代方法返回的节点数据域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代状态校验</span></span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="comment">// fail-fast机制</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 覆盖</span></span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在下次调用迭代方法将返回的节点之前连接指定节点e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line">        nextIndex++;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK8 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fail-fast机制：校验实际修改次数是否等于期望修改次数。不等则立即抛出ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>该类提供了深拷贝方法（从<code>LinkedList</code>维度来说可以称为深拷贝）。由于其内部持有的是对象引用，列表中的元素并没有进行“深拷贝”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 克隆实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个浅拷贝对象</span></span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="comment">// Put clone into &quot;virgin&quot; state</span></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 值填充</span></span><br><span class="line">    <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法：调用Object#clone浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之Deque</title>
      <link href="2020/05/11/javase/base/deque/"/>
      <url>2020/05/11/javase/base/deque/</url>
      
        <content type="html"><![CDATA[<h2 id="双端队列简述"><a href="#双端队列简述" class="headerlink" title="双端队列简述"></a>双端队列简述</h2><p>双端队列是一种更特殊的线性表。普通队列<code>Queue</code>只允许在队首删除元素，在队尾插入元素。而双端队列同时允许在队首和队尾插入和删除元素。</p><h2 id="Deque接口简述"><a href="#Deque接口简述" class="headerlink" title="Deque接口简述"></a><code>Deque</code>接口简述</h2><p><code>Deque</code>接口是<code>Java</code>中的双端队列定义，继承<code>java.util.Queue</code>接口，它提供了操作队首和队尾的六组方法：插入队首/队尾元素、删除队首/队尾元素、提取队首/队尾元素。同<code>Queue</code>接口一样，每组操作都包含两种形式：一种在操作失败时抛出异常；另一种返回特殊的值（<code>null</code>或<code>false</code>）。</p><p>当把双端队列当做普通队列使用时，将出现<code>FIFO</code>（先进先出）行为。继承自<code>Queue</code>接口的方法等同于<code>Deque</code>接口中的特定方法。</p><p>双端队列也可用做<code>LIFO</code>（后进先出）堆栈。应该优先选用此接口，尽量不要使用旧版<code>java.util.Stack</code>类（继承自同步集合<code>Vector</code>）。</p><h2 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h2><p>双端队列操作接口：</p><table style="vertical-align:middle; text-align:center;">    <tr>        <th>操作位置</th>        <th colspan="2">队首（Head）</th>        <th colspan="2">队尾（Tail）</th>    </tr>    <tr>        <th>响应</th>        <th>throws exception</th>        <th>special value</th>        <th>throws exception</th>        <th>special value</th>    </tr>    <tr>        <td>insert</td>        <td>addFirst(e)</td>        <td>offerFirst(e)</td>        <td>addLast(e)</td>        <td>offerLast(e)</td>    </tr>    <tr>        <td>remove</td>        <td>removeFirst()</td>        <td>pollFirst()</td>        <td>removeLast()</td>        <td>pollLast()</td>    </tr>    <tr>        <td>get element</td>        <td>getFirst()</td>        <td>peekFirst()</td>        <td>getLast()</td>        <td>peekLast()</td>    </tr></table><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><h4 id="入队首"><a href="#入队首" class="headerlink" title="入队首"></a>入队首</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>插入指定元素至队首，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则抛出<code>IllegalStateException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>同样是插入指定元素至队首，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则返回<code>false</code>。不会抛出异常。</p><p>所以，当使用容量受限的队列时，通常使用<code>offerFirst</code>方法插入指定元素至队首。</p><h4 id="入队尾"><a href="#入队尾" class="headerlink" title="入队尾"></a>入队尾</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则抛出<code>IllegalStateException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>同样是插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则返回<code>false</code>。不会抛出异常。</p><p>所以，当使用容量受限的队列时，通常使用<code>offerLast</code>方法插入指定元素至队尾。</p><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><h4 id="从队首出队列"><a href="#从队首出队列" class="headerlink" title="从队首出队列"></a>从队首出队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除队首第一个元素，如果为空队列，则抛出NoSuchElementException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是删除队首第一个元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="从队尾出队列"><a href="#从队尾出队列" class="headerlink" title="从队尾出队列"></a>从队尾出队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除队尾第一个元素，如果为空队列，则抛出NoSuchElementException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是删除队尾第一个元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="查询队列元素"><a href="#查询队列元素" class="headerlink" title="查询队列元素"></a>查询队列元素</h3><h4 id="查询队首元素"><a href="#查询队首元素" class="headerlink" title="查询队首元素"></a>查询队首元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>获取队首元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是获取队首元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h4 id="查询队尾元素"><a href="#查询队尾元素" class="headerlink" title="查询队尾元素"></a>查询队尾元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>获取队尾元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是获取队尾元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h3><h4 id="删除第一次出现的指定元素"><a href="#删除第一次出现的指定元素" class="headerlink" title="删除第一次出现的指定元素"></a>删除第一次出现的指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>从此双端队列中删除第一次出现的指定元素<code>e</code>。如果从未出现，则队列保持不变。判断队列中的元素与指定元素相等的条件为：<code>o == null ? e == null : o.equals(e)</code>。</p><h4 id="删除最后一次出现的指定元素"><a href="#删除最后一次出现的指定元素" class="headerlink" title="删除最后一次出现的指定元素"></a>删除最后一次出现的指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>从此双端队列中删除最后一次出现的指定元素<code>e</code>。如果从未出现，则队列保持不变。判断队列中的元素与指定元素相等的条件为：<code>o == null ? e == null : o.equals(e)</code>。</p><h3 id="作为普通队列"><a href="#作为普通队列" class="headerlink" title="作为普通队列"></a>作为普通队列</h3><p>该双端队列<code>Deque</code>接口同样提供了普通队列<code>Queue</code>的六个操作方法。用作普通队列时，产生<code>FIFO</code>（先进先出）行为，其方法等同于上述双端队列的特定方法。下面是它们的对应关系：</p><table><thead><tr><th align="left">Queue Method</th><th align="left">Equivalent Deque Method</th></tr></thead><tbody><tr><td align="left">add(e)</td><td align="left">addLast(e)</td></tr><tr><td align="left">offer(e)</td><td align="left">offerLast(e)</td></tr><tr><td align="left">remove()</td><td align="left">removeFirst()</td></tr><tr><td align="left">poll()</td><td align="left">pollFirst()</td></tr><tr><td align="left">element()</td><td align="left">getFirst()</td></tr><tr><td align="left">peek()</td><td align="left">peekFirst()</td></tr></tbody></table><p>虽然<code>Deque</code>接口也提供了普通队列的六个操作方法，但我们尽量不要去使用它们，而是使用其对应的方法。</p><p>例如入队列，最好不要调用<code>offer(e)</code>，而是调用<code>offerLast(e)</code>。</p><p>因为当使用<code>offer(e)</code>时，我们还需要思考，<code>offer(e)</code>实际上就是<code>offerLast(e)</code>：从队尾入队列。如果我们直接调用<code>offerLast(e)</code>，一眼就能看出是从队尾入队列。</p><p>所以，使用<code>Deque</code>接口时，推荐明确使用<code>xxxLast</code>/<code>xxxFirst</code>这类方法。</p><h3 id="作为栈"><a href="#作为栈" class="headerlink" title="作为栈"></a>作为栈</h3><p>双端队列可以当做栈（<code>LIFO</code>后进先出）来使用。它提供了遗留类<code>Stack</code>中对栈的基本操作方法。这些方法等同于上述双端队列的特定方法。下面是它们的对应关系：</p><table><thead><tr><th align="left">Stack Method</th><th align="left">Equivalent Deque Method</th></tr></thead><tbody><tr><td align="left">push(e)</td><td align="left">addFirst(e)</td></tr><tr><td align="left">pop()</td><td align="left">removeFirst()</td></tr><tr><td align="left">peek()</td><td align="left">peekFirst()</td></tr></tbody></table><p>当做栈使用时，尽量使用栈的方法：<code>push(e)</code>/<code>pop</code>/<code>peek</code>，不要调用其对应的方法。</p><p>因为遗留类<code>Stack</code>已经存在了，考虑到类库兼容性问题无法将其覆盖，所以在<code>Deque</code>接口中定义了栈的方法，当我们把<code>Deque</code>当做栈使用时，直接调用栈的方法会使语义更加明确。</p><h3 id="作为集合"><a href="#作为集合" class="headerlink" title="作为集合"></a>作为集合</h3><p>由于<code>Deque</code>接口继承了<code>Queue</code>接口，而<code>Queue</code>接口又继承了<code>Collection</code>接口，所以<code>Deque</code>也可作为集合使用。它也定义了一些集合的基本操作。</p><p>判断指定元素<code>o</code>与双端队列中元素<code>e</code>相等的条件为：<code>o == null ? e == null : o.equals(e)</code>。</p><h4 id="删除第一次出现的指定元素-1"><a href="#删除第一次出现的指定元素-1" class="headerlink" title="删除第一次出现的指定元素"></a>删除第一次出现的指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>与<code>Collection</code>接口中定义的类似，删除指定元素在集合中的第一次出现。实际上，该方法等同与<code>removeFirstOccurrence(o)</code>方法。</p><h4 id="判断是否包含指定元素"><a href="#判断是否包含指定元素" class="headerlink" title="判断是否包含指定元素"></a>判断是否包含指定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>该双端队列中至少包含一个指定的元素<code>o</code>。</p><h4 id="查询元素个数"><a href="#查询元素个数" class="headerlink" title="查询元素个数"></a>查询元素个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回该双端队列中的元素个数。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>提供了两个不同元素顺序的迭代器。</p><h5 id="从队首到队尾的迭代器"><a href="#从队首到队尾的迭代器" class="headerlink" title="从队首到队尾的迭代器"></a>从队首到队尾的迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>迭代器中的元素顺序为双端队列从队首到队尾的元素顺序。</p><h5 id="从队尾到队首的迭代器"><a href="#从队尾到队首的迭代器" class="headerlink" title="从队尾到队首的迭代器"></a>从队尾到队首的迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>以相反的顺序返回迭代器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Deque</code>接口定义了一个双端队列（<code>Double Ended Queue</code>），它可以从队首或队尾操作元素；也可以当做普通队列<code>Queue</code>使用；同时还可以当做栈<code>Stack</code>来使用。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之Queue</title>
      <link href="2020/05/11/javase/base/queue/"/>
      <url>2020/05/11/javase/base/queue/</url>
      
        <content type="html"><![CDATA[<h2 id="队列简述"><a href="#队列简述" class="headerlink" title="队列简述"></a>队列简述</h2><p>队列是一种特殊的线性表，它具有先进先出（<code>FIFO</code>）的特点，只允许在表的前端（<code>front</code>）进行删除操作，而在表的后端（<code>rear</code>）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p><h2 id="Queue接口简述"><a href="#Queue接口简述" class="headerlink" title="Queue接口简述"></a><code>Queue</code>接口简述</h2><p><code>Queue</code>接口是<code>Java</code>中的队列定义，它也是<code>Java</code>容器中的一员，继承自<code>java.util.Collection</code>接口。<code>Queue</code>接口在<code>Collection</code>接口的基础上定义了三组操作：插入、删除和提取。每组操作都包含两种形式：一种在操作失败时抛出异常；另一种返回特殊的值（<code>null</code>或<code>false</code>）。</p><h2 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h2><table><thead><tr><th align="left">action</th><th align="left">throws exception</th><th align="left">returns special value</th></tr></thead><tbody><tr><td align="left">insert</td><td align="left">add(e)</td><td align="left">offer(e)</td></tr><tr><td align="left">remove</td><td align="left">remove()</td><td align="left">poll()</td></tr><tr><td align="left">get head</td><td align="left">element()</td><td align="left">peek()</td></tr></tbody></table><h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则抛出<code>IllegalStateException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>同样是插入指定元素至队尾，如果成功则返回<code>true</code>，如果达到了当前队列的最大容量限制，则返回<code>false</code>。不会抛出异常。</p><p>所以，当使用容量受限的队列时，通常使用<code>offer</code>方法插入元素。</p><h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>删除队首第一个元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是删除队首第一个元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h3 id="查询队首元素"><a href="#查询队首元素" class="headerlink" title="查询队首元素"></a>查询队首元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>获取队首元素，如果为空队列，则抛出<code>NoSuchElementException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样是获取队首元素，如果为空队列，则返回<code>null</code>。不会抛出异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Queue</code>接口实现通常不允许插入<code>null</code>元素，尽管某些实现（例如<code>LinkedList</code>）可以插入<code>null</code>元素，也不应将<code>null</code>插入队列中，因为<code>poll</code>和<code>peek</code>方法会在队列为空队列时返回特殊值<code>null</code>，会产生歧义。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之AbstractList</title>
      <link href="2020/05/08/javase/base/abstract-list/"/>
      <url>2020/05/08/javase/base/abstract-list/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>AbstractList</code>类是一个抽象类，它继承了<code>AbstractCollection</code>抽象类并实现了<code>List</code>接口。<code>List</code>接口定义了一种有序集合，可以精确控制每个元素的插入位置；而<code>AbstractCollection</code>抽象类提供了两个抽象方法，基于这两个抽象方法提供出了集合的最基本实现。</p><p>所以，<code>AbstractList</code>抽象类提供的是有序集合的骨架实现，用以最大程度地减少支持随机访问数据（例如数组）的实现类所需的工作。而对于顺序访问数据（例如链表），应该优先使用<code>AbstractSequentialList</code>抽象类。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>该抽象类提供了有序集合的骨架实现。让实现类支持随机快速访问。</p><p>如果要实现不可修改的有序集合，只需继承该类并为<code>get</code>和<code>size</code>方法提供实现；如果要实现可修改的有序集合，在实现不可修改的有序集合基础之上，还要另外重写此类的两个重载的<code>set</code>方法（否则将抛出<code>UnsupportedOperationException</code>异常），如果集合的大小是可变的，还要再另外重写两个重载的<code>add</code>方法和一个<code>remove</code>方法。</p><p>此外，实现类同样应该遵循<code>Collection</code>接口中提出的规范：必须提供两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数的构造器。</p><p>与其它抽象集合实现不同，此类的实现类不是必须要提供迭代器实现；此类的迭代器和列表迭代器是在“随机访问”方法之上由此类自身进行实现的。</p><p>“随机访问”方法（索引访问）有：</p><ul><li><code>get(int)</code></li><li><code>set(int, Object)</code></li><li><code>set(int, E)</code></li><li><code>add(int Object)</code></li><li><code>add(int, E)</code></li><li><code>remove(int)</code></li></ul><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>只有一个使用<code>protected</code>修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是一个骨架实现，并不提供有序集合的完整功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>只有一个成员变量，表示该列表被结构修改的次数。</p><p>结构修改是指：更改列表大小或以其它方式干扰列表。</p><p>此字段由<code>iterator</code>和<code>listIterator</code>方法返回的迭代器使用。如果在迭代过程中修改了该字段的值，则迭代器将在<code>next</code>、<code>remove</code>和<code>previous</code>方法中抛出<code>ConcurrentModificationException</code>异常。这里就是<code>Java</code>普通集合的<code>fail-fast</code>机制。否则将出现不确定的行为。</p><p>子类对该字段的使用是可选的，当子类需要提供具有<code>fail-fast</code>机制的迭代器（或列表迭代器）时，只需在其<code>add</code>和<code>remove</code>方法中修改该字段的值，一次调用<code>add</code>或<code>remove</code>方法必须修改该值且不超过<code>1</code>。否则迭代器将抛出<code>ConcurrentModificationException</code>异常；当子类不需要提供具有<code>fail-fast</code>机制的迭代器时，可直接忽略该字段。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>该类中只包含一个抽象方法，用于支持随机快速访问（根据索引取值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="已实现方法"><a href="#已实现方法" class="headerlink" title="已实现方法"></a>已实现方法</h3><p>所有的实现方法都是基于该类的抽象方法或其它已实现方法，大部分实现是基于迭代器的。部分方法中直接抛出<code>UnsupportedOperationException</code>异常，这样的实现表示该方法需要子类进行重写实现。总的来看，该类提供了有序集合的模板实现。下面我们来具体的分析每个方法。</p><h4 id="快速访问"><a href="#快速访问" class="headerlink" title="快速访问"></a>快速访问</h4><h5 id="添加指定元素至列表末尾"><a href="#添加指定元素至列表末尾" class="headerlink" title="添加指定元素至列表末尾"></a>添加指定元素至列表末尾</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了重载的<code>add</code>方法，传入<code>size()</code>方法的返回值和指定元素，然后返回<code>true</code>。</p><p>只要重载的<code>add</code>方法中不出现异常，则该<code>add</code>方法始终返回<code>true</code>。</p><p>需要注意的是，支持此操作的列表可能会对可以添加至列表的元素进行限制。例如，某些列表拒绝添加<code>null</code>元素，而另一些对可能添加的元素进行类型限制。所以实现类应在其文档中明确指出对可以添加的元素有哪些限制。</p><h5 id="在指定索引位置添加指定元素"><a href="#在指定索引位置添加指定元素" class="headerlink" title="在指定索引位置添加指定元素"></a>在指定索引位置添加指定元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h5 id="用指定元素来覆盖指定索引位置的值"><a href="#用指定元素来覆盖指定索引位置的值" class="headerlink" title="用指定元素来覆盖指定索引位置的值"></a>用指定元素来覆盖指定索引位置的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h5 id="添加指定元素至指定索引位置"><a href="#添加指定元素至指定索引位置" class="headerlink" title="添加指定元素至指定索引位置"></a>添加指定元素至指定索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h5 id="删除指定索引位置的元素"><a href="#删除指定索引位置的元素" class="headerlink" title="删除指定索引位置的元素"></a>删除指定索引位置的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中直接抛出<code>UnsupportedOperationException</code>异常，是必须要子类重写进行具体实现的。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><h5 id="查询指定元素在列表中第一次出现的索引位置"><a href="#查询指定元素在列表中第一次出现的索引位置" class="headerlink" title="查询指定元素在列表中第一次出现的索引位置"></a>查询指定元素在列表中第一次出现的索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现为：首先调用该类的<code>listIterator()</code>方法获取一个指向列表开头的列表迭代器，然后，从前往后遍历列表，直到第一次找到指定的元素或到达列表的末尾（返回<code>-1</code>）。</p><h5 id="查询指定元素在列表中最后一次出现的索引位置"><a href="#查询指定元素在列表中最后一次出现的索引位置" class="headerlink" title="查询指定元素在列表中最后一次出现的索引位置"></a>查询指定元素在列表中最后一次出现的索引位置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (it.previous()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.previous()))</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的实现为：首先调用该类的<code>listIterator()</code>方法传入<code>size()</code>方法的返回值（该列表的大小）获取一个指向列表末尾的列表迭代器，然后，从后往前遍历列表，直到第一次找到指定的元素或到达列表的开头（返回<code>-1</code>）。</p><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><h5 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除此列表中的所有元素，内部调用的是<code>removeRange</code>方法。子类必须重写本类的<code>remove</code>或<code>removeRange</code>方法，否则将抛出<code>UnsupportedOperationException</code>异常。</p><p>我们来看下<code>removeRange</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该列表中删除索引介于<code>fromIndex</code>和<code>toIndex</code>之间的元素，将<code>toIndex</code>索引后的所有元素左移。当<code>fromIndex</code>等于<code>toIndex</code>时，此方法不会做任何操作。</p><p>入参有两个：</p><ul><li><code>fromIndex</code>：要删除的第一个元素的索引；</li><li><code>toIndex</code>：要删除的最后一个元素之后的索引。</li></ul><p>首先调用<code>listIterator(fromIndex)</code>方法获取位于<code>fromIndex</code>之前的列表迭代器，然后迭代索引区间为<code>[0,toIndex-fromIndex)</code>的元素，在每次迭代过程中，调用<code>ListIterator.next</code>方法获取下一个元素，然后调用<code>ListIterator.remove</code>方法删除当前迭代索引元素，直到删除了整个范围内的元素为止。</p><p>如果<code>ListIterator.remove</code>方法的时间复杂度为<code>O(n)</code>，那么该方法的时间复杂度为<code>O(n^2)</code>。</p><h5 id="将指定集合从指定索引位置开始插入"><a href="#将指定集合从指定索引位置开始插入" class="headerlink" title="将指定集合从指定索引位置开始插入"></a>将指定集合从指定索引位置开始插入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指定集合<code>c</code>从索引为<code>index</code>的位置开始插入，需要子类实现<code>add(int,E)</code>方法，否则将抛出<code>UnsupportedOperationException</code>异常。</p><p>首先调用<code>rangeCheckForAdd(index)</code>方法校验索引范围（区间为<code>[0,size())</code>），然后迭代指定集合<code>c</code>，使用<code>add(int,E)</code>方法进行插入。</p><p>一般来说，子类会选择重写该方法来提高批量插入效率。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="普通迭代器"><a href="#普通迭代器" class="headerlink" title="普通迭代器"></a>普通迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接创建内部类<code>Itr</code>的实例对象返回。我们来看下这个内部类<code>Itr</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                    cursor--;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有三个成员变量：</p><ul><li><code>cursor</code>：游标，初始化为<code>0</code>，后续调用该内部类的<code>next</code>方法返回的元素索引。</li><li><code>lastRet</code>：初始化为<code>-1</code>，最近一次调用<code>next</code>或<code>previous</code>方法返回的元素索引。如果一次调用中删除了当前指向的元素，则将其重置为<code>-1</code>。</li><li><code>expectedModCount</code>：期望修改次数，初始化为外部类<code>AbstractList</code>的成员变量<code>modCount</code>，迭代器认为后续迭代过程中列表应该具有的<code>modCount</code>值，如果期望值与实际<code>modCount</code>值不相等，则出现了并发修改的情况。</li></ul><p>有三个公共方法：</p><p>1、判断是否还有下一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前游标是否等于列表大小。<code>size()</code>方法为父类<code>AbstractCollection</code>中的抽象<code>size()</code>方法。</p><p>2、获取当前游标索引指向的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        E next = get(i);</span><br><span class="line">        lastRet = i;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用当前内部类的<code>checkForComodification()</code>方法校验期望修改次数<code>expectedModCount</code>是否等于实际修改次数<code>modCount</code>。如果不相等，则已出现并发修改，抛出<code>ConcurrentModificationException</code>异常。</p><p>然后调用外部类<code>AbstractList</code>的抽象方法<code>get(int)</code>根据当前游标索引取值，将当前游标值赋给成员变量<code>lastRet</code>，当前游标右移一位，最后返回取到的元素。</p><p>先校验<code>modCount</code>的值，如果在校验通过且代码执行到<code>get(i)</code>之前时有其它线程修改了当前列表的大小，则可能会出现索引越界<code>IndexOutOfBoundsException</code>的异常，此时将其捕获，在<code>catch</code>块中再次进行<code>modCount</code>校验，如果校验不通过，则会直接抛出<code>ConcurrentModificationException</code>异常；但可能在这次校验之前又有其它线程将当前列表还原了，此时校验又会通过，所以在校验之后主动抛出<code>NoSuchElementException</code>异常。</p><p>3、删除最近一次通过<code>next</code>方法获取到的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">            cursor--;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先如果<code>lastRet</code>小于<code>0</code>，则该迭代器的<code>next</code>方法未先调用，抛出<code>IllegalStateException</code>异常。</p><p>然后检查<code>expectedModCount</code>与<code>modCount</code>是否相等，不相等则出现并发修改，抛出<code>ConcurrentModificationException</code>异常。</p><p>接下来调用外部类<code>AbstractList</code>的<code>remove</code>方法，删除上次通过<code>next</code>方法获取到的元素。所以<code>AbstractList</code>的子类必须重写<code>AbstractList</code>类的<code>remove</code>方法。</p><p>删除元素之后，将游标左移一位，此时指向的是删除的元素之后的第一个元素。然后重置<code>lastRet=-1</code>，重新将修改过后的<code>modCount</code>赋给<code>expectedModCount</code>。</p><blockquote><p>解释：</p><p>例如列表<code>A,B,C</code>。</p><p>初始状态：初始游标<code>cursor</code>为<code>0</code>指向元素<code>A</code>，<code>lastRet=-1</code>；</p><p>第一次调用<code>next</code>方法：游标<code>cursor</code>右移一位为<code>1</code>指向元素<code>B</code>，<code>lastRet=0</code>；</p><p>此时调用<code>AbstractList</code>的<code>remove</code>方法：删除索引为<code>lastRet=0</code>的元素<code>A</code>，<code>lastRet=0 &lt; cursor=1</code>，游标左移一位为<code>0</code>指向元素<code>B</code>，重置<code>lastRet=-1</code>并将<code>modCount</code>重新赋值给<code>expectedModCount</code>。</p><p>由于调用过外部类<code>AbstractList</code>的<code>remove</code>方法，此时的<code>modCount</code>值已经修改。</p></blockquote><h5 id="列表迭代器"><a href="#列表迭代器" class="headerlink" title="列表迭代器"></a>列表迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用<code>listIterator(0)</code>方法返回，我们来看下该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先校验传入索引<code>index</code>范围，然后直接一个返回<code>ListItr</code>的实例对象。我们来看下<code>ListItr</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            cursor = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                E previous = get(i);</span><br><span class="line">                lastRet = cursor = i;</span><br><span class="line">                <span class="keyword">return</span> previous;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该类继承了内部类<code>Itr</code>并实现了<code>ListIterator</code>接口。</p><p>继承得到了<code>Itr</code>类的三个属性：<code>cursor</code>、<code>lastRet</code>和<code>expectedModCount</code>。</p><p>只有一个带参构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    cursor = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让游标指向传入的索引<code>index</code>。</p><p>重写了<code>ListIterator</code>接口的六个方法，我们来依次看下实现：</p><p>1、判断是否有前一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接判断当前游标<code>cursor</code>是否指向<code>0</code>，为<code>0</code>表示指向列表开始位置，无前一个元素。</p><p>2、获取前一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        E previous = get(i);</span><br><span class="line">        lastRet = cursor = i;</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前游标指向索引的前一位<code>i</code>，获取其元素值<code>previous</code>，将索引<code>i</code>赋值给游标<code>cursor</code>和最后返回元素索引<code>lastRet</code>，最后返回元素<code>previous</code>。校验逻辑同<code>Itr</code>迭代器的<code>next</code>方法。</p><p>3、获取下一个即将迭代元素索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回游标<code>cursor</code>。</p><p>4、获取即将迭代元素的前一个元素的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回游标<code>cursor</code>减一。</p><p>5、用指定元素替换最近一次迭代返回的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅能在上次调用<code>next</code>或<code>previous</code>方法之后没有调用迭代器的<code>remove</code>或<code>add</code>方法的情况下才能调用。</p><p>调用了外部抽象类<code>AbstractList</code>的<code>set</code>方法将<code>lastRet</code>索引指向的元素替换成指定元素<code>e</code>，然后将实际<code>modCount</code>赋给期望修改次数<code>expectedModCount</code>。校验逻辑同<code>Itr</code>迭代器的<code>remove</code>方法。</p><p>6、插入指定元素至列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指定元素<code>e</code>插入列表，该元素的插入位置为：<code>next</code>方法返回的元素（如果有元素）之前和<code>previous</code>方法返回的元素（如果有元素）之后。如果列表中本来不包含任何元素，则指定元素<code>e</code>将成为列表中的唯一元素。调用此方法后，<code>nextIndex</code>和<code>previousIndex</code>方法的调用返回值将增加一。</p><p>首先获取当前游标指向索引<code>i</code>，然后调用外部类<code>AbstractList</code>的<code>add</code>方法将指定元素<code>e</code>插入指定索引<code>i</code>位置。将<code>lastRet</code>重置为<code>-1</code>，游标<code>cursor</code>增一，即下次调用<code>next</code>方法将返回指定元素<code>e</code>之后的元素，而调用<code>previous</code>方法将返回指定元素<code>e</code>。最后将实际<code>modCount</code>赋给期望修改次数<code>expectedModCount</code>。校验逻辑同<code>set</code>方法。</p><h4 id="比较和哈希"><a href="#比较和哈希" class="headerlink" title="比较和哈希"></a>比较和哈希</h4><h5 id="equals比较"><a href="#equals比较" class="headerlink" title="equals比较"></a><code>equals</code>比较</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较指定对象与此对象是否相等。当且仅当指定对象也是一个列表，且两个列表具有相同的大小，并且两个列表中所有对应的元素也均相等时，返回<code>true</code>。判断两个元素相等的条件为：当且仅当<code>e1 == null ? e2 == null : e1.equals(e2)</code>时，两个元素认为是相等的。</p><p>换句话说，如果两个列表包含相同顺序的相同元素，则将它们定义为相等。</p><p>此实现首先检查指定的对象是否为当前列表（<code>==</code>判断地址是否相等），如果是，则返回<code>true</code>；如果不是，将检查指定对象是否为<code>List</code>类型，如果不是则返回<code>false</code>；如果是，则迭代两个列表，比较相对应的元素对，如果有任何比较返回<code>false</code>，则该方法返回<code>false</code>。如果比较完成后任意一个迭代器还有元素，则返回<code>false</code>（因为两个列表长度不相等），否则迭代完成后将返回<code>true</code>。</p><h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a><code>hashCode</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实现完全使用<code>List#hashCode</code>方法文档中定义的列表哈希函数的代码。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之AbstractCollection</title>
      <link href="2020/05/05/javase/base/abstract-collection/"/>
      <url>2020/05/05/javase/base/abstract-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>java.util.AbstractCollection</code>类是一个抽象类，它实现了<code>Collection</code>接口。从设计模式的角度来看，以<code>Abstract</code>开头的类应该是一个模板方法类。事实也是如此，它提供了对<code>Collection</code>接口的最基本实现。以最大程度地减少实现类所需的工作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>该抽象类只提供了集合的最基本实现，并未对实现类的特性进行任何限制。</p><p>如果要实现不可修改的集合，只需继承该类并为<code>iterator</code>和<code>size</code>方法提供实现（由<code>iterator</code>方法返回的迭代器必须实现<code>hasNext</code>和<code>next</code>方法）；如果要实现可修改的集合，在实现不可修改集合的基础之上，还要另外重写此类的<code>add</code>方法（否则将抛出<code>UnsupportedOperationException</code>异常），同时由<code>iterator</code>方法返回的迭代器必须另外实现其<code>remove</code>方法。</p><p>此外，实现类同样应该遵循<code>Collection</code>接口中提出的规范：必须提供两个标准构造器：<code>void</code>无参构造器和带<code>Collection</code>类型的单个参数的构造器。</p><p>所有未进行实现的方法都被标记为抽象方法待子类实现。下面我们来看下在该抽象类中是如何对集合进行最基本实现的。</p><h2 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>只有一个使用<code>protected</code>修饰符修饰的无参构造器。说明该抽象类不允许外部直接实例化使用，因为它只是最基本的实现，并不具备集合的完整功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>只有一个静态成员变量，它表明了要分配的数组的最大大小。如果超出此限制可能会导致<code>OutOfMemoryError</code>。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>所有的抽象方法都是待具体子类去实现的方法。一共有两个：</p><ul><li><code>public abstract Iterator&lt;E&gt; iterator();</code>：返回一个迭代器。</li><li><code>public abstract int size();</code>：计算集合大小。</li></ul><h3 id="已实现方法"><a href="#已实现方法" class="headerlink" title="已实现方法"></a>已实现方法</h3><p>所有实现方法都是最基本的实现，当子类有更好的实现方式时完全可以进行重写。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><h5 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需判断<code>size()</code>方法计算出的集合大小是否为<code>0</code>即可。由于<code>size()</code>方法是抽象方法，此方法相当于还是交由子类实现。</p><h5 id="判断集合中是否包含指定的元素"><a href="#判断集合中是否包含指定的元素" class="headerlink" title="判断集合中是否包含指定的元素"></a>判断集合中是否包含指定的元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用抽象的<code>iterator</code>方法获取一个迭代器对象，然后对集合进行迭代遍历。</p><p>分为两种情况，指定的元素为<code>null</code>和非<code>null</code>，如果为<code>null</code>，则使用<code>==</code>运算符比较；如果为非<code>null</code>，则使用<code>equals</code>方法进行比较。</p><p>迭代器对象的<code>hasNext</code>和<code>next</code>方法均由具体子类进行实现。</p><h5 id="将集合转换成对象数组"><a href="#将集合转换成对象数组" class="headerlink" title="将集合转换成对象数组"></a>将集合转换成对象数组</h5><p>将该集合的迭代器返回的所有元素按相同顺序连续存储在数组中，数组索引从<code>0</code>开始。返回的数组长度等于集合元素的数量，即使在迭代过程中此集合的大小发生了改变（并发修改），最终返回的数组也与集合保持一致。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class="line">    Object[] r = <span class="keyword">new</span> Object[size()];</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext()) <span class="comment">// fewer elements than expected</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">        r[i] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建<code>size()</code>大小的<code>Object</code>数组，调用<code>iterator</code>方法得到集合的迭代器，然后对创建的<code>Object</code>数组进行下标索引遍历：</p><p>正常情况下，在<code>for</code>循环的遍历中，<code>it.hasNext()</code>方法将一直返回<code>true</code>，<code>if</code>条件判断将不会成立，循环完成后，迭代器的<code>hasNext</code>方法将返回<code>false</code>，最终将<code>r</code>数组返回；</p><p>而在并发修改的情况下，会出现迭代过程中集合元素减少的情况，这时<code>if(!it.hasNext())</code>判断成立，将返回<code>Arrays.copyOf(r,i)</code>：拷贝一个新数组，其长度为<code>i</code>；</p><p>同样地，并发修改会造成集合元素增加的情况，<code>for</code>循环遍历原集合长度<code>r.length</code>次后就已经结束了，再返回时进行了三目表达式判断，如果迭代器的<code>hasNext</code>方法返回<code>true</code>（还有下一个元素），则调用<code>finishToArray(r, it)</code>方法并返回。</p><p>下面我们来看下<code>finishToArray</code>方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = r.length;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cap = r.length;</span><br><span class="line">        <span class="keyword">if</span> (i == cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCap = cap + (cap &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// overflow-conscious code</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">                newCap = hugeCapacity(cap + <span class="number">1</span>);</span><br><span class="line">            r = Arrays.copyOf(r, newCap);</span><br><span class="line">        &#125;</span><br><span class="line">        r[i++] = (T)it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// trim if overallocated</span></span><br><span class="line">    <span class="keyword">return</span> (i == r.length) ? r : Arrays.copyOf(r, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参为原集合的对象数组（并发修改前的集合）和集合的迭代器。</p><p>首先记录原数组的长度为<code>i</code>；</p><p>然后开始迭代，再次记录一次原数组长度，用局部变量<code>cap</code>接收，在第一次迭代时<code>i == cap</code>成立，对<code>cap</code>进行扩容，<code>newCap = cap + (cap &gt;&gt; 1) + 1;</code>：扩容大约为原<code>cap</code>的<code>1.5</code>倍。</p><p>扩容后如果发现大于了定义的静态成员变量<code>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</code>时，则进行容量最大化处理：调用<code>hugeCapacity</code>方法。</p><p><code>hugeCapacity</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError</span><br><span class="line">            (<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到返回的最大容量为<code>Integer.MAX_VALUE</code>。</p><p>接下来调用<code>r = Arrays.copyOf(r, newCap);</code>，将数组<code>r</code>中的元素拷贝至一个新的容量为<code>newCap</code>的数组中并赋值给<code>r</code>。</p><p>再接下来调用<code>r[i++] = (T)it.next();</code>将集合中的剩余元素（并发修改产生的，索引大于<code>i</code>）填充至新容量的<code>r</code>数组中。</p><p>然后进行下一次的迭代，如果<code>newCap</code>容量的数组仍不能完全填充集合中的剩余元素，则<code>i == cap</code>条件会再次成立，会再次进行扩容，直至完全填充。</p><p>填充完成后，<code>r</code>数组并不是恰好被填满，因为扩容是直接扩容<code>1.5</code>倍，很可能数组末尾没有任何元素，所以在<code>return</code>时利用三目运算符判断<code>i == r.length</code>是否成立，如果成立则表示恰好填满，直接返回<code>r</code>数组；否则调用<code>Arrays.copyOf(r, i)</code>将<code>r</code>数组拷贝至一个新的容量为<code>i</code>的数组中返回。</p><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><h5 id="添加元素至集合"><a href="#添加元素至集合" class="headerlink" title="添加元素至集合"></a>添加元素至集合</h5><p>此抽象类直接抛出<code>UnsupportedOperationException</code>异常。由具体子类去重写<code>add</code>方法来实现向集合中添加元素。</p><blockquote><p>添加元素已经属于集合的个性化操作了，不同的集合保存元素的方式不同，添加的方式也不同，在抽象类中不应有任何具体实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从集合中删除指定元素"><a href="#从集合中删除指定元素" class="headerlink" title="从集合中删除指定元素"></a>从集合中删除指定元素</h5><p>此抽象类中没有任何存储集合元素的介质，唯一能接触到集合元素的是迭代器。</p><blockquote><p>这里就体现出迭代器设计模式的好处了：不用去关心子类采用何种算法去实现迭代，只需要知道<code>hasNext</code>方法可判断集合中是否还有元素；<code>next</code>方法可获取到本次迭代的元素即可。</p></blockquote><p>所以删除指定元素利用的是迭代器的删除方法。我们来看下具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为指定元素为<code>null</code>和非<code>null</code>两种情况：<code>null</code>使用<code>==</code>运算符比较；非<code>null</code>使用<code>equals</code>方法比较。最终都会调用迭代器的<code>remove</code>方法删除指定元素。</p><p>所以实现类如果不重写该<code>remove(Object o)</code>方法，则必须在<code>iterator()</code>方法返回的迭代器中实现迭代器的<code>remove</code>方法。否则将抛出<code>UnsupportedOperationException</code>异常。</p><h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><h5 id="判断是否包含指定集合中的全部元素"><a href="#判断是否包含指定集合中的全部元素" class="headerlink" title="判断是否包含指定集合中的全部元素"></a>判断是否包含指定集合中的全部元素</h5><p>使用迭代器遍历指定集合中的所有元素，遍历过程中调用本抽象类中的<code>contains</code>方法判断是否包含，只要出现一个不包含的情况，返回<code>false</code>，全部包含返回<code>true</code>。</p><blockquote><p>语法糖：JDK5引入的forEach循环实际调用的是迭代器，这是一个语法糖。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加指定集合至当前集合"><a href="#添加指定集合至当前集合" class="headerlink" title="添加指定集合至当前集合"></a>添加指定集合至当前集合</h5><p>使用迭代器迭代指定的集合，并将迭代器返回的每个对象添加至当前集合中。</p><p>由于当前集合的<code>add</code>方法中直接抛出<code>UnsupportedOperationException</code>异常，所以该方法依赖于具体子类的<code>add</code>方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除指定集合中的全部元素"><a href="#删除指定集合中的全部元素" class="headerlink" title="删除指定集合中的全部元素"></a>删除指定集合中的全部元素</h5><p>使用迭代器遍历当前集合，如果迭代器返回的元素包含在指定集合中，则调用迭代器的<code>remove</code>方法将其从当前集合中删除。</p><p>所以，子类实现的<code>iterator</code>方法返回的迭代器必须包含<code>remove</code>方法实现。否则调用该方法将抛出<code>UnsupportedOperationException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从当前集合中删除指定集合之外的全部元素"><a href="#从当前集合中删除指定集合之外的全部元素" class="headerlink" title="从当前集合中删除指定集合之外的全部元素"></a>从当前集合中删除指定集合之外的全部元素</h5><p>使用迭代器遍历当前集合，如果迭代器返回的元素不包含在指定集合中，则调用迭代器的<code>remove</code>方法将其重当前集合中删除。</p><p>所以，子类实现的<code>iterator</code>方法返回的迭代器必须包含<code>remove</code>方法实现。否则调用该方法将抛出<code>UnsupportedOperationException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h5><p>在此抽象类中，是使用迭代器遍历当前集合，调用迭代器的<code>remove</code>方法依次删除每个元素。</p><p>但大多数具体实现类会选择重写该方法以提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h4><p>此方法是重写<code>Object#toString</code>方法，避免在控制台打印集合时打印出集合对象的地址值。其格式为：最外层用方括号<code>[]</code>括起来，方括号中间填充由迭代器返回的元素，顺序为迭代器返回的顺序。相邻元素中间以英文逗号<code>,</code>分隔。每一个元素通过<code>String.valueOf(Object)</code>方法转换成字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法是大多数集合的<code>toString</code>方法，具体实现类（例如<code>ArrayList</code>）中并未重写该方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该抽象类虽然提供了很多方法的实现，但所有的实现都是基于<code>iterator</code>和<code>size</code>这两个方法。从模板方法设计模式的角度看，该类定义了集合操作的算法骨架，具体实现还是得由子类去进行实现。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之Collection</title>
      <link href="2020/05/05/javase/base/collection/"/>
      <url>2020/05/05/javase/base/collection/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Collection</code>接口是<code>Java</code>容器类库中的顶层接口之一。它概括了序列的概念：一种存放一组对象的方式。</p><p><code>JDK</code>不提供<code>Collection</code>接口的直接实现，而是提供更特殊的子接口的实现，比如<code>Set</code>和<code>List</code>。该接口通常用于传递集合并在需要最大通用性的地方操纵它们。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>所有通用的<code>Collection</code>接口实现类（通常通过其子接口之一来间接实现）应该提供两个标准构造器：</p><ul><li><code>void</code>无参构造器：创建一个空集合。</li><li>带有<code>Collection</code>类型的单个参数的构造器：创建一个新集合，该集合具有与参数相同的元素。</li></ul><p>事实上，后一个构造器允许我们复制任何集合，从而产生所需实现类型的等效集合。</p><p>由于接口无法包含构造器，所以无法强制执行此规范，但是<code>Java</code>平台库中的所有通用<code>Collection</code>实现都遵循了该规范。</p><p>此接口中包含一些“破坏性”方法：修改集合的操作。如果实现类不支持，将抛出<code>UnsupportedOperationException</code>异常。在这种情况下，如果调用对集合没有影响，则可以但不强制要求这些方法抛出<code>UnsupportedOperationException</code>异常。例如，对不可修改的集合调用<code>addAll(Collection c)</code>方法时，如果待添加的集合<code>c</code>为空，则可以但不是必须抛出异常。</p><p>有些集合实现对它们可能包含的元素有限制。例如，有些实现禁止<code>null</code>元素，而有些实现对其元素类型有限制。尝试添加不合法元素会引发未经检查的异常，通常为<code>NullPointerException</code>或<code>ClassCastException</code>。尝试查询不合法元素的存在可能会引发异常，或者可能仅返回<code>false</code>。一些实现类将表现出前者的行为，而某些实现类则表现出后者的行为。更一般的，尝试对不合法元素进行操作，该操作的完成不会导致不合法元素插入集合中，这可能会抛出异常，或者可能会成功，一切都取决于实现类。对于<code>Collection</code>接口的规范来说，这些异常是可选的，并未显式抛出。</p><p>该接口中的许多方法都是根据<code>Object#equals(Object o)</code>方法的术语定义的。例如以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><p>此接口的定义为：当且仅当此集合中至少包含一个元素<code>e</code>，使得<code>o == null ? e == null : o.equals(e)</code>成立。</p><p>不应理解为对集合中所有元素都调用<code>equals</code>方法，找到一个满足条件的就可以返回。实现类可以自由进行优化，从而避免<code>equals</code>频繁调用。例如，可以先比较两个元素的哈希码（<code>Object#hashCode()</code>方法的规范保证了具有不相等哈希码的两个对象一定不相等。）</p><p>简单的说，各种<code>Collection</code>接口实现类都可以自由利用基础方法（<code>Object</code>类的方法），只要实现类认为合适即可。</p><h2 id="接口签名"><a href="#接口签名" class="headerlink" title="接口签名"></a>接口签名</h2><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><ul><li><code>int size()</code>：返回集合中的元素个数，最多为<code>Integer.MAX_VALUE</code>。</li><li><code>boolean isEmpty()</code>：如果集合中不包含任何元素则返回<code>true</code>。</li><li><code>boolean contains(Object o)</code>：当且仅当此集合中至少包含一个元素<code>e</code>使得<code>o == null ? e == null : o.equals(e)</code>成立时返回<code>true</code>。</li><li><code>Iterator&lt;E&gt; iterator()</code>：返回此集合中元素的迭代器。</li><li><code>Object[] toArray()</code>：返回包含此集合中所有元素的数组。如果此集合对由其迭代器返回元素的顺序进行了任何保证，则此方法必须按相同的顺序返回元素。操作返回的数组不会对原集合产生任何影响（安全）。此方法充当基于数组的<code>API</code>和基于集合的<code>API</code>之间的桥梁。</li></ul><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><ul><li><code>boolean add(E e)</code>：插入元素<code>e</code>至集合中，如果此集合由于调用该方法发生更改，则返回<code>true</code>；如果集合不允许重复元素，且已经包含<code>e</code>，则返回<code>false</code>。</li><li><code>boolean remove(Object o)</code>：从集合中删除元素<code>o</code>。需满足条件：<code>o == null ? e == null : o.equals(e)</code>。如果存在多个满足条件的元素，则只会删除先找到的那个。</li></ul><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><ul><li><code>boolean containsAll(Collection&lt;?&gt; c)</code>：如果集合中包含指定集合<code>c</code>中的所有元素，则返回<code>true</code>。</li><li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合<code>c</code>中的所有元素添加至当前集合中。如果在操作过程中修改了指定的集合<code>c</code>，则此操作的行为是不确定的。</li><li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：删除所有包含在指定集合<code>c</code>中的元素。此调用返回后，当前集合中将不包含与指定集合相同的元素。</li><li><code>boolean retainAll(Collection&lt;?&gt; c)</code>：仅保留此集合中包含在指定集合<code>c</code>中的元素。换句话说，此操作完成后，当前集合与指定集合中的元素完全相同。</li><li><code>void clear()</code>：删除此集合中的全部元素。</li></ul><h3 id="比较和哈希"><a href="#比较和哈希" class="headerlink" title="比较和哈希"></a>比较和哈希</h3><p>该接口重新声明了<code>Object#equals</code>和<code>Object#hashCode</code>方法，强制子类必须实现这两个方法。</p><p><code>Collection</code>接口要求<code>hashCode</code>方法返回该集合的哈希码；<code>equals</code>方法比较指定的对象与该集合是否相等。</p><h3 id="JDK8新增默认方法"><a href="#JDK8新增默认方法" class="headerlink" title="JDK8新增默认方法"></a><code>JDK8</code>新增默认方法</h3><p><code>JDK8</code>的<code>StreamAPI</code>提供的两个方法。在此顶层接口中定义默认实现，表示所有的集合都可以使用流操作。</p><h4 id="获取串行流"><a href="#获取串行流" class="headerlink" title="获取串行流"></a>获取串行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取并行流"><a href="#获取并行流" class="headerlink" title="获取并行流"></a>获取并行流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之List</title>
      <link href="2020/05/05/javase/base/list/"/>
      <url>2020/05/05/javase/base/list/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>List</code>接口继承了<code>Collection</code>接口，更精确的定义了一种集合类型。</p><p>该接口定义的是一种有序集合，也称为序列。接口的使用者可以精确控制序列中每个元素的插入位置。可以通过其整数索引（序列中的位置）访问元素，并在序列中搜索元素。</p><p>与<code>Set</code>集合不同，序列通常允许重复的元素（<code>equals</code>比较相等）。并且允许多个<code>null</code>元素。</p><h2 id="主要接口签名"><a href="#主要接口签名" class="headerlink" title="主要接口签名"></a>主要接口签名</h2><p>对于<code>Iterator</code>、<code>add</code>、<code>remove</code>、<code>equals</code>和<code>hashCode</code>方法，序列在<code>Collection</code>接口的定义之外，又增加了一些其它定义。同时为了方便起见，序列中还包含了对继承方法的重新声明。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a><code>hashCode()</code></h3><p><code>Collection</code>接口中的<code>hashCode</code>方法只是定义了返回值是该集合的哈希码（调用的是<code>Object</code>类的<code>hashCode</code>方法）。而<code>List</code>接口明确规定了集合<code>hashCode</code>的计算方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (E e : list)</span><br><span class="line">    hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br></pre></td></tr></table></figure><p>计算每一个元素的<code>hashCode</code>并相加。</p><p>这确保了对于任意两个集合<code>list1</code>和<code>list2</code>，如果满足<code>list1.hashCode() == list2.hashCode()</code>，则<code>list1.equals(list2)</code>一定相等。这符合<code>Object#hashCode</code>的规定。</p><h3 id="equals-Object-o"><a href="#equals-Object-o" class="headerlink" title="equals(Object o)"></a><code>equals(Object o)</code></h3><p><code>Collection</code>接口中的<code>equals</code>方法的定义是指定对象与当前集合是否相等，如果实现类希望不使用默认的<code>Object#equals</code>方法的<code>==</code>比较，那么需要重写该方法。</p><p><code>List</code>接口中重写的<code>equals</code>方法规定了判断指定对象与集合是否相等的逻辑：当且仅当指定的对象也是一个<code>List</code>序列，具有相同的大小，并且两个序列中所有对应位置的元素都相等（相等的条件为：<code>e1 == null ? e2 == null : e1.equals(e2)</code>）。</p><p>换句话说，如果两个序列中相同索引位置的元素都相等，那么这两个序列被定义为相等。</p><p>这个定义确保了<code>equals</code>方法可以在<code>List</code>接口的不同实现类中正常运行。</p><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a><code>add(E e)</code></h3><p><code>Collection</code>接口中的<code>add</code>方法定义了可以向集合中添加元素。而<code>List</code>接口中定义的<code>add</code>方法规定了元素添加的位置：添加到原集合末尾。</p><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a><code>add(int index, E element)</code></h3><p><code>List</code>接口中新增的接口签名，在指定索引位置插入指定元素。如果指定索引位置有元素，该元素及其之后的所有元素整体向后移动一位。</p><h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a><code>addAll(Collection&lt;? extends E&gt; c)</code></h3><p>同样地，<code>Collection</code>接口中的<code>add</code>方法只是定义了可以向当前集合中插入另一个集合。而<code>List</code>接口明确规定了插入的位置为原集合末尾。</p><h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></h3><p><code>List</code>接口中新增的接口签名，在指定索引位置插入指定集合。如果指定索引位置有元素，该元素及其之后的所有元素整体向后移动指定集合大小位。</p><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a><code>remove(int index)</code></h3><p><code>List</code>接口中新增的接口签名，删除序列中指定索引位置的元素。如果指定索引位置后还有其它元素，则之后的所有元素整体向前移动一位，最后返回被移除的那个元素。</p><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a><code>Iterator</code></h3><p><code>List</code>接口提供了一个称为<code>ListIterator</code>的特殊迭代器，除了允许<code>Iterator</code>接口提供的常规操作外，它还允许元素的插入和替换以及双向访问。提供了一种方式来获取从序列的指定位置开始的序列迭代器。</p><p>定义了以下两个方法获取序列迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>其中重载的带一个参数的<code>listIterator(int index)</code>方法从指定索引位置开始返回序列迭代器，它表示在首次调用<code>ListIterator#next</code>方法时将返回指定索引位置的元素。首次调用<code>ListIterator#previous</code>方法时将返回指定索引减一位置的元素。</p><h2 id="其它特性"><a href="#其它特性" class="headerlink" title="其它特性"></a>其它特性</h2><p><code>List</code>接口定义了四个方法用于对序列元素进行位置（索引）访问。索引从<code>0</code>开始。在某些实现类中，例如<code>LinkedList</code>，这些方法的实现可能在时间上与索引的值成比例增长。因此，如果在编码过程中不知道<code>List</code>的实现类（例如使用反射等）具体是哪个类，则遍历序列可能比通过索引进行索引更加高效。</p><ul><li><code>void add(int index, E element);</code>：在指定索引位置添加指定元素。</li><li><code>E get(int index);</code>：获取指定索引位置的元素。</li><li><code>E remove(int index);</code>：移除指定索引位置的元素。</li><li><code>E set(int index, E element);</code>：给指定索引位置的元素赋值。</li></ul><p>另外，<code>List</code>接口还定义了两个用来搜索指定对象的方法，从性能来看，应谨慎使用这些方法。在许多实现类中，它们的执行效率非常低下。</p><ul><li><code>int indexOf(Object o);</code>：返回指定元素第一次出现在该序列中的索引位置。如果不存在则返回<code>-1</code>。</li><li><code>int lastIndexOf(Object o);</code>：返回指定元素最后一次出现在该序列中的索引位置。如果不存在则返回<code>-1</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>List</code>接口是对<code>Collection</code>接口的进一步定义，明确了一种集合的类型：序列。</p><p>接口中的方法一部分是对父接口方法的重新声明，另一部分是为了对序列这种集合建模而增加的接口。</p><p>我们学习该接口是为了“从上往下”地对集合框架的特性进行认知。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之Cloneable</title>
      <link href="2020/04/26/javase/base/cloneable/"/>
      <url>2020/04/26/javase/base/cloneable/</url>
      
        <content type="html"><![CDATA[<h2 id="Cloneable接口简介"><a href="#Cloneable接口简介" class="headerlink" title="Cloneable接口简介"></a><code>Cloneable</code>接口简介</h2><p>1、一个类实现<code>java.lang.Cloneable</code>标记性接口以向<code>java.lang.Object#clone()</code>方法指示该方法为该类的实例进行逐域复制是合法的。</p><p>2、在未实现<code>java.lang.Cloneable</code>接口的实例上调用<code>java.lang.Object#clone()</code>方法会导致抛出<code>java.lang.CloneNotSupportedException</code>异常。</p><p>3、按照约定，实现了<code>java.lang.Cloneable</code>接口的类应使用<code>public</code>公共方法重写<code>java.lang.Object#clone()</code>方法（<code>protected</code>受保护的）。</p><h2 id="克隆的基本使用"><a href="#克隆的基本使用" class="headerlink" title="克隆的基本使用"></a>克隆的基本使用</h2><p>由于<code>java.util.ArrayList</code>类实现了<code>Cloneable</code>接口，我们可以将一个<code>ArrayList</code>集合的数据克隆至另一个新的集合中。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个ArrayList集合的数据克隆至另一个新的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListClone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;Java大法好&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP是世界上最好的语言&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;向日葵的自我修养&quot;</span>);</span><br><span class="line">        Object clone = list.clone();</span><br><span class="line">        System.out.println(clone == list);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li>创建一个<code>ArrayList</code>集合对象；</li><li>往其中添加三个元素；</li><li>调用集合对象的<code>clone()</code>方法；</li><li>判断克隆后的集合地址与原集合地址是否相等；</li><li>分别打印两个集合的内容。</li></ol><p>运行程序，可以看到，克隆后的<code>ArrayList</code>集合与旧集合的地址不一样，但其内容相同。</p><h2 id="ArrayList-clone-方法源码分析"><a href="#ArrayList-clone-方法源码分析" class="headerlink" title="ArrayList#clone()方法源码分析"></a><code>ArrayList#clone()</code>方法源码分析</h2><p>调用了<code>list</code>对象的<code>clone()</code>方法，我们来看下其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其调用的是<code>super.clone()</code>方法得到的一个新的集合。</p><p>那么该<code>super</code>指代的是哪个父类呢？</p><ul><li><code>java.util.ArrayList</code>的直接父类是<code>java.util.AbstractList</code>；</li><li><code>java.util.AbstractList</code>的直接父类是<code>java.util.AbstractCollection</code>；</li><li><code>java.util.AbstractCollection</code>是一个抽象类，实现了<code>java.util.Collection</code>接口，没有继承任何父类。</li></ul><p>但是我们却没有在<code>java.util.AbstractList</code>和<code>java.util.AbstractCollection</code>类中找到<code>clone()</code>方法。</p><p>事实上可以直接借助<code>IDEA</code>的快捷键得到其是<code>Object</code>类的<code>clone()</code>方法。</p><p>只有<code>java.util.ArrayList</code>类中有<code>clone()</code>方法，这也是为什么在基本使用的代码中创建的集合，使用<code>java.util.ArrayList</code>接收而不用顶层接口<code>java.util.List</code>接收的原因。</p><p>我们来看下<code>Object#clone()</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>这是一个本地<code>navive</code>方法，使用了<code>protected</code>访问修饰符，并显式抛出了<code>java.lang.CloneNotSupportedException</code>异常。其实现是由底层的<code>c/c++</code>语言进行实现的，我们无法从<code>Java</code>语言层面看到。</p><p>克隆出一个<code>ArrayList</code>对象<code>v</code>之后，调用工具类<code>java.util.Arrays</code>的<code>copyOf</code>方法，将原集合的数据<code>elementData</code>和集合大小<code>size</code>传入，拷贝集合元素至克隆集合<code>v</code>的<code>elementData</code>域中。</p><p>我们来看下<code>java.util.Arrays#copyOf()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyOf</code>方法内部调用的是另一个重载的<code>copyOf</code>方法，判断传入的集合数据<code>elementData</code>类型是不是<code>Object[]</code>数组类型，如果是<code>Object</code>类型则使用<code>new</code>关键字创建一个新的<code>Object[]</code>数组，否则创建其它类型的数组，最后调用<code>System.arraycopy</code>方法将传入的数组元素拷贝至新建的数组中返回。</p><p>返回了新的数组之后，将克隆出来的集合<code>v</code>的<code>elementData</code>域引用指向新的数组地址，然后设置修改次数<code>modCount</code>字段为<code>0</code>，得到一个全新的克隆集合返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Java</code>中所有类都是从<code>java.lang.Object</code>类继承而来的，而<code>Object</code>类提供<code>protected Object clone()</code>方法对对象进行克隆，子类必须实现标记型接口<code>java.lang.Cloneable</code>才支持克隆，当然子类也可以重写<code>Object#clone()</code>方法来实现自己的克隆方式。</p><p>对象的克隆有一个基本问题：对象可能包含对其它对象的引用，当使用<code>Object#clone()</code>方法来克隆对象时，此对象对其它对象的引用也被克隆了一份（注意：这里克隆的是引用）。</p><p><code>java.lang.Cloneable</code>接口只起一个作用，就是在运行期指示虚拟机在当前类使用<code>Object#clone()</code>方法是合法的。通过克隆可以得到一个对象的复制。但由于<code>Object</code>类并未实现<code>java.lang.Cloneable</code>接口，所以被克隆的类如果未实现<code>java.lang.Cloneable</code>接口，在调用<code>java.lang.Object#clone()</code>方法时会抛出<code>java.lang.CloneNotSupportedException</code>异常。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解深浅拷贝</title>
      <link href="2020/04/26/javase/base/depth-shallow-copy/"/>
      <url>2020/04/26/javase/base/depth-shallow-copy/</url>
      
        <content type="html"><![CDATA[<p>无论是<code>java.lang.Object#clone()</code>方法还是自己实现的克隆方法，都存在着浅拷贝和深拷贝的问题。</p><p>那么什么是浅拷贝和深拷贝呢？</p><p>举一个不太恰当的例子：大家都玩过英雄联盟这款游戏吧？英雄联盟中的孙悟空这个英雄的<code>W</code>技能是“真假猴王”：孙悟空进入隐形状态片刻，并留下一个替身，替身在片刻后会对其周围的敌人造成魔法伤害。如果玩家攻击替身，替身掉血但本身不掉血。这似乎可以理解成深拷贝。</p><h2 id="浅拷贝和深拷贝简介"><a href="#浅拷贝和深拷贝简介" class="headerlink" title="浅拷贝和深拷贝简介"></a>浅拷贝和深拷贝简介</h2><ul><li>浅拷贝：只拷贝被克隆对象中按值传递的属性数据，不拷贝引用类型的属性数据。换言之，所有对其它对象的引用仍指向原来的对象，拷贝的是栈内的引用而不是堆内的对象。</li><li>深拷贝：除了浅拷贝需要克隆的值传递的属性数据之外，还会拷贝引用类型所指向的对象，即拷贝的引用会指向新的对象。换言之，深拷贝把待克隆的对象所引用的对象全都拷贝了一遍。</li></ul><p>深拷贝要深入到多少层，这是一个需要根据实际情况来决定的问题。当拷贝至无引用对象的时候，就可称之为完全深拷贝。此外，深拷贝中还可能会出现循环引用的问题，需要仔细处理。</p><h2 id="java-lang-Object-clone-浅拷贝"><a href="#java-lang-Object-clone-浅拷贝" class="headerlink" title="java.lang.Object#clone()浅拷贝"></a><code>java.lang.Object#clone()</code>浅拷贝</h2><p>为了证实该方法是浅拷贝，我们先来尝试设计一下英雄，首先创建一个<code>LOL</code>英雄接口，它包含两个方法：攻击和被攻击，攻击时法力值减少，被攻击时生命值减少。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LOL英雄接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LolHero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 攻击</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lolSkill 使用的技能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(LolSkill lolSkill)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 受到其它英雄攻击</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beAttacked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义技能类，技能包括按键<code>key</code>、技能名称和技能描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LOL英雄的技能类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LolSkill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LolSkill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LolSkill</span><span class="params">(String key, String name, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;LolSkill&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;key=&#x27;&quot;</span>).append(key).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;, desc=&#x27;&quot;</span>).append(desc).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来定义生命值和法力值类。</p><p>生命值类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄生命值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeValue</span><span class="params">(Integer lifeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifeValue = lifeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLifeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lifeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifeValue <span class="title">setLifeValue</span><span class="params">(Integer lifeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifeValue = lifeValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;LifeValue&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;lifeValue=&quot;</span>).append(lifeValue);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法力值类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄法力值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mana</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer mana;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mana</span><span class="params">(Integer mana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mana = mana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mana <span class="title">setMana</span><span class="params">(Integer mana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mana = mana;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Mana&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;mana=&quot;</span>).append(mana);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来创建孙悟空英雄类，它实现了自定义的<code>LOL</code>英雄接口和<code>java.lang.Cloneable</code>接口，包含英雄名称、生命值、法力值和四个技能等属性，重写了<code>java.lang.Cloneable#clone()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄：孙悟空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SunWuKong</span> <span class="keyword">implements</span> <span class="title">LolHero</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;齐天大圣-孙悟空&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LifeValue sunWuKongLifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 法力值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Mana sunWuKongMana;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skill */</span></span><br><span class="line">    <span class="keyword">private</span> LolSkill Q = <span class="keyword">new</span> LolSkill(<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;粉碎打击&quot;</span>,<span class="string">&quot;孙悟空的下次攻击造成额外物理伤害，获得距离加成，并暂时减少敌人的护甲。&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> LolSkill W = <span class="keyword">new</span> LolSkill(<span class="string">&quot;W&quot;</span>,<span class="string">&quot;真假猴王&quot;</span>,<span class="string">&quot;孙悟空进入隐形状态片刻，并留下一个替身，替身在片刻后会对其周围的敌人造成魔法伤害。&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> LolSkill E = <span class="keyword">new</span> LolSkill(<span class="string">&quot;E&quot;</span>,<span class="string">&quot;腾云突击&quot;</span>,<span class="string">&quot;孙悟空突进至目标敌人处，并变出最多2个分身，攻击附近目标。对每个击中的目标造成物理伤害。&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> LolSkill R = <span class="keyword">new</span> LolSkill(<span class="string">&quot;R&quot;</span>,<span class="string">&quot;大闹天宫&quot;</span>,<span class="string">&quot;孙悟空展开金箍棒，不停地旋转，对敌人造成伤害并将其击飞。在此期间，孙悟空速度持续增加。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(LolSkill lolSkill)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用了&quot;</span> + lolSkill + <span class="string">&quot;进行了攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beAttacked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer oldSunWuKongLifeValue = <span class="keyword">this</span>.sunWuKongLifeValue.getLifeValue() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.sunWuKongLifeValue.setLifeValue(oldSunWuKongLifeValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LifeValue <span class="title">getSunWuKongLifeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sunWuKongLifeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SunWuKong <span class="title">setSunWuKongLifeValue</span><span class="params">(LifeValue sunWuKongLifeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sunWuKongLifeValue = sunWuKongLifeValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mana <span class="title">getSunWuKongMana</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sunWuKongMana;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SunWuKong <span class="title">setSunWuKongMana</span><span class="params">(Mana sunWuKongMana)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sunWuKongMana = sunWuKongMana;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;SunWuKong&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;, sunWuKongLifeValue=&quot;</span>).append(sunWuKongLifeValue);</span><br><span class="line">        sb.append(<span class="string">&quot;, sunWuKongMana=&quot;</span>).append(sunWuKongMana);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切准备就绪，我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深浅拷贝测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthCopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个孙悟空英雄对象，并赋予生命值1000，法力值2000</span></span><br><span class="line">        SunWuKong sunWuKong = <span class="keyword">new</span> SunWuKong();</span><br><span class="line">        sunWuKong.setSunWuKongLifeValue(<span class="keyword">new</span> LifeValue(<span class="number">1000</span>))</span><br><span class="line">                .setSunWuKongMana(<span class="keyword">new</span> Mana(<span class="number">2000</span>));</span><br><span class="line">        <span class="comment">// 克隆一个替身</span></span><br><span class="line">        SunWuKong clone = (SunWuKong) sunWuKong.clone();</span><br><span class="line">        System.out.println(sunWuKong);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(sunWuKong == clone);</span><br><span class="line">        <span class="comment">// 替身受到攻击</span></span><br><span class="line">        clone.beAttacked();</span><br><span class="line">        System.out.println(sunWuKong);</span><br><span class="line">        System.out.println(clone);</span><br><span class="line">        System.out.println(sunWuKong == clone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;999&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;999&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>孙悟空“替身”受到攻击后，“真身”的生命值也减少了。可以看出真身和替身引用的是同一个生命值对象。足以证实<code>java.lang.Cloneable#clone()</code>方法是浅拷贝。</p><h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h2><p>深拷贝则不能简单的在重写的<code>clone</code>方法内直接调用<code>super.clone()</code>，需要将当前类的每一个引用对象都进行拷贝，如果引用对象还包含引用对象，则需进行多层拷贝。</p><p>当前类的每一个引用对象均需实现<code>java.lang.Cloneable</code>接口并重写其<code>clone</code>方法。</p><p>我们来看下<code>SunWuKong</code>类的引用对象：<code>LifeValue</code>和<code>Mana</code>。</p><p><code>LifeValue</code>代码实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄生命值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeValue</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mana</code>代码实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄法力值类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mana</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer mana;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>SunWuKong</code>类的<code>clone</code>方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.cloneable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 英雄：孙悟空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SunWuKong</span> <span class="keyword">implements</span> <span class="title">LolHero</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;齐天大圣-孙悟空&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LifeValue sunWuKongLifeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 法力值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Mana sunWuKongMana;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        SunWuKong clone = (SunWuKong) <span class="keyword">super</span>.clone();</span><br><span class="line">        LifeValue lifeValueClone = (LifeValue) <span class="keyword">this</span>.sunWuKongLifeValue.clone();</span><br><span class="line">        Mana manaClone = (Mana) <span class="keyword">this</span>.sunWuKongMana.clone();</span><br><span class="line">        clone.setSunWuKongLifeValue(lifeValueClone);</span><br><span class="line">        clone.setSunWuKongMana(manaClone);</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;1000&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">SunWuKong&#123;name&#x3D;&#39;齐天大圣-孙悟空&#39;, sunWuKongLifeValue&#x3D;LifeValue&#123;lifeValue&#x3D;999&#125;, sunWuKongMana&#x3D;Mana&#123;mana&#x3D;2000&#125;&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>替身对象受到攻击后，原对象生命值不变，替身对象生命值减少。这就是深拷贝的实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深拷贝要求被拷贝的类的每一个引用对象都实现<code>java.lang.Cloneable</code>接口并实现<code>clone</code>方法，所以当需要实现深拷贝时，需要进行对象功能的全面考虑，特别是当引用对象还包含引用对象的多层嵌套时，需要结合对象的功能进行考虑。</p><p>本篇文章所有源代码地址：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/java-se/src/main/java/com/sunchaser/javase/base/cloneable">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之RandomAccess</title>
      <link href="2020/04/26/javase/base/randomaccess/"/>
      <url>2020/04/26/javase/base/randomaccess/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>该接口是<code>List</code>实现使用的标记型接口，表明它们支持快速（通常是恒定时间）随机访问。此接口的主要目的是允许通用算法更改其行为，以应用于随机访问列表或顺序访问列表时提供良好的性能。</p><p>当应用于顺序访问列表（例如<code>LinkedList</code>）时，用于操纵随机访问列表（例如<code>ArrayList</code>）的最佳算法会产生二次行为。鼓励使用通用列表算法，先检查给定列表是否为该接口的实例，然后再应用一种算法（如果将其应用于顺序访问列表则性能较差），并在必要时更改其行为以保证可接受的性能。</p><p>公认的是，随机访问和顺序访问之间的区别通常是模糊的。例如，某些<code>List</code>实现在变得庞大的情况下提供渐进线性的访问时间，但实际上却是恒定的访问时间。这样的<code>List</code>实现通常应该实现此接口。根据经验，如果满足以下条件，则<code>List</code>实现应实现此接口：</p><p>对于类的典型实例，此循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure><p>比这个循环运行更快：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure><h2 id="ArrayList效率比较"><a href="#ArrayList效率比较" class="headerlink" title="ArrayList效率比较"></a><code>ArrayList</code>效率比较</h2><p><code>ArrayList</code>实现了<code>RandomAccess</code>接口，根据<code>RandomAccess</code>接口定义，使用<code>fori</code>循环遍历比迭代器遍历更快。下面我们来进行验证。</p><p>创建一个<code>ArrayList</code>集合并填充一千万个元素，分别使用<code>fori</code>循环和迭代器进行遍历，计算其运行时间。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.randomaccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机访问和迭代器访问效率比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomIteratorCompare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// init list data</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// random access</span></span><br><span class="line">        <span class="keyword">long</span> randomStartTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = list.size(); i &lt; size; i++) &#123;</span><br><span class="line">            list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> randomEndTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;random access:&quot;</span> + (randomEndTime - randomStartTime));</span><br><span class="line">        <span class="comment">// sequential access</span></span><br><span class="line">        <span class="keyword">long</span> sequentialStartTime = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sequentialEndTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sequential access:&quot;</span> + (sequentialEndTime - sequentialStartTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random access:6</span><br><span class="line">sequential access:11</span><br></pre></td></tr></table></figure><p>结果显而易见，<code>ArrayList</code>使用迭代器遍历效率略低于<code>fori</code>遍历。</p><h2 id="LinkedList效率比较"><a href="#LinkedList效率比较" class="headerlink" title="LinkedList效率比较"></a><code>LinkedList</code>效率比较</h2><p>当应用于<code>LinkedList</code>时，用于操纵<code>ArrayList</code>的最佳算法（<code>fori</code>循环遍历）会产生二次行为。<code>ListedList</code>未实现<code>RandomAccess</code>接口。</p><p>我们来创建一个<code>LinkedList</code>，对其填充元素并分别使用<code>fori</code>循环和迭代器进行遍历。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init LinkedList data</span></span><br><span class="line">List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    linkedList.add(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// random access</span></span><br><span class="line"><span class="keyword">long</span> linkedListRandomStartTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,size = linkedList.size(); i &lt; size; i++) &#123;</span><br><span class="line">    linkedList.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> linkedListRandomEndTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;random access:&quot;</span> + (linkedListRandomEndTime - linkedListRandomStartTime));</span><br><span class="line"><span class="comment">// sequential access</span></span><br><span class="line"><span class="keyword">long</span> linkedListSequentialStartTime = System.currentTimeMillis();</span><br><span class="line">Iterator&lt;String&gt; linkedListIterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (linkedListIterator.hasNext()) &#123;</span><br><span class="line">    linkedListIterator.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> linkedListSequentialEndTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;sequential access:&quot;</span> + (linkedListSequentialEndTime - linkedListSequentialStartTime));</span><br></pre></td></tr></table></figure><p>运行后控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random access:11031</span><br><span class="line">sequential access:10</span><br></pre></td></tr></table></figure><p>可以看到，<code>fori</code>循环遍历所耗费的时间已经远远超过了迭代器遍历，这说明适用于<code>ArrayList</code>的最佳算法不再适用于<code>LinkedList</code>，这与集合的内部数据结构和<code>get</code>方法实现有关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现了<code>RandomAccess</code>接口的<code>ArrayList</code>使用<code>fori</code>循环遍历效率更高，而<code>LinkedList</code>使用迭代器遍历效率极高。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码解析之Serializable</title>
      <link href="2020/03/21/javase/base/serializable/"/>
      <url>2020/03/21/javase/base/serializable/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是序列化和反序列化？</p><ul><li>序列化：将对象的二进制数据流写入硬盘（或用于网络传输）；</li><li>反序列化：从硬盘（网络）中将对象的二进制数据流读取出来转化成对象。</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>实现了<code>java.io.serializable</code>标记性接口的类是可序列化的，可序列化类的所有子类型都是可序列化的。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Java</code>中序列化接口是一个空接口，仅用于标记可序列化的语义。</p><h2 id="序列化UID字段：serialVersionUID"><a href="#序列化UID字段：serialVersionUID" class="headerlink" title="序列化UID字段：serialVersionUID"></a>序列化<code>UID</code>字段：<code>serialVersionUID</code></h2><p>实现了<code>java.io.Serializable</code>接口的类，如果未显式进行声明，在编译期<code>JVM</code>将使用自己的算法生成默认的<code>serialVersionUID</code>字段。</p><blockquote><p>默认的<code>serialVersionUID</code>生成算法对类的详细信息非常敏感，因不同的<code>JVM</code>实现而异，并且在反序列化过程中会可能会导致意外的<code>java.io.InvalidClassException</code>异常。</p></blockquote><p>当进行序列化操作时，会将此<code>serialVersionUID</code>序列化进二进制流中；</p><p>当进行反序列化操作时，如果用来接收对象的类中的<code>serialVersionUID</code>字段值与序列化时的值不一致，会导致反序列化失败。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>首先创建一个用来序列化测试的类<code>SerializableClass</code>，并实现序列化接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.serizlizable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/3/19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5135631042912401553L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerializableClass <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerializableClass <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;SerializableClass&#123;&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;name=&#x27;&quot;</span>).append(name).append(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;, age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来创建测试类来进行序列化。首先在当前类所在包中创建<code>serializableClass.txt</code>文件。之后我们序列化写对象写入该文件中，反序列化从该文件中读对象。</p><p>使用以下代码即可获取<code>txt</code>文件的绝对路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前类所在包中的serializableClass.txt文件路径</span></span><br><span class="line">String path = SerializableTest.class.getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br><span class="line">path = path.replace(<span class="string">&quot;target/classes&quot;</span>,<span class="string">&quot;src/main/java&quot;</span>) + <span class="string">&quot;serializableClass.txt&quot;</span>;</span><br></pre></td></tr></table></figure><p>接下来创建用来序列化的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SerializableClass sc = <span class="keyword">new</span> SerializableClass().setName(<span class="string">&quot;序列化&quot;</span>).setAge(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>然后我们创建序列化的方法<code>writeObject</code>，将对象和<code>txt</code>文件绝对路径传入进行写对象操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(SerializableClass sc,String path)</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    ObjectOutputStream ops = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">        ops = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        ops.writeObject(sc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ops.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>方法中调用即可将对象写入文本文件中，可打开文本文件查看（有点乱码）。</p><p>下面我们来创建反序列化的方法<code>readObject</code>，将文本文件路径传入进行读对象操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        SerializableClass sc = (SerializableClass) ois.readObject();</span><br><span class="line">        System.out.println(sc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法后可在控制台看到对象打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SerializableClass&#123;name&#x3D;&#39;序列化&#39;, age&#x3D;10&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化失败演示"><a href="#反序列化失败演示" class="headerlink" title="反序列化失败演示"></a>反序列化失败演示</h3><p>先调用<code>writeObject</code>方法将对象序列化写入文本文件，然后去修改<code>SerializableClass</code>的<code>serialVersionUID</code>字段的值，再去调用<code>readObject</code>方法从文本文件中反序列化读对象。这时反序列化就会失败，并抛出<code>java.io.InvalidClassException</code>异常。</p><p>主要异常堆栈信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.sunchaser.javase.base.serizlizable.SerializableClass; </span><br><span class="line"></span><br><span class="line">local class incompatible: stream classdesc serialVersionUID &#x3D; 5135632042912401553, local class serialVersionUID &#x3D; 5135631042912401553</span><br></pre></td></tr></table></figure><h2 id="IDEA中生成serialVersionUID"><a href="#IDEA中生成serialVersionUID" class="headerlink" title="IDEA中生成serialVersionUID"></a><code>IDEA</code>中生成<code>serialVersionUID</code></h2><p>打开<code>IDEA</code>，选择<code>File</code>-&gt;<code>Settings</code>-&gt;<code>Editor</code>-&gt;<code>Inspections</code>，在搜索框中输入<code>serialVersionUID</code>，找到<code>Serializable class without &#39;serialVersionUID&#39;</code>，进行勾选，点击<code>apply</code>-&gt;<code>OK</code>进行保存。</p><p>设置之后如果实现了<code>Serializable</code>接口的类未定义<code>serialVersionUID</code>字段，则类名处会有黄色警告，输入光标移动至类名处按下快捷键<code>alt+enter</code>会有生成<code>serialVersionUID</code>的快捷方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文完整代码地址：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/java-se/src/main/java/com/sunchaser/javase/base/serizlizable">传送门</a></p><p><code>Serializable</code>接口实际上就是一个标记，实现了该接口的类才允许被序列化和反序列化，而<code>serialVersionUID</code>字段则像是一个“版本号”，序列化时将该字段一起存至二进制流中，反序列化时用该字段来判断是否是存进去时的状态。它的作用其实就是判断反序列化出来的对象是不是原来序列化的对象。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼xxl-job之调度中心—初始化失败任务管理中心</title>
      <link href="2020/03/03/middleware/xxl-job/job-fail-monitor/"/>
      <url>2020/03/03/middleware/xxl-job/job-fail-monitor/</url>
      
        <content type="html"><![CDATA[<p>调度中心启动时主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，这篇文章来分析第三个初始化动作：初始化失败任务管理中心。其关键调用代码为：<code>JobFailMonitorHelper.getInstance().start();</code></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>来看<code>com.xxl.job.admin.core.thread.JobFailMonitorHelper</code>类的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>先看类的主要成员变量：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobFailMonitorHelper.memberVariables.png" alt="JobFailMonitorHelper.memberVariables"></p><ol><li>私有<code>slf4j</code>日志对象；</li><li>私有静态<code>JobFailMonitorHelper</code>类实例对象：<code>instance</code>；</li><li>私有成员变量：<code>Thread</code>类对象<code>monitorThread</code>；</li><li>私有布尔变量<code>toStop</code>，初始化为<code>false</code>。</li></ol><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ol><li>实例<code>instance</code>的公有静态访问器<code>getInstance()</code>；</li><li>公有<code>start()</code>方法；</li><li>公有<code>toStop()</code>方法。</li><li>私有<code>failAlarm()</code>方法，用于失败告警。</li></ol><p>其中公有静态访问器<code>getInstance()</code>和私有静态<code>JobFailMonitorHelper</code>类实例对象<code>instance</code>共同形成了饿汉式单例模式。</p><h3 id="start-方法解析"><a href="#start-方法解析" class="headerlink" title="start()方法解析"></a><code>start()</code>方法解析</h3><p>可以发现该类的主要实现是在<code>start()</code>方法中，先折叠一些实现我们来看下整体。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobFailMonitorHelper.start.png" alt="JobFailMonitorHelper.start"></p><ol><li>给私有成员变量<code>Thread</code>类对象<code>monitorThread</code>赋值，即创建一个子线程：实现<code>Runnable</code>接口并重写其<code>run</code>方法；</li><li>将其设置为守护线程；</li><li>设置线程名为：<code>xxl-job, admin JobFailMonitorHelper</code>；</li><li>调用线程的<code>start()</code>方法启动线程。</li></ol><p>这其实是一个守护线程。</p><p>我们继续来看子线程重写的<code>run</code>方法的具体实现：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobFailMonitorHelper.complete.start.png" alt="JobFailMonitorHelper.complete.start"></p><p>看起来实现有点长，我们逐渐将其拆解来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br></pre></td></tr></table></figure><p>循环，判断的条件为私有布尔变量<code>toStop</code>的非，而<code>toStop</code>被初始化为了<code>false</code>，所以这是一个死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>从配置“容器”<code>com.xxl.job.admin.core.conf.XxlJobAdminConfig</code>对象中拿到<code>com.xxl.job.admin.dao.XxlJobLogDao</code>对象，调用<code>findFailJobLogIds(1000)</code>方法。这是<code>Mybatis</code>持久层的方法，来看一下其实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Mapper接口 *&#x2F;</span><br><span class="line">public List&lt;Long&gt; findFailJobLogIds(@Param(&quot;pagesize&quot;) int pagesize);</span><br><span class="line"></span><br><span class="line">&#x2F;* xml实现 *&#x2F;</span><br><span class="line">&lt;select id&#x3D;&quot;findFailJobLogIds&quot; resultType&#x3D;&quot;long&quot; &gt;</span><br><span class="line">SELECT id FROM &#96;xxl_job_log&#96;</span><br><span class="line">WHERE !(</span><br><span class="line">(trigger_code in (0, 200) and handle_code &#x3D; 0)</span><br><span class="line">OR</span><br><span class="line">(handle_code &#x3D; 200)</span><br><span class="line">)</span><br><span class="line">AND &#96;alarm_status&#96; &#x3D; 0</span><br><span class="line">ORDER BY id ASC</span><br><span class="line">LIMIT #&#123;pagesize&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>传入的参数<code>pagesize</code>为<code>1000</code>，<code>SQL</code>的查询条件：非（调度成功 或 执行成功）。</p><p>所以此处实际上就是分页查询<code>1000</code>条失败任务日志记录的<code>failLogIds</code>。</p><p>如果存在失败的日志记录则进行遍历处理，我们往下看处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lockRet = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (lockRet &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">XxlJobLog log = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);</span><br><span class="line">XxlJobInfo info = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());</span><br></pre></td></tr></table></figure><p>调用<code>XxlJobLogDao</code>的<code>updateAlarmStatus</code>方法，来看下其<code>Mybatis</code>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int updateAlarmStatus(@Param(&quot;logId&quot;) long logId,</span><br><span class="line"> @Param(&quot;oldAlarmStatus&quot;) int oldAlarmStatus,</span><br><span class="line"> @Param(&quot;newAlarmStatus&quot;) int newAlarmStatus);</span><br><span class="line"></span><br><span class="line">&lt;update id&#x3D;&quot;updateAlarmStatus&quot; &gt;</span><br><span class="line">    UPDATE xxl_job_log</span><br><span class="line">    SET</span><br><span class="line">        &#96;alarm_status&#96; &#x3D; #&#123;newAlarmStatus&#125;</span><br><span class="line">    WHERE &#96;id&#96;&#x3D; #&#123;logId&#125; AND &#96;alarm_status&#96; &#x3D; #&#123;oldAlarmStatus&#125;</span><br><span class="line">&lt;&#x2F;update&gt;</span><br></pre></td></tr></table></figure><p><code>CAS</code>乐观锁的方式将<code>alarm_status</code>字段从<code>0</code>更新为<code>-1</code>。</p><blockquote><p>思考：这里为什么使用乐观锁？有什么作用？</p><p>猜想：支持调度集群部署，高可用。</p></blockquote><p>如果乐观锁“加锁”成功，则根据失败任务<code>failLogId</code>加载任务日志信息和任务信息。</p><p>得到了任务必要信息后就可以进行处理了，包括重试或告警，我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (log.getExecutorFailRetryCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-<span class="number">1</span>), log.getExecutorShardingParam(), log.getExecutorParam());</span><br><span class="line">String retryMsg = <span class="string">&quot;&lt;br&gt;&lt;br&gt;&lt;span style=\&quot;color:#F39C12;\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>+ I18nUtil.getString(<span class="string">&quot;jobconf_trigger_type_retry&quot;</span>) +<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">log.setTriggerMsg(log.getTriggerMsg() + retryMsg);</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断日志信息中执行器失败重试次数是否仍大于零，是则进行重试。</p><p>重试即重新进行调度，调用<code>JobTriggerPoolHelper</code>类的<code>trigger()</code>方法，传入了五个参数，我们来分别解释一下：</p><ul><li><code>log.getJobId()</code>：任务信息表自增主键。</li><li><code>TriggerTypeEnum.RETRY</code>：执行类型：重试。</li><li><code>(log.getExecutorFailRetryCount()-1)</code>：当前重试次数减一，这里传入是为了执行时存入日志表，当再次失败时可确保重试次数。</li><li><code>log.getExecutorShardingParam()</code>：执行器分片参数（分片任务用到）。</li><li><code>log.getExecutorParam()</code>：执行器执行参数。</li></ul><p>关于任务调度执行本篇文章不做详细介绍，只需知道这里触发了任务执行，并将减一后的重试次数存入了日志，若这次执行仍然失败，则可被重新查出并根据剩余重试次数进行处理。</p><p>重试完成后更新本条记录的调度日志<code>trigger_msg</code>字段。</p><p>然后进行告警处理，无论是否有重试都会进行告警处理。</p><p>我们来看告警的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newAlarmStatus = <span class="number">0</span>;<span class="comment">// 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败</span></span><br><span class="line"><span class="keyword">if</span> (info!=<span class="keyword">null</span> &amp;&amp; info.getAlarmEmail()!=<span class="keyword">null</span> &amp;&amp; info.getAlarmEmail().trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> alarmResult = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        alarmResult = failAlarm(info, log);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        alarmResult = <span class="keyword">false</span>;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    newAlarmStatus = alarmResult?<span class="number">2</span>:<span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newAlarmStatus = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -<span class="number">1</span>, newAlarmStatus);</span><br></pre></td></tr></table></figure><p>只有配置了告警邮箱才进行告警，核心逻辑是调用了私有成员方法<code>failAlarm</code>，根据调用情况得到新的告警状态，最后使用<code>CAS</code>的方式更新日志记录表，将<code>alarm_status</code>字段从<code>-1</code>更新为新的告警状态。</p><p>最后阻塞当前子线程<code>10</code>秒，一次循环就结束了。</p><p>而私有成员方法<code>failAlarm</code>的主要逻辑是发送邮件，调度中心<code>xxl-job-admin</code>项目配置文件中可配置告警发件邮箱，<code>Web</code>管理后台界面添加任务时可填写告警收件人邮箱。该方法有一行代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; emailSet = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(info.getAlarmEmail().split(<span class="string">&quot;,&quot;</span>)));</span><br></pre></td></tr></table></figure><p>从而得知在管理后台界面添加任务时可填写多个告警收件人邮箱，用英文逗号分隔即可，会自动去重。</p><p>我们可在该方法中实现自定义的告警方式，例如钉钉机器人等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用以下一张图来对失败任务管理中心进行归纳总结。<br><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/job-fail-monitor.png" alt="job-fail-monitor"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼xxl-job之调度中心—初始化注册中心“心跳续约”服务</title>
      <link href="2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/"/>
      <url>2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/</url>
      
        <content type="html"><![CDATA[<p>调度中心启动时主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，这篇文章来分析第二个初始化动作：初始化注册中心“心跳续约”服务。其关键调用代码为：<code>JobRegistryMonitorHelper.getInstance().start();</code></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>来看<code>com.xxl.job.admin.core.thread.JobRegistryMonitorHelper</code>类的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>先看类的成员变量：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobRegistryMonitorHelper.memberVariables.png" alt="JobRegistryMonitorHelper.memberVariables"></p><ol><li>私有<code>slf4j</code>日志对象；</li><li>私有静态<code>JobRegistryMonitorHelper</code>类实例对象：<code>instance</code>；</li><li>私有成员变量：<code>Thread</code>类对象<code>registryThread</code>；</li><li>私有布尔变量<code>toStop</code>，初始化为<code>false</code>。</li></ol><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ol><li>实例<code>instance</code>的公有静态访问器<code>getInstance()</code>；</li><li>公有<code>start()</code>方法；</li><li>公有<code>toStop()</code>方法。</li></ol><p>其中公有静态访问器<code>getInstance()</code>和私有静态<code>JobRegistryMonitorHelper</code>类实例对象<code>instance</code>共同形成了饿汉式单例模式。</p><h3 id="start-方法解析"><a href="#start-方法解析" class="headerlink" title="start()方法解析"></a><code>start()</code>方法解析</h3><p>可以发现该类的主要实现是在<code>start()</code>方法中，先折叠一些实现我们来看下整体。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobRegistryMonitorHelper.start.png" alt="JobRegistryMonitorHelper.start"></p><ol><li>给私有成员变量<code>Thread</code>类对象<code>registryThread</code>赋值，即创建一个子线程：实现<code>Runnable</code>接口并重写其<code>run</code>方法；</li><li>将其设置为守护线程；</li><li>设置线程名为：<code>xxl-job, admin JobRegistryMonitorHelper</code>；</li><li>调用线程的<code>start()</code>方法启动线程。</li></ol><p>这其实是一个守护线程。</p><p>我们继续来看子线程重写的<code>run</code>方法的具体实现：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/JobRegistryMonitorHelper.complete.start.png" alt="JobRegistryMonitorHelper.complete.start"></p><p>看起来实现有点长，我们逐渐将其拆解来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!toStop) &#123;</span><br></pre></td></tr></table></figure><p>循环，判断的条件为私有布尔变量<code>toStop</code>的非，而<code>toStop</code>被初始化为了<code>false</code>，所以这是一个死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>从配置“容器”<code>com.xxl.job.admin.core.conf.XxlJobAdminConfig</code>对象中拿到<code>com.xxl.job.admin.dao.XxlJobGroupDao</code>对象，调用<code>findByAddressType(0)</code>方法。这是<code>Mybatis</code>持久层的方法，来看一下其实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Mapper接口 *&#x2F;</span><br><span class="line">public List&lt;XxlJobGroup&gt; findByAddressType(@Param(&quot;addressType&quot;) int addressType);</span><br><span class="line"></span><br><span class="line">&#x2F;* xml实现 *&#x2F;</span><br><span class="line">&lt;select id&#x3D;&quot;findByAddressType&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; resultMap&#x3D;&quot;XxlJobGroup&quot;&gt;</span><br><span class="line">SELECT &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">FROM xxl_job_group AS t</span><br><span class="line">WHERE t.address_type &#x3D; #&#123;addressType&#125;</span><br><span class="line">ORDER BY t.order ASC</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>传入的参数<code>addressType</code>为<code>0</code>，<code>SQL</code>的含义为：查询<code>xxl_job_group</code>表中<code>address_type</code>字段为<code>0</code>的数据并按<code>order</code>字段升序排序。</p><p>我们可以去初始化<code>sql</code>脚本中寻找该字段的含义：<code>执行器地址类型：0=自动注册、1=手动录入</code>。</p><p>所以此处代码的作用是：查询地址类型为自动注册的执行器信息列表。</p><p>如果查询出的执行器列表不为空则继续往下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig()</span><br><span class="line">                                .getXxlJobRegistryDao()</span><br><span class="line">                                .findDead(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">if</span> (ids!=<span class="keyword">null</span> &amp;&amp; ids.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>XxlJobRegistryDao</code>的<code>findDead</code>方法，传入的参数为：</p><ul><li><code>RegistryConfig.DEAD_TIMEOUT</code>：超时时间，值为<code>90</code>；</li><li><code>new Date()</code>：当前时间对象。</li></ul><p>来看一下<code>Mybatis</code>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; findDead(@Param(&quot;timeout&quot;) int timeout,</span><br><span class="line">                              @Param(&quot;nowTime&quot;) Date nowTime);</span><br><span class="line">                                  </span><br><span class="line">&lt;select id&#x3D;&quot;findDead&quot; parameterType&#x3D;&quot;java.util.HashMap&quot; resultType&#x3D;&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">SELECT t.id</span><br><span class="line">FROM xxl_job_registry AS t</span><br><span class="line">WHERE t.update_time &lt;![CDATA[ &lt; ]]&gt; DATE_ADD(#&#123;nowTime&#125;,INTERVAL -#&#123;timeout&#125; SECOND)</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>查询的是主键<code>id</code>列表，关键的是<code>where</code>条件，<code>xxl_job_registry</code>表的<code>update_time</code>字段小于传入的当前时间减去传入的超时时间<code>90</code>秒。</p><p>其含义为：查询出<code>90</code>秒内未更新时间的任务<code>id</code>集合列表。</p><blockquote><p>思考：这里查询时为什么选择传入<code>Java</code>时间而不是直接用<code>MySQL</code>的<code>NOW()</code>函数获取当前时间？</p><p>解答：防止<code>MySQL</code>服务器和调度中心服务器的时钟不同步。</p></blockquote><p>如果查到了记录，则调用<code>XxlJobRegistryDao</code>的<code>removeDead</code>方法。来看下其<code>Mybatis</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeDead(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);</span><br><span class="line">    </span><br><span class="line">&lt;delete id&#x3D;&quot;removeDead&quot; parameterType&#x3D;&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">DELETE FROM xxl_job_registry</span><br><span class="line">WHERE id in</span><br><span class="line">&lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;item&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot; &gt;</span><br><span class="line">#&#123;item&#125;</span><br><span class="line">&lt;&#x2F;foreach&gt;</span><br><span class="line">&lt;&#x2F;delete&gt;</span><br></pre></td></tr></table></figure><p>删除任务<code>id</code>列表对应的<code>xxl_job_registry</code>记录。</p><p>看到这里，我们应该理解到这实际上是“心跳”机制。“心跳”的最长时间间隔为<code>90</code>秒。</p><p>继续往下看，初始化了一个局部<code>HashMap</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig()</span><br><span class="line">                                    .getXxlJobRegistryDao()</span><br><span class="line">                                    .findAll(RegistryConfig.DEAD_TIMEOUT, <span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure><p>随即调用<code>XxlJobRegistryDao</code>的<code>findAll</code>方法查询出了一个<code>List&lt;XxlJobRegistry&gt;</code>集合，我们来看下查询条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;XxlJobRegistry&gt; findAll(@Param(&quot;timeout&quot;) int timeout,</span><br><span class="line">                                    @Param(&quot;nowTime&quot;) Date nowTime);</span><br><span class="line">                                        </span><br><span class="line">&lt;select id&#x3D;&quot;findAll&quot; parameterType&#x3D;&quot;java.util.HashMap&quot; resultMap&#x3D;&quot;XxlJobRegistry&quot;&gt;</span><br><span class="line">SELECT &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">FROM xxl_job_registry AS t</span><br><span class="line">WHERE t.update_time &lt;![CDATA[ &gt; ]]&gt; DATE_ADD(#&#123;nowTime&#125;,INTERVAL -#&#123;timeout&#125; SECOND)</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><p>重点是<code>where</code>条件：更新时间<code>update_time</code>大于当前时间减去“死亡”超时时间<code>90</code>秒。</p><p>即：查询上次“心跳”时间在<code>90</code>秒以内的注册列表。</p><p>实际上这是在做执行器“心跳”续约，类似于微服务中的服务续约。</p><p>我们继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XxlJobRegistry item: list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) &#123;</span><br><span class="line">            String appName = item.getRegistryKey();</span><br><span class="line">            List&lt;String&gt; registryList = appAddressMap.get(appName);</span><br><span class="line">            <span class="keyword">if</span> (registryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                registryList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!registryList.contains(item.getRegistryValue())) &#123;</span><br><span class="line">                registryList.add(item.getRegistryValue());</span><br><span class="line">            &#125;</span><br><span class="line">            appAddressMap.put(appName, registryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查询到有未“死亡”的注册列表，则对其进行“续约”：</p><ul><li>遍历查询出的注册列表。</li><li>如果注册组为执行器（这里注意到枚举<code>RegistType</code>有两个值：<code>EXECUTOR</code>（执行器）和<code>ADMIN</code>（调度中心））。</li><li>取出注册表的注册键（<code>xxl_job_registry</code>表中的<code>registry_key</code>字段）：即执行器名称<code>appName</code>。</li><li>先尝试从局部<code>map</code>变量中取出该执行器名称对应注册地址集合，若没有则新建一个空集合（懒加载思想）。</li><li>判断从<code>map</code>中取出的注册地址集合是否包含当前遍历的注册表的注册值（<code>xxl_job_registry</code>表中的<code>registry_value</code>字段），若不包含则添加至集合（去重）。</li><li>将执行器名称<code>appName</code>和注册地址集合映射至局部<code>map</code>变量。</li></ul><p>映射至局部<code>map</code>变量后，开始执行真正的“续约”动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (XxlJobGroup group: groupList) &#123;</span><br><span class="line">    List&lt;String&gt; registryList = appAddressMap.get(group.getAppName());</span><br><span class="line">    String addressListStr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registryList!=<span class="keyword">null</span> &amp;&amp; !registryList.isEmpty()) &#123;</span><br><span class="line">        Collections.sort(registryList);</span><br><span class="line">        addressListStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String item:registryList) &#123;</span><br><span class="line">            addressListStr += item + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addressListStr = addressListStr.substring(<span class="number">0</span>, addressListStr.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    group.setAddressList(addressListStr);</span><br><span class="line">    XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历从<code>xxl_job_group</code>表中查询出的自动注册执行器的信息列表。</li><li>从局部<code>map</code>变量中取出当前遍历执行器对应的“心跳续约”注册地址集合。</li><li>组装执行器注册地址列表，多地址逗号分隔；如果“续约”的地址集合为空，则代表当前执行器已“死亡”。</li><li>更新执行器“续约”的地址信息至<code>DB</code>：更新<code>xxl_job_group</code>表的<code>address_list</code>字段。</li></ul><p>至此，任务注册中心“心跳”机制就已完成。</p><blockquote><p>到这里我们或许有了一个疑问？<code>xxl_job_registry</code>任务注册表的记录是何时存在的？即任务是何时被注册的？<br>我们也许会在后面的文章中有所发现。</p></blockquote><p>最后，阻塞当前子线程<code>30</code>秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用<code>java.util.concurrent</code>包下的枚举<code>TimeUnit</code>类的<code>sleep</code>方法进行睡眠，先指定时间单位，再指定时间大小，代码可读性更高；如果直接使用传统<code>Thread.sleep()</code>方法，传给<code>sleep</code>方法的值的单位是毫秒，即需传入<code>30*1000</code>，代码可读性不高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用以下一副图来对注册中心“心跳续约”服务进行归纳总结。<br><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/registry-center-heartbeat-renewal.png" alt="registry-center-heartbeat-renewal"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼xxl-job之调度中心—初始化国际化组件</title>
      <link href="2020/02/27/middleware/xxl-job/initI18n/"/>
      <url>2020/02/27/middleware/xxl-job/initI18n/</url>
      
        <content type="html"><![CDATA[<p>调度中心启动时主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，这篇文章来分析第一个初始化动作：初始化国际化组件。其关键调用代码为：<code>initI18n();</code></p><h2 id="国际化简介"><a href="#国际化简介" class="headerlink" title="国际化简介"></a>国际化简介</h2><p>国际化又称为<code>i18n</code>，来源于国际化的英文单词<code>internationalization</code>从<code>i</code>到<code>n</code>之间有<code>18</code>个英文字母。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们来看一下<code>initI18n()</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initI18n</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ExecutorBlockStrategyEnum item:ExecutorBlockStrategyEnum.values()) &#123;</span><br><span class="line">        item.setTitle(I18nUtil.getString(<span class="string">&quot;jobconf_block_&quot;</span>.concat(item.name())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环迭代枚举<code>com.xxl.job.core.enums.ExecutorBlockStrategyEnum</code>，该枚举是执行器阻塞策略枚举。只有一个<code>title</code>属性，提供了三个枚举对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExecutorBlockStrategyEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SERIAL_EXECUTION(<span class="string">&quot;Serial execution&quot;</span>),</span><br><span class="line">    <span class="comment">/*CONCURRENT_EXECUTION(&quot;并行&quot;),*/</span></span><br><span class="line">    DISCARD_LATER(<span class="string">&quot;Discard Later&quot;</span>),</span><br><span class="line">    COVER_EARLY(<span class="string">&quot;Cover Early&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>循环中调用变异器<code>setTitle()</code>方法给每个枚举对象的<code>title</code>属性重新赋值。</p><p>工具类<code>I18nUtil</code>的<code>getString()</code>方法获取到以<code>jobconf_block_</code>开头，以枚举对象名结尾的属性值。</p><p>我们来看一下工具类<code>getString()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadI18nProp().getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了静态成员方法<code>loadI18nProp()</code>得到一个<code>Properties</code>对象，再调用其<code>getProperty()</code>方法从资源文件中获取对应<code>key</code>的值。</p><p>来看一下<code>loadI18nProp()</code>方法的实现：</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/I18nUtil.loadI18nProp.png" alt="I18nUtil.loadI18nProp"></p><ul><li>读取<code>application.properties</code>配置文件的<code>xxl.job.i18n</code>配置项的值;</li><li><code>build</code>组装，得到<code>i18n</code>文件路径。即<code>resources\i18n</code>目录下的<code>Resource Bundle &#39;message&#39;</code>资源包文件;</li><li>使用<code>Spring</code>提供的<code>PropertiesLoaderUtils</code>工具类加载对应资源文件。</li></ul><p>我们可以从这里知道调度中心<code>application.properties</code>的配置项<code>xxl.job.i18n</code>有两种配置，一是缺省不填，为中文；二是设置为<code>en</code>，即英文。</p><p>去<code>resources\i18n</code>目录看下资源包文件：<code>message.properties</code>和<code>message_en.properties</code>。搜索<code>jobconf_block_</code>，得到以下内容：</p><p><code>message.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## job conf</span></span><br><span class="line"><span class="attr">jobconf_block_SERIAL_EXECUTION</span>=<span class="string">单机串行</span></span><br><span class="line"><span class="attr">jobconf_block_DISCARD_LATER</span>=<span class="string">丢弃后续调度</span></span><br><span class="line"><span class="attr">jobconf_block_COVER_EARLY</span>=<span class="string">覆盖之前调度</span></span><br></pre></td></tr></table></figure><p><code>message_en.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## job conf</span></span><br><span class="line"><span class="attr">jobconf_block_SERIAL_EXECUTION</span>=<span class="string">Serial execution</span></span><br><span class="line"><span class="attr">jobconf_block_DISCARD_LATER</span>=<span class="string">Discard Later</span></span><br><span class="line"><span class="attr">jobconf_block_COVER_EARLY</span>=<span class="string">Cover Early</span></span><br></pre></td></tr></table></figure><p>可以发现键中<code>jobconf_block_</code>后接的内容即为<code>ExecutorBlockStrategyEnum</code>枚举的<code>name</code>值。一共有三个阻塞策略：单机串行、丢弃后续调度和覆盖之前调度。</p><p><code>initI18n()</code>方法的迭代完成后，枚举的<code>title</code>属性值就变成了对应的国际化设置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是分析了调度中心国际化组件的初始化原理。接下来我们将继续分析调度中心启动的其它初始化动作。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼xxl-job之调度中心启动流程解析</title>
      <link href="2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/"/>
      <url>2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要是解析调度中心<code>xxl-job-admin</code>启动流程。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我们先来看一下调度中心项目的<code>maven</code>依赖。依赖了<code>Spring Boot</code>的一些<code>starter</code>依赖：<code>web</code>、<code>test</code>、<code>freemarker</code>、<code>mail</code>、<code>actuator</code>和<code>mybatis</code>等，最后依赖了<code>xxl-job-core</code>包。</p><p>还记得我们在 <a href="/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/">修炼xxl-job之搭建本地调度平台</a> 时启动调度中心过程中控制台输出的一句日志吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:01:40.001 logback [xxl-job, admin JobScheduleHelper#scheduleThread] INFO  c.x.j.a.c.thread.JobScheduleHelper - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</span><br></pre></td></tr></table></figure><p><code>JobScheduleHelper</code>类打印了<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</code>。表示初始化任务调度器成功。</p><h2 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h2><p>我们找到<code>com.xxl.job.admin.core.thread.JobScheduleHelper</code>类中打印启动日志的代码，发现其在该类的<code>start</code>方法中，<code>start</code>方法初始化了一个子线程，在子线程中打印了日志。</p><p>那么该<code>start</code>方法是何时被执行的呢？我们发现该类并未交由<code>Spring</code>管理，借助于<code>IDEA</code>的快捷键<code>Ctrl+Alt+H</code>查看该方法的调用处，发现其在<code>XxlJobScheduler.init()</code>方法中被调用了，来看一下<code>init</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// init i18n</span></span><br><span class="line">    initI18n();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin registry monitor run</span></span><br><span class="line">    JobRegistryMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin monitor run</span></span><br><span class="line">    JobFailMonitorHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin trigger pool start</span></span><br><span class="line">    JobTriggerPoolHelper.toStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// admin log report start</span></span><br><span class="line">    JobLogReportHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start-schedule</span></span><br><span class="line">    JobScheduleHelper.getInstance().start();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JobScheduleHelper.getInstance().start();</code>这一行代码使用“饿汉式”单例模式得到<code>JobScheduleHelper</code>类对象并随之调用了其<code>start</code>方法，然后打印了一行日志：<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.</code>。</p><p>思考：既然<code>JobScheduleHelper</code>类中的子线程中的日志都进行了打印，那么在其之后的日志打印在了何处呢？</p><p>我们复制代码中的日志信息，前往调度中心启动的控制台中按下<code>Ctrl+F</code>搜索相关信息，发现确实打印了，并且打印的位置非常靠前。</p><p>再来看一下<code>init()</code>方法的写法，几乎都是调用某个<code>XxxxxHelper</code>类的<code>getInstance()</code>方法然后再调用其<code>start()</code>方法。</p><p>猜想：这里所有的<code>XxxxxHelper</code>类的<code>start()</code>方法都是开启子线程执行相关任务，才导致<code>init()</code>方法中的日志打印位置非常靠前。</p><p>实际上这是全异步化设计思想的体现。</p><p>我们发现<code>init()</code>方法所在的类<code>XxlJobScheduler</code>也未交由<code>Spring</code>管理，继续借助<code>IDEA</code>的快捷键<code>Ctrl+Alt+H</code>查看<code>init()</code>方法的调用处，发现是在<code>XxlJobAdminConfig.afterPropertiesSet()</code>方法中被调用的。</p><p><img src="https://cdn.jsdelivr.net/gh/sunchaser-lilu/sunchaser-cdn@master/images/xxl-job/XxlJobAdminConfig.afterPropertiesSet.png" alt="XxlJobAdminConfig.afterPropertiesSet"></p><p><code>XxlJobAdminConfig</code>类使用<code>@Component</code>注解交由<code>Spring</code>进行管理，并实现了<code>InitializingBean</code>和<code>DisposableBean</code>这两个接口，重写的<code>afterPropertiesSet()</code>方法中只有简单的三行代码，第二行使用<code>new</code>关键字创建了<code>XxlJobScheduler</code>对象赋给私有成员变量<code>xxlJobScheduler</code>，随后第三行调用了其<code>init()</code>方法。</p><p>至此，我们找到了启动的起点，不妨先来分析一下这个“起点类”。</p><p>从类名来看，它是一个配置类。其第一个静态成员变量<code>adminConfig</code>是它本身，并在<code>afterPropertiesSet()</code>方法的第一行将<code>this</code>关键字赋给了该变量。</p><p>这是什么意思？“自身包含自身”吗？在该静态成员变量下还提供了一个静态方法<code>getAdminConfig()</code>用来获取该静态成员变量的引用。那我可以无限链式调用静态方法<code>getAdminConfig()</code>了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XxlJobAdminConfig.getAdminConfig().getAdminConfig().getAdminConfig().......getAdminConfig();</span><br></pre></td></tr></table></figure><p>只有第一次调用是通过类名.静态方法名，第一次调用返回了类的实例对象<code>adminConfig</code>，所以第二次以及之后的每次链式调用都是通过实例对象.静态方法名。这是不被建议和认可的，编译器也发出了黄色警告。所以每次使用时建议是只调用一次，调用一次就拿到了<code>XxlJobAdminConfig</code>类的对象，多次链式调用并无任何作用。</p><p>再来看一下<code>XxlJobAdminConfig</code>类的其它成员变量，发现是一些通过<code>@Value</code>注解获取的一些配置信息，还有一些是通过<code>@Resource</code>注解注入的<code>XxxxxxDao</code>类和其它业务类，同时提供了每个成员变量的访问器（<code>getter</code>方法）。</p><p>为什么这么做呢？为什么要将这些<code>XxxxxxDao</code>等类放到这里并提供访问器呢？</p><p>简单猜想：实际上<code>XxlJobAdminConfig</code>可以看做是一个简单的“容器”，调度中心在启动时将整个系统需要用到的配置信息和<code>XxxxxxDao</code>类对象初始化到该“容器”中，在需要使用某个<code>XxxxxxDao</code>类时，不使用<code>Spring</code>的依赖注入，而是从该“容器”中拿，还记得前面分析过的静态方法<code>getAdminConfig()</code>，它返回了<code>XxlJobAdminConfig</code>类的对象，我们可以这样来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XxlJobAdminConfig.getAdminConfig().getXxxxxxDao()</span><br></pre></td></tr></table></figure><p>这样做有什么好处呢？</p><p>猜想：这样做对系统的配置信息和依赖信息进行了统一管理，有一种全局配置感。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要分析了调度中心项目<code>xxl-job-admin</code>的启动流程。发现主要执行了<code>XxlJobScheduler.init()</code>方法，该方法中有六个初始化动作，接下来我们会逐个进行分析。</p><ul><li><a href="/2020/02/27/middleware/xxl-job/initI18n/">初始化国际化组件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建mysql5.7的Docker容器</title>
      <link href="2020/02/19/ops/docker/create-mysql-container/"/>
      <url>2020/02/19/ops/docker/create-mysql-container/</url>
      
        <content type="html"><![CDATA[<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h2><p>如果不创建挂载目录，一旦容器重启，则数据会全部丢失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;data &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;logs &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;conf</span><br></pre></td></tr></table></figure><h2 id="创建mysql配置文件"><a href="#创建mysql配置文件" class="headerlink" title="创建mysql配置文件"></a>创建<code>mysql</code>配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql</span><br><span class="line">touch my.cnf</span><br><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br><span class="line">secure_file_priv&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">expire_logs_days&#x3D;7</span><br><span class="line">sql_mode&#x3D;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">max_connections&#x3D;1000</span><br><span class="line"> </span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"> </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart&#x3D;always -p 3306:3306 --name mysql5.7 -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;usr&#x2F;local&#x2F;software&#x2F;mysql&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.7</span><br></pre></td></tr></table></figure><ul><li><code>--restart=always</code>：当docker重启时，容器也重启。</li><li><code>--name</code>：容器名称。</li><li><code>-p 3306:3306</code>：宿主机：容器端口映射。</li><li><code>-v source:target</code>：目录挂载。</li><li><code>-e</code>：设置环境变量（<code>mysql</code>密码）。</li><li><code>-d</code>：后台启动。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="2020/02/19/ops/docker/docker-common-commands/"/>
      <url>2020/02/19/ops/docker/docker-common-commands/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><p><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p><p><code>yum install docker-ce docker-ce-cli containerd.io</code></p><h2 id="设为开机启动"><a href="#设为开机启动" class="headerlink" title="设为开机启动"></a>设为开机启动</h2><p><code>systemctl enable docker</code></p><p>非常重要！！！否则可能重启机器后再次启动<code>docker</code>时会出现以下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to start docker: Unit docker is masked.</span><br></pre></td></tr></table></figure><h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><p><code>systemctl status docker</code></p><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p><code>systemctl stop docker</code></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>systemctl start docker</code></p><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p><code>systemctl restart docker</code></p><h2 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h2><p><code>docker version</code></p><h2 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h2><p><code>docker --help</code></p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p><code>docker images</code></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p><code>docker pull [OPTIONS] NAME[:tag]</code></p><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>参考 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云容器镜像加速器服务</a></p><h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p><code>docker search NAME</code></p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p><code>docker rmi NAME1/ID1 NAME2/ID2</code></p><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><ul><li>查看正在运行的容器：<code>docker ps</code></li><li>查看所有容器：<code>docker ps -a</code></li><li>查看最后一次运行的容器：<code>docker ps -l</code></li></ul><h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><p><code>exit</code></p><h2 id="创建交互式容器"><a href="#创建交互式容器" class="headerlink" title="创建交互式容器"></a>创建交互式容器</h2><p><code>docker run -i -t --name=[NAME] IMAGE /bin/bash</code></p><ul><li><code>-i</code>：交互式操作</li><li><code>-t</code>：分配一个可操作容器的终端</li><li><code>--name=[NAME]</code>：指定容器名称（唯一）</li></ul><p>可选参数可合并：<br><code>docker run -it --name [NAME] IMAGE /bin/bash</code></p><p>交互式容器<code>exit</code>退出后容器自动关闭。</p><h2 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h2><p><code>docker run -itd --name NAME IMAGE /bin/bash</code></p><p><code>-d</code>：指定容器运行模式</p><h2 id="进入守护式容器"><a href="#进入守护式容器" class="headerlink" title="进入守护式容器"></a>进入守护式容器</h2><p><code>docker exec -it [CONTAINER ID] /bin/bash</code></p><p>守护式容器<code>exit</code>退出后容器继续运行。</p><h2 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h2><p><code>docker start [CONTAINER ID]</code></p><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p><code>docker stop [CONTAINER ID]</code></p><h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><p><code>docker restart [CONTAINER ID]</code></p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><code>docker rm -f [CONTAINER ID]</code></p><p>删除时容器必须是停止状态。</p><p>删除全部容器（先查询出所有容器再删除）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &#96;docker ps -a -q&#96;</span><br></pre></td></tr></table></figure><h2 id="查看容器详细信息"><a href="#查看容器详细信息" class="headerlink" title="查看容器详细信息"></a>查看容器详细信息</h2><p><code>docker inspect [CONTAINER NAME]</code></p><h2 id="查看容器详细信息中某个属性的详细信息"><a href="#查看容器详细信息中某个属性的详细信息" class="headerlink" title="查看容器详细信息中某个属性的详细信息"></a>查看容器详细信息中某个属性的详细信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#96;docker inspect -f&#x3D;&#39;&#123;&#123;.[属性名]&#125;&#125;&#39; [CONTAINER NAME]&#96;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#96;docker inspect --format&#x3D;&#39;&#123;&#123;.[属性名]&#125;&#125;&#39; [CONTAINER NAME]&#96;</span><br></pre></td></tr></table></figure><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p><code>docker cp source target</code></p><p>可将宿主机的文件/目录拷贝至容器或将容器内的文件/目录拷贝至宿主机。</p><p><code>example</code>：</p><p>从宿主机（source）拷贝至容器内（target）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp .&#x2F;1.txt container1:&#x2F;root</span><br></pre></td></tr></table></figure><p>从容器内（source）拷贝至宿主机（target）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp container1:&#x2F;root .&#x2F;1.txt</span><br></pre></td></tr></table></figure><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>创建容器时指定<code>-p</code>参数将容器内端口映射到宿主机的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name&#x3D;NAME -p 宿主机端口:容器端口 IMAGE &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><p>创建容器时指定<code>-v</code>参数进行目录挂载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name&#x3D;NAME -v 宿主机目录:容器目录 IMAGE &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h2 id="镜像打包"><a href="#镜像打包" class="headerlink" title="镜像打包"></a>镜像打包</h2><p><code>docker save -o [dir/NAME.tar] IMAGE_NAME</code></p><h2 id="将打包的镜像上传至其它服务器"><a href="#将打包的镜像上传至其它服务器" class="headerlink" title="将打包的镜像上传至其它服务器"></a>将打包的镜像上传至其它服务器</h2><p><code>scp ./NAME.tar ip:/root/dir</code></p><h2 id="导入打包镜像"><a href="#导入打包镜像" class="headerlink" title="导入打包镜像"></a>导入打包镜像</h2><p><code>docker load -i /root/dir/NAME.tar</code></p><h2 id="容器打包"><a href="#容器打包" class="headerlink" title="容器打包"></a>容器打包</h2><p><code>docker export -o /root/CONTAINER_NAME.tar CONTAINER_NAME</code></p><h2 id="导入打包容器"><a href="#导入打包容器" class="headerlink" title="导入打包容器"></a>导入打包容器</h2><p><code>docker import CONTAINER_NAME.tar CONTAINER_NAME</code></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼xxl-job之搭建本地调度平台</title>
      <link href="2020/02/13/middleware/xxl-job/build-local-dispatch-platform/"/>
      <url>2020/02/13/middleware/xxl-job/build-local-dispatch-platform/</url>
      
        <content type="html"><![CDATA[<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p><code>xxl-job</code>目前最新<code>master</code>分支的代码为<code>v2.2.0</code>，官网显示仍在迭代中（该版本目前发布的更新内容主要是调度中心升级<code>SpringBoot</code>版本为<code>2.x</code>），所以本次修炼我们采用最近稳定版<code>v2.1.2</code>，发布日期为<code>2019-12-12</code>。</p><p>源码地址：<a href="https://github.com/xuxueli/xxl-job">GitHub</a>/<a href="https://gitee.com/xuxueli0323/xxl-job">Gitee</a></p><h2 id="工程简介"><a href="#工程简介" class="headerlink" title="工程简介"></a>工程简介</h2><p>源码结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xxl-job-admin：调度中心</span><br><span class="line">xxl-job-core：公共依赖</span><br><span class="line">xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）</span><br><span class="line">    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；</span><br><span class="line">    ：xxl-job-executor-sample-spring：Spring版本，通过Spring容器管理执行器，比较通用；</span><br><span class="line">    ：xxl-job-executor-sample-frameless：无框架版本；</span><br><span class="line">    ：xxl-job-executor-sample-jfinal：JFinal版本，通过JFinal管理执行器；</span><br><span class="line">    ：xxl-job-executor-sample-nutz：Nutz版本，通过Nutz管理执行器；</span><br><span class="line">    ：xxl-job-executor-sample-jboot：jboot版本，通过jboot管理执行器；</span><br></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>基础环境：</p><ul><li><code>Maven3+</code></li><li><code>JDK7+</code></li><li><code>MySQL5.7+</code></li></ul><h3 id="搭建调度中心"><a href="#搭建调度中心" class="headerlink" title="搭建调度中心"></a>搭建调度中心</h3><p>调度中心项目：<code>xxl-job-admin</code>。</p><p>作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。</p><h4 id="初始化“调度数据库”"><a href="#初始化“调度数据库”" class="headerlink" title="初始化“调度数据库”"></a>初始化“调度数据库”</h4><p>源码下载后获取初始化数据库<code>SQL</code>脚本并在<code>MySQL</code>中执行。</p><p>调度数据库初始化<code>SQL</code>脚本地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;xxl-job&#x2F;doc&#x2F;db&#x2F;tables_xxl_job.sql</span><br></pre></td></tr></table></figure><h4 id="修改调度中心配置"><a href="#修改调度中心配置" class="headerlink" title="修改调度中心配置"></a>修改调度中心配置</h4><p>将整个项目工程导入<code>IDEA</code>中，等待<code>maven</code>依赖下载完毕，修改调度中心配置。</p><p>调度中心配置文件地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;xxl-job&#x2F;xxl-job-admin&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties</span><br></pre></td></tr></table></figure><p>需要修改的配置项有以下三个：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>将数据源信息修改为上一步中导入脚本的数据库信息。</p><h4 id="启动调度中心"><a href="#启动调度中心" class="headerlink" title="启动调度中心"></a>启动调度中心</h4><p>在<code>IDEA</code>中运行<code>com.xxl.job.admin.XxlJobAdminApplication#main</code>方法，启动调度中心。</p><p>如果一切配置正常，可在控制台看到以下三行关键日志信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13:01:37.678 logback [main] INFO  o.s.b.c.e.t.TomcatEmbeddedServletContainer - Tomcat started on port(s): 8080 (http)</span><br><span class="line">13:01:37.690 logback [main] INFO  c.x.job.admin.XxlJobAdminApplication - Started XxlJobAdminApplication in 6.976 seconds (JVM running for 8.944)</span><br><span class="line">13:01:40.001 logback [xxl-job, admin JobScheduleHelper#scheduleThread] INFO  c.x.j.a.c.thread.JobScheduleHelper - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</span><br></pre></td></tr></table></figure><p><code>Tomcat</code>容器监听<code>8080</code>端口启动；</p><p><code>JVM</code>启动；</p><p><code>JobScheduleHelper</code>这个类打印了<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.</code>这句话。</p><h4 id="访问调度中心地址"><a href="#访问调度中心地址" class="headerlink" title="访问调度中心地址"></a>访问调度中心地址</h4><p>如已正确进行前述步骤，则可访问调度中心。</p><p>调度中心访问地址：<code>http://localhost:8080/xxl-job-admin</code></p><p>该地址执行器将会使用到，作为回调地址。</p><p>默认管理员账号密码为<code>admin/123456</code>。登录成功后可看到如下界面：</p><p><img src="https://i.loli.net/2020/02/15/oZum5VbtTvH1SeY.png" alt="xxl-job-index.png"></p><p>至此调度中心搭建完毕。</p><h3 id="搭建执行器"><a href="#搭建执行器" class="headerlink" title="搭建执行器"></a>搭建执行器</h3><p>“执行器”示例项目：<code>xxl-job-executor-sample</code>，该模块下包含多个版本的执行器示例，我们选用<code>xxl-job-executor-sample-springboot</code>版本。</p><p>作用：负责接收“调度中心”的调度并执行；可直接部署执行器项目，也可以将执行器集成到现有业务项目中。</p><h4 id="启动执行器"><a href="#启动执行器" class="headerlink" title="启动执行器"></a>启动执行器</h4><p>在<code>IDEA</code>中运行<code>com.xxl.job.executor.XxlJobExecutorApplication#main</code>方法，启动示例执行器。</p><p>如果一切运行正常，可在控制台看到以下关键日志信息（这将作为我们后续解析源码的思路）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">16:47:51.370 logback [main] INFO  c.x.j.e.core.config.XxlJobConfig - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.</span><br><span class="line">16:47:51.425 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:httpJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@1c32886a[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#httpJobHandler]</span><br><span class="line">16:47:51.426 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:demoJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3a4b0e5d[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#demoJobHandler]</span><br><span class="line">16:47:51.426 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:demoJobHandler2, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@10b892d5[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#demoJobHandler2]</span><br><span class="line">16:47:51.427 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:commandJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3d3f761a[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#commandJobHandler]</span><br><span class="line">16:47:51.427 logback [main] INFO  c.x.job.core.executor.XxlJobExecutor - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job register jobhandler success, name:shardingJobHandler, jobHandler:com.xxl.job.core.handler.impl.MethodJobHandler@3546d80f[class com.xxl.job.executor.service.jobhandler.SampleXxlJob#shardingJobHandler]</span><br><span class="line">......</span><br><span class="line">16:47:52.172 logback [main] INFO  c.x.r.r.p.XxlRpcProviderFactory - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-rpc, provider factory add service success. serviceKey &#x3D; com.xxl.job.core.biz.ExecutorBiz, serviceBean &#x3D; class com.xxl.job.core.biz.impl.ExecutorBizImpl</span><br><span class="line">......</span><br><span class="line">16:48:02.189 logback [Thread-10] INFO  com.xxl.rpc.remoting.net.Server - &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-rpc remoting server start success, nettype &#x3D; com.xxl.rpc.remoting.net.impl.netty_http.server.NettyHttpServer, port &#x3D; 9999</span><br></pre></td></tr></table></figure><p>启动成功后，点击任务调度中心后台导航-执行器管理菜单，可看到如下图所示：<code>OnLine</code>机器地址中已显示我们运行的执行器地址。</p><p><img src="https://i.loli.net/2020/02/15/2iUXThLzZHMkP9w.png" alt="xxl-job-executor-online.png"></p><p>点击任务管理菜单可看到示例执行器的测试任务1；</p><p><img src="https://i.loli.net/2020/02/15/DjYCsoTmGf3zknV.png" alt="xxl-job-demo-executor.png"></p><p>点击右侧[操作]-&gt;[执行一次]，弹出的模态框中无需输入任务参数，直接点击[保存]即可执行任务；</p><p><img src="https://i.loli.net/2020/02/15/tq754auXjG1NP3f.png" alt="xxl-job-executor-one-times.png"></p><p>点击[查询日志]，可进入调度日志列表页，点击右侧[执行日志]，可看到任务在执行器一侧运行输出的日志信息。</p><p><img src="https://i.loli.net/2020/02/15/3WUBxcaE8YZMG6i.png" alt="xxl-job-executor-log.png"></p><p><img src="https://i.loli.net/2020/02/15/nVaF4GzW2LsUYxC.jpg" alt="xxl-job-executor-log-page.png"></p><p>至此，我们已经完成了任务的调度和执行。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修炼xxl-job之执行器项目七大配置项解析</title>
      <link href="2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/"/>
      <url>2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要是解析执行器项目七大配置项作用和原理。我们以示例执行器<code>xxl-job-executor-sample-springboot</code>项目为例。</p><h2 id="工程结构介绍"><a href="#工程结构介绍" class="headerlink" title="工程结构介绍"></a>工程结构介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├─java</span><br><span class="line">│  └─com</span><br><span class="line">│      └─xxl</span><br><span class="line">│          └─job</span><br><span class="line">│              └─executor</span><br><span class="line">│                  │  XxlJobExecutorApplication.java  ------启动类</span><br><span class="line">│                  │</span><br><span class="line">│                  ├─core</span><br><span class="line">│                  │  └─config</span><br><span class="line">│                  │          XxlJobConfig.java       ------XxlJobSpringExecutor配置类</span><br><span class="line">│                  │</span><br><span class="line">│                  ├─mvc</span><br><span class="line">│                  │  └─controller</span><br><span class="line">│                  │          IndexController.java    ------空文件</span><br><span class="line">│                  │</span><br><span class="line">│                  └─service</span><br><span class="line">│                      └─jobhandler</span><br><span class="line">│                              SampleXxlJob.java      ------示例执行器类</span><br><span class="line">│</span><br><span class="line">└─resources</span><br><span class="line">        application.properties                        ------项目配置文件</span><br><span class="line">        logback.xml                                   ------日志配置文件</span><br></pre></td></tr></table></figure><h2 id="com-xxl-job-executor-core-config-XxlJobConfig配置类解读"><a href="#com-xxl-job-executor-core-config-XxlJobConfig配置类解读" class="headerlink" title="com.xxl.job.executor.core.config.XxlJobConfig配置类解读"></a><code>com.xxl.job.executor.core.config.XxlJobConfig</code>配置类解读</h2><p>由于是<code>SpringBoot</code>项目，该类采用<code>@Configuration</code>注解添加配置。</p><h3 id="成员变量简介"><a href="#成员变量简介" class="headerlink" title="成员变量简介"></a>成员变量简介</h3><p>该配置类一共包含八个成员变量。</p><h4 id="日志对象"><a href="#日志对象" class="headerlink" title="日志对象"></a>日志对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);</span><br></pre></td></tr></table></figure><p><code>slf4j</code>的日志对象，用来打印关键日志。</p><h4 id="七大核心属性变量"><a href="#七大核心属性变量" class="headerlink" title="七大核心属性变量"></a>七大核心属性变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String accessToken;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> logRetentionDays;</span><br></pre></td></tr></table></figure><p>使用<code>Spring</code>提供的<code>@Value</code>注解来注入配置文件<code>application.properties</code>中的配置信息。</p><p>我们打开<code>resources</code>目录下的<code>application.properties</code>文件查看，默认配置信息如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### xxl-job admin address list, such as &quot;http://address&quot; or &quot;http://address01,http://address02&quot;</span></span><br><span class="line"><span class="meta">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### xxl-job executor address</span></span><br><span class="line"><span class="meta">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="meta">xxl.job.executor.ip</span>=<span class="string"></span></span><br><span class="line"><span class="meta">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### xxl-job, access token</span></span><br><span class="line"><span class="meta">xxl.job.accessToken</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">### xxl-job log path</span></span><br><span class="line"><span class="meta">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### xxl-job log retention days</span></span><br><span class="line"><span class="meta">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><p>根据配置文件中的相关注释我们来解释七大核心属性的含义：</p><ul><li><code>adminAddresses</code>：<ul><li>配置项：<code>xxl.job.admin.addresses</code>，选填。</li><li>含义：调度中心部署根地址。</li><li>作用：执行器会使用该地址进行“执行器心跳注册”和任务结果回调。</li><li>注意事项：如调度中心集群部署，存在多个根地址，则用逗号分隔。为空不填则关闭自动注册功能。</li></ul></li><li><code>appName</code>：<ul><li>配置项：<code>xxl.job.executor.appname</code>，选填。</li><li>含义：是每个执行器集群的唯一标示AppName。</li><li>作用：执行器心跳注册分组依据。</li><li>注意事项：为空不填表示关闭自动注册功能。</li></ul></li><li><code>ip</code>：<ul><li>配置项：<code>xxl.job.executor.ip</code>，选填。</li><li>含义：执行器<code>IP</code>。</li><li>作用：适用于多网卡时手动设置指定<code>IP</code>，该<code>IP</code>不会绑定<code>Host</code>仅作为通讯使用；用于“执行器注册”和“调度中心请求并触发任务”。</li><li>注意事项：为空不填表示自动获取<code>IP</code>。</li></ul></li><li><code>port</code>：<ul><li>配置项：<code>xxl.job.executor.port</code>，选填。</li><li>含义：执行器端口号。执行器实际是一个内嵌的<code>Server</code>，默认端口<code>9999</code>。</li><li>作用：用于“执行器注册”和“调度中心请求并触发任务”时通讯。</li><li>注意事项：小于等于<code>0</code>时自动获取。单机部署多个执行器时，不同执行器端口不能相同。</li></ul></li><li><code>accessToken</code>：<ul><li>配置项：<code>xxl.job.accessToken</code>，选填。</li><li>含义：访问令牌。</li><li>作用：为提升系统安全性，调度中心和执行器进行安全性校验，双方<code>accessToken</code>匹配才允许通讯。</li><li>注意事项：正常通讯只有两种设置；<ul><li>设置一：调度中心和执行器均不设置<code>accessToken</code>，关闭访问令牌校验。</li><li>设置二：调度中心和执行器设置相同的<code>accessToken</code>。</li></ul></li></ul></li><li><code>logPath</code>：<ul><li>配置项：<code>xxl.job.executor.logpath</code>，选填。</li><li>含义：执行器运行日志文件存储磁盘路径。</li><li>作用：设置执行器运行日志文件存储磁盘路径。</li><li>注意事项：需要对设置的路径拥有读写权限；为空则使用默认路径（<code>/data/applogs/xxl-job/jobhandler</code>）。</li></ul></li><li><code>logRetentionDays</code>：<ul><li>配置项：<code>xxl.job.executor.logretentiondays</code>，选填。</li><li>含义：执行器日志文件保存天数。</li><li>作用：设置过期日志自动清理。</li><li>注意事项：设置的值大于等于<code>3</code>时生效；否则日志自动清理功能关闭。</li></ul></li></ul><h3 id="com-xxl-job-executor-core-config-XxlJobConfig-xxlJobExecutor方法作用"><a href="#com-xxl-job-executor-core-config-XxlJobConfig-xxlJobExecutor方法作用" class="headerlink" title="com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor方法作用"></a><code>com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor</code>方法作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XxlJobSpringExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">    XxlJobSpringExecutor xxlJobSpringExecutor = <span class="keyword">new</span> XxlJobSpringExecutor();</span><br><span class="line">    xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">    xxlJobSpringExecutor.setAppName(appName);</span><br><span class="line">    xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">    xxlJobSpringExecutor.setPort(port);</span><br><span class="line">    xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">    xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">    xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上一部分列举出的七大属性最终设置给了<code>com.xxl.job.core.executor.impl.XxlJobSpringExecutor</code>这个类的对象，并使用<code>@Bean</code>注解交由<code>Spring</code>进行管理。该方法中打印的日志信息 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.</code> 我们在启动执行器时控制台有输出。</p><h2 id="七大属性配置详解"><a href="#七大属性配置详解" class="headerlink" title="七大属性配置详解"></a>七大属性配置详解</h2><p>上一部分列举出了每个属性的注意事项等，这一部分我们去源码中验证上一部分的内容。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们要找到上述七大属性在设置给<code>com.xxl.job.core.executor.impl.XxlJobSpringExecutor</code>这个类的对象时是如何以及怎样进行条件限制的。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>从<code>com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor</code>方法来看，这些配置从配置文件中读到值后是直接使用变异器（<code>setter</code>方法）设置给<code>xxlJobSpringExecutor</code>这个对象，然后就把这个对象交给<code>Spring</code>进行管理了，所以只有两种可能，第一是在变异器中进行了逻辑处理，第二是在<code>Spring</code>加载<code>bean</code>的过程中进行了逻辑处理。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>我们首先看一下<code>com.xxl.job.core.executor.impl.XxlJobSpringExecutor</code>这个类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobSpringExecutor</span> <span class="keyword">extends</span> <span class="title">XxlJobExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>该类继承了<code>com.xxl.job.core.executor.XxlJobExecutor</code>父类并实现了<code>Spring</code>的三个接口；我们在该类中未找属性对应的变异器，所以我们几乎可以断定这些属性是定义在父类中。</p><p>我们来看父类的代码</p><p><img src="https://i.loli.net/2020/02/15/Xg4kodaAcUKtLG9.jpg" alt="XxlJobExecutor变异器.png"></p><p>变异器只是单纯的把传入的值设置给对象，所以排除了第一种可能，情况只能是第二种：在<code>Spring</code>加载<code>bean</code>的过程中进行了逻辑处理。</p><p>我们继续往下看父类<code>XxlJobExecutor</code>的代码，发现<code>start</code>方法中用到了这些属性，接下来我们来仔细阅读以下该方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------- start + stop ----------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init logpath</span></span><br><span class="line">    XxlJobFileAppender.initLogPath(logPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init invoker, admin-client</span></span><br><span class="line">    initAdminBizList(adminAddresses, accessToken);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init JobLogFileCleanThread</span></span><br><span class="line">    JobLogFileCleanThread.getInstance().start(logRetentionDays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init TriggerCallbackThread</span></span><br><span class="line">    TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init executor-server</span></span><br><span class="line">    port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line">    ip = (ip!=<span class="keyword">null</span>&amp;&amp;ip.trim().length()&gt;<span class="number">0</span>)?ip: IpUtil.getIp();</span><br><span class="line">    initRpcProvider(ip, port, appName, accessToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有七行核心代码，我们一行一行的来解读：</p><ol><li><code>XxlJobFileAppender.initLogPath(logPath);</code></li></ol><p>从方法名来看显然是初始化日志存储路径，我们进入<code>XxlJobFileAppender</code>类查看<code>initLogPath(logPath)</code>方法，代码如下：</p><p><img src="https://i.loli.net/2020/02/15/DswcF91RrLxi4Ca.jpg" alt="XxlJobFileAppender_initLogPath.png"></p><p>我们可以看到静态成员变量<code>logBasePath</code>的值为<code>/data/applogs/xxl-job/jobhandler</code>，当<code>logPath</code>属性未配置时该路径即为日志存盘的默认路径。</p><p>该方法的实现思路如下：</p><ul><li>如果配置的<code>logPath</code>不为空则覆盖静态成员变量<code>logBasePath</code>的值。</li><li>以静态成员变量<code>logBasePath</code>的值调用<code>File</code>类的<code>mkdirs</code>方法创建多级文件目录。</li><li>调用<code>File</code>类的<code>getPath</code>方法将创建好的文件夹的路径重新赋值给静态成员变量<code>logBasePath</code>。</li></ul><p>以上就是属性<code>logPath</code>的配置方式。</p><ol start="2"><li><code>initAdminBizList(adminAddresses, accessToken);</code></li></ol><p>从方法名来看该方法的作用是初始化调度中心部署根地址集合，其参数是配置项<code>adminAddresses</code>和<code>accessToken</code>的值。我们来看该方法的具体实现：</p><p><img src="https://i.loli.net/2020/02/15/KANYOLTaBfeh3mx.jpg" alt="initAdminBizList.png"></p><p>该方法的实现思路如下：</p><ul><li>判断传入的配置项<code>adminAddresses</code>的值是否为<code>null</code>并且去除两端空格后的长度是否大于零。</li><li>如果不满足第一步的条件则什么也不做，即关闭自动注册功能；如果满足第一步的条件，则去除两端空格后调用<code>split</code>方法以英文逗号<code>,</code>分割成字符串数组进行遍历，遍历的第一步是限制数组中的单个地址值不为<code>null</code>并且去除两端空格后的长度大于零，这一步是为了防止<code>,http://127.0.0.1:8080/xxl-job-admin,</code>等类似误配置。</li><li>一切限制条件通过后开始创建<code>com.xxl.job.core.biz.client.AdminBizClient</code>类的对象，并添加至静态成员变量<code>adminBizList</code>集合中。这里是在第一次循环时才使用<code>new</code>关键字创建<code>ArrayList</code>集合对象，其思想是“懒加载”，用时才去创建对象。由于<code>Spring</code>的<code>bean</code>的默认作用域是单例的，所以保证了该初始化方法只会执行一次。</li></ul><p>我们来看一下<code>com.xxl.job.core.biz.client.AdminBizClient</code>类的构造方法：</p><p><img src="https://i.loli.net/2020/02/15/on4UPLwMYal8jsm.png" alt="AdminBizClient_AdminBizClient.png"></p><p>构造方法中对传入的<code>addressUrl</code>进行了简单的<code>valid</code>校验，如果不是以<code>/</code>结尾则将<code>/</code>拼接至末尾。此处可看出我们的<code>adminAddresses</code>配置实际会变成类似<code>http://127.0.0.1:8080/xxl-job-admin/</code>这样的字符串。至于该类对象什么时候使用我们暂时没有线索，大可先不关注这个。</p><ol start="3"><li><code>JobLogFileCleanThread.getInstance().start(logRetentionDays);</code></li></ol><p>调用<code>JobLogFileCleanThread</code>类的<code>getInstance</code>方法取得该类对象再调用其<code>start(final long logRetentionDays)</code>方法。</p><p>从类名来看是清除日志文件的线程。</p><p>我们前往<code>com.xxl.job.core.thread.JobLogFileCleanThread</code>类看一下<code>getInstance</code>方法，会发现有如下两行关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JobLogFileCleanThread instance = <span class="keyword">new</span> JobLogFileCleanThread();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobLogFileCleanThread <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是“饿汉式”单例模式的写法，创建了单例的<code>JobLogFileCleanThread</code>对象。</p><p>接下来看一下<code>start</code>方法：</p><p><img src="https://i.loli.net/2020/02/15/V7KL4TDFZdYaqrj.png" alt="JobLogFileCleanThread_start.png"></p><p>首先第一步检查设置的<code>logRetentionDays</code>属性是否小于<code>3</code>，小于则直接<code>return</code>；这里说明了配置文件中的值设置小于<code>3</code>时关闭日志自动清理功能。</p><p>该方法中实例化了成员变量<code>private Thread localThread;</code>，调用了<code>setDaemon(true)</code>方法将该线程设置为守护线程，并调用<code>setName</code>方法将线程名设为了<code>xxl-job, executor JobLogFileCleanThread</code>。</p><p>线程中运行的<code>run</code>方法逻辑大致如下：</p><ul><li>调用<code>XxlJobFileAppender.getLogPath()</code>方法获取设置的日志存盘路径</li><li>遍历该路径下所有文件夹，判断当前时间与文件夹的创建时间之差是否大于等于设置的<code>logRetentionDays</code>天数，如果大于则调用工具类<code>com.xxl.job.core.util.FileUtil</code>的<code>deleteRecursively</code>方法递归删除文件夹下的所有文件。</li><li>删除逻辑完成后，有这样一行代码：<code>TimeUnit.DAYS.sleep(1);</code>，线程睡眠一天。这里调用并发包下的<code>TimeUnit</code>类的<code>sleep</code>方法让代码可读性更高，如果直接使用传统<code>Thread.sleep()</code>方法，传给<code>sleep</code>方法的值的单位是毫秒，即需传入<code>24*60*60*1000</code>，代码可读性不高。</li></ul><ol start="4"><li><code>TriggerCallbackThread.getInstance().start();</code></li></ol><p>从类名<code>TriggerCallbackThread</code>来看，这是执行器回调线程，由于未使用到配置参数，这篇文章不对其进行展开解读。</p><ol start="5"><li><code>port = port&gt;0?port: NetUtil.findAvailablePort(9999);</code></li></ol><p>初始化<code>port</code>端口号。</p><p>如果配置文件中设置的端口号大于零，则使用配置文件中的值；</p><p>否则执行代码<code>NetUtil.findAvailablePort(9999);</code>，我们进入<code>NetUtil</code>类查看<code>findAvailablePort</code>方法，发现这个类属于<code>com.xxl.rpc.util</code>包，可见，<code>xxl-job</code>依赖了<code>xxl-rpc</code>（这是作者许雪里开源的<code>rpc</code>框架）。</p><p>从方法名来看作用是“寻找可用端口”，我们来看一下<code>findAvailablePort</code>方法的具体实现逻辑：</p><p><img src="https://i.loli.net/2020/02/15/Y6MigAsaEbWwLxv.png" alt="NetUtil_findAvailablePort.png"></p><ul><li>传入的<code>9999</code>作为默认端口，首先循环<code>9999</code>到<code>65534</code>端口，逐个进行<code>!isPortUsed(portTmp)</code>判断，如果返回<code>true</code>则表示当前端口号未被使用，返回赋值给属性<code>port</code>。</li><li>如果上述循环未找到可使用的端口，则再循环<code>9999</code>到<code>1</code>端口，同样逐个进行<code>!isPortUsed(portTmp)</code>判断，如果还未找到可用端口，则抛出<code>XxlRpcException</code>异常，异常信息为<code>no available port.</code>。</li></ul><p>我们来看一下<code>isPortUsed</code>方法是如何判断端口是否被使用的：</p><p><img src="https://i.loli.net/2020/02/15/jy9bL4ZIrwB7shd.png" alt="NetUtil_isPortUsed.png"></p><p>实际是尝试去创建一个<code>ServerSocket</code>客户端并与传入的端口号进行绑定，如端口被占用则绑定时会抛出<code>IOException</code>，由此来确定端口是否被使用，从而在未配置端口号时选出一个可用端口。最终<code>finally</code>代码块中调用了<code>close</code>方法关闭资源。</p><ol start="6"><li><code>ip = (ip!=null&amp;&amp;ip.trim().length()&gt;0)?ip: IpUtil.getIp();</code></li></ol><p>作用：确定<code>ip</code>地址。示例执行器的配置中是未进行配置的，所以会执行<code>IpUtil.getIp()</code>方法，该方法中最后会调用<code>java.net.InetAddress#getHostAddress</code>方法，该方法返回<code>null</code>，所以属性<code>ip</code>会被设置成<code>null</code>。</p><ol start="7"><li><code>initRpcProvider(ip, port, appName, accessToken);</code></li></ol><p>传入了四个参数：<code>ip</code>、<code>port</code>、<code>appName</code>和<code>accessToken</code>用来初始化<code>Rpc</code>服务提供者。这部分属于<code>xxl-rpc</code>的内容，目前我们可以简单看看，大致内容是创建出<code>XxlRpcProviderFactory</code>类的对象，给该对象设置相关属性，添加<code>com.xxl.job.core.biz.impl.ExecutorBizImpl</code>服务至<code>rpc</code>服务提供者<code>map</code>容器中，最后调用<code>start</code>方法启动服务提供者（这里实际是一个<code>NettyServer</code>）。</p><p>现在我们大可不必去关注<code>xxl-rpc</code>是怎么实现的，这篇文章的目的是搞清楚七大核心配置的工作原理。</p><p>父类<code>XxlJobExecutor</code>的<code>start</code>方法我们看完了，那么它是什么时机执行的呢？</p><p>我们注意到<code>XxlJobSpringExecutor</code>类实现了<code>Spring</code>的<code>InitializingBean</code>接口，该接口提供了<code>afterPropertiesSet</code>方法供子类实现，在<code>bean</code>加载过程中会执行该方法。</p><p>接下来我们来看一下<code>XxlJobSpringExecutor</code>类中重写的<code>afterPropertiesSet</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init JobHandler Repository</span></span><br><span class="line">    initJobHandlerRepository(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init JobHandler Repository (for method)</span></span><br><span class="line">    initJobHandlerMethodRepository(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// refresh GlueFactory</span></span><br><span class="line">    GlueFactory.refreshInstance(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// super start</span></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三行代码是初始化一些东西，暂时不去关注；最后一行<code>super.start()</code>是我们的关键，调用了父类的<code>start</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们知道了七大配置项的基本原理，对我们使用<code>xxl-job</code>有了一些帮助。例如配置项<code>logretentiondays</code>不能小于<code>3</code>，否则日志文件不会自动清理等。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下Git安装及SSH公私钥配置</title>
      <link href="2020/02/07/installed/install-git/"/>
      <url>2020/02/07/installed/install-git/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="https://git-scm.com/">Git官网</a> 下载最新<code>Windows</code>安装文件（下载速度有点感人）。</p><p>这里我提供<code>64</code>位的<code>Git 2.25.0</code>版本的 <a href="https://pan.baidu.com/s/1pAYF4SQDs2KF750rokTJgA">百度网盘</a> 供大家下载，提取码：<code>uzs6</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>双击安装包文件进行安装，自定义安装位置，其余保持默认一直<code>next</code>下去。</p><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，输入命令<code>git --version</code>，出现下图所示内容即表示安装成功。</p><p><img src="https://i.loli.net/2020/02/15/2RBSQYq6VMND5br.png" alt="git_version.png"></p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>全局配置用户名和邮箱，否则无法进行下一步的<code>SSH</code>公私钥配置。鼠标右击桌面空白处-&gt;选择<code>Git Bash Here</code>打开。分别输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>用户名可随意指定，一般是自己名字或简称，<code>git</code>提交代码到远程时会使用该名称。邮箱填自己喜欢的邮箱即可。</p><h2 id="SSH公私钥配置"><a href="#SSH公私钥配置" class="headerlink" title="SSH公私钥配置"></a><code>SSH</code>公私钥配置</h2><ol><li>鼠标右击桌面空白处-&gt;选择<code>Git Bash Here</code>打开。</li><li>使用<code>cd ~/.ssh</code>切换到公私钥目录。</li><li>执行命令<code>ssh-keygen -t rsa</code>生成公私钥，回车<code>3</code>次（这里回车会让你输入一些配置，比如密码，如果设置了密码则每次使用<code>git</code>命令都会要求输入密码，不推荐），会在<code>C:\Users\Administrator\.ssh</code>目录下生成一个私钥<code>id_rsa</code>和一个公钥<code>id_rsa.pub</code>。</li></ol><h2 id="Gitlab配置"><a href="#Gitlab配置" class="headerlink" title="Gitlab配置"></a><code>Gitlab</code>配置</h2><p>上述配置完成之后即可在全球最大的开源项目托管平台<code>Github</code>上进行代码版本控制。</p><p>但一般企业都会有自己的<code>Gitlab</code>代码托管平台，这时如果没有在<code>Gitlab</code>上配置公私钥则不能上传/下载代码。</p><p>登录企业的<code>Gitlab</code>平台-&gt;右上角个人头像-&gt;<code>Settings</code>-&gt;<code>SSH Keys</code>-&gt;粘贴<code>.ssh</code>文件夹下的<code>id_rsa.pub</code>公钥内容-&gt;确认添加。</p><p><img src="https://i.loli.net/2020/02/15/g6BT2HSfZOLaWnV.png" alt="add_ssh_pub_key.png"></p><p>配置完成后即可在企业的<code>Gitlab</code>平台上传/下载代码。</p>]]></content>
      
      
      <categories>
          
          <category> 安装配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下IntelliJ IDEA 2019.3.2安装和常用配置</title>
      <link href="2020/02/07/installed/install-idea/"/>
      <url>2020/02/07/installed/install-idea/</url>
      
        <content type="html"><![CDATA[<p>以下教程基于<code>windows 10</code>和<code>IntelliJ IDEA 2019.3.2</code>。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="https://www.jetbrains.com/idea/download/#section=windows">IntelliJ IDEA官网</a> 下载最新安装包。</p><p>这里我提供 <a href="https://pan.baidu.com/s/14P-cczbbA-o8N6CdCsQe6w">百度云盘</a> 供大家下载，提取码：<code>v9oj</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>双击<code>.exe</code>安装文件-&gt;<code>Next</code>-&gt;指定安装路径（可直接填写，不存在会自动创建）-&gt;<code>Next</code>-&gt;<code>Next</code>-&gt;<code>Install</code>；等待安装完成。</p></li><li><p>勾选<code>Run IntelliJ IDEA</code>-&gt;<code>Finish</code></p></li><li><p><code>Do not import settings</code>-&gt;<code>OK</code>-&gt;勾选<code>I confirm that...</code>-&gt;<code>Continue</code>-&gt;<code>Don&#39;t Send</code></p></li><li><p>选择界面主题-&gt;<code>Next: Default plugins</code>-&gt;<code>Next: Featured plugins</code>-&gt;<code>Start using IntelliJ IDEA</code>（这一系列推荐按默认配置）</p></li><li><p><code>Evaluate for free</code>-&gt;<code>Evaluate</code>-&gt;<code>Continue</code></p></li></ul><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>由于法律关系，请大家尽量支持正版。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>点击<code>File</code>-&gt;<code>Close Project</code>，关闭主界面进入选择项目窗口（这样设置是全局设置，而不是单对于某个项目设置）。</p><p>点击右下角<code>Configure</code>-&gt;<code>Settings</code>，打开设置面板。</p><h3 id="设置每次打开都是选择项目界面。"><a href="#设置每次打开都是选择项目界面。" class="headerlink" title="设置每次打开都是选择项目界面。"></a>设置每次打开都是选择项目界面。</h3><p><code>Appearance &amp; Behavior</code>-&gt;<code>System Settings</code>-&gt;取消勾选<code>Reopen last project on startup</code></p><p><img src="https://i.loli.net/2020/02/15/ARP29OHgBo7cfdb.png" alt="show_project_select.png"></p><h3 id="取消自动检查更新。"><a href="#取消自动检查更新。" class="headerlink" title="取消自动检查更新。"></a>取消自动检查更新。</h3><p><code>Appearance &amp; Behavior</code>-&gt;<code>System Settings</code>-&gt;<code>Updates</code>-&gt;取消勾选<code>Automatically check updates for</code></p><h3 id="设置鼠标放到类或方法上自动显示注释文档。"><a href="#设置鼠标放到类或方法上自动显示注释文档。" class="headerlink" title="设置鼠标放到类或方法上自动显示注释文档。"></a>设置鼠标放到类或方法上自动显示注释文档。</h3><p><code>Editor</code>-&gt;<code>General</code>-&gt;勾选<code>Show quick documentation on mouse move</code></p><p>可在下方设置显示的延迟毫秒数<code>Tooltip delay</code></p><h3 id="设置字体和字体大小"><a href="#设置字体和字体大小" class="headerlink" title="设置字体和字体大小"></a>设置字体和字体大小</h3><p><code>Editor</code>-&gt;<code>Font</code></p><h3 id="设置创建Java类时的头部注释模板。"><a href="#设置创建Java类时的头部注释模板。" class="headerlink" title="设置创建Java类时的头部注释模板。"></a>设置创建<code>Java</code>类时的头部注释模板。</h3><p><code>Editor</code>-&gt;<code>File and Code Templates</code>-&gt;<code>Includes</code>-&gt;<code>File Header</code></p><p>右侧输入注释模板，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author sunchaser</span><br><span class="line"> * @date $&#123;DATE&#125;</span><br><span class="line"> * @description</span><br><span class="line"> * @since 1.0</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="设置文件编码字符集。"><a href="#设置文件编码字符集。" class="headerlink" title="设置文件编码字符集。"></a>设置文件编码字符集。</h3><p><code>Editor</code>-&gt;<code>File Encodings</code></p><p>统一选择<code>UTF-8</code>/<code>with NO BOM</code>。</p><h3 id="设置Git及GitHub。"><a href="#设置Git及GitHub。" class="headerlink" title="设置Git及GitHub。"></a>设置<code>Git</code>及<code>GitHub</code>。</h3><p><code>Version Control</code>-&gt;<code>Git</code>/<code>GitHub</code></p><p>选择<code>Git</code>安装目录下的<code>bin\git.exe</code>文件。有关<code>Git</code>的安装配置，可参考 <a href="/2020/02/07/installed/install-git/">这篇文章</a></p><p>输入用户名/密码登录<code>GitHub</code>。</p><h3 id="设置Maven。"><a href="#设置Maven。" class="headerlink" title="设置Maven。"></a>设置<code>Maven</code>。</h3><p><code>Build,Execution,Deployment</code>-&gt;<code>Build Tools</code>-&gt;<code>Maven</code></p><p>选择<code>Maven home directory</code>为我们自己安装的<code>Maven</code>目录，点击<code>Override</code>覆盖默认的<code>User settings file</code>和<code>Local repository</code>。</p><p>有关<code>Maven</code>的安装和配置，可参考 <a href="/2020/02/07/installed/install-maven/">这篇文章</a> 。</p><p><code>Build,Execution,Deployment</code>-&gt;<code>Build Tools</code>-&gt;<code>Maven</code>-&gt;<code>Importing</code>/<code>Runner</code></p><p>选择<code>JDK for importer</code>/<code>JRE</code>为<code>Use JAVA_HOME</code></p><h3 id="设置序列化UID生成快捷键"><a href="#设置序列化UID生成快捷键" class="headerlink" title="设置序列化UID生成快捷键"></a>设置序列化<code>UID</code>生成快捷键</h3><p>设置实现了<code>Serializable</code>序列化接口的类中未定义<code>serialVersionUID</code>属性时类名处报黄色警告，按快捷键<code>alt</code>+<code>enter</code>有快捷生成序列化<code>UID</code>的选项。</p><p><code>Editor</code>-&gt;<code>Inspections</code></p><p>搜索<code>Serializable</code>，找到<code>Serializable class without &#39;serialVersionUID&#39;</code>，右侧进行勾选。</p><p><img src="https://i.loli.net/2020/02/15/u5Cjxqkdo79TDFr.jpg" alt="serializable.png"></p><p>所有设置完成后点击右下角<code>Apply</code>-&gt;<code>OK</code>，完成设置。</p>]]></content>
      
      
      <categories>
          
          <category> 安装配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下JDK安装及环境变量配置</title>
      <link href="2020/02/07/installed/install-jdk/"/>
      <url>2020/02/07/installed/install-jdk/</url>
      
        <content type="html"><![CDATA[<p>由于<code>JDK</code>开始收费，现在大多数企业使用的<code>Java</code>版本是<code>Java8</code>或者以下，<code>Java8</code>的使用者居多。我们在学习或开发中，下载<code>Java8</code>就足够使用了。</p><h2 id="下载JDK安装包"><a href="#下载JDK安装包" class="headerlink" title="下载JDK安装包"></a>下载<code>JDK</code>安装包</h2><p>可前往 <a href="https://www.oracle.com/technetwork/java/javase/documentation/8u-relnotes-2225394.html">Oracle官网</a> 下载。</p><p>这里我分享 <a href="https://pan.baidu.com/s/10_chUokZGwpcoCA-nGADOQ">百度云盘</a> 供大家下载，提取码：<code>5mxh</code>。</p><h2 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h2><p>双击运行<code>.exe</code>后缀文件，运行安装程序，注意下图所示地方，去除公共<code>JRE</code>的安装，点击左侧的小图标选择此功能将不可用。点击开发工具更改安装路径，继续下一步直至完成安装即可。</p><p><img src="https://i.loli.net/2020/02/15/nafVXGuSYeIFr8o.png" alt="java-jre.png"></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p><p>在系统变量处点击新建，输入变量名：<code>JAVA_HOME</code>，变量值为上述<code>JDK</code>安装步骤中更改的安装路径，点击确定。</p><p><img src="https://i.loli.net/2020/02/15/WcE1fDZLtdYCgm5.png" alt="java_home.png"></p><p>选中系统<code>Path</code>变量，点击编辑-&gt;新建，输入<code>%JAVA_HOME%\bin\</code>，点击确定。</p><p><img src="https://i.loli.net/2020/02/15/RShbVoiKCfFg7nI.png" alt="java_home_path.png"><br><img src="https://i.loli.net/2020/02/15/GFevdKUXnPjZ8tO.png" alt="java_home_path_bin.png"></p><p>最后一直确定下去至窗口关闭即可。</p><h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，输入命令<code>java -version</code>，出现下图所示内容即表示配置成功。</p><p><img src="https://i.loli.net/2020/02/15/c6OCkniZS8IprxU.png" alt="java_version.png"></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>网上很多老的教程还需要配置<code>CLASSPATH</code>变量，这个是<code>JDK</code>的历史原因，现在<code>JDK</code>目录下已包含专用的<code>JRE</code>，无需再进行额外配置。</p>]]></content>
      
      
      <categories>
          
          <category> 安装配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下Maven安装及配置</title>
      <link href="2020/02/07/installed/install-maven/"/>
      <url>2020/02/07/installed/install-maven/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="http://maven.apache.org/download.cgi/">Maven官网</a> 下载<code>Binary zip archive</code>最新压缩包。</p><p>这里我提供 <a href="https://pan.baidu.com/s/1QMUbAxNFTKTPwktK1-v1qg">百度云盘</a> 供大家下载，提取码：<code>olx2</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>maven</code>为绿色安装，下载完成后解压至自定义目录即可。</p><p>注意：解压路径不要包含中文。</p><h2 id="安装文件简介"><a href="#安装文件简介" class="headerlink" title="安装文件简介"></a>安装文件简介</h2><p>解压目录包含<code>4</code>个文件夹<code>bin/boot/conf/lib</code>，其存放的文件分别为：</p><ul><li><code>bin</code>：<code>maven</code>的一些可执行程序。</li><li><code>boot</code>：一些启动引导程序，例如类加载器等。</li><li><code>conf</code>：配置文件。</li><li><code>lib</code>：<code>maven</code>自身运行依赖的库。</li></ul><h2 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置<code>maven</code></h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p><p>在系统变量处点击新建，输入变量名：<code>MAVEN_HOME</code>，变量值上述<code>maven</code>的解压目录，点击确定。</p><p><img src="https://i.loli.net/2020/02/15/Trs4I5pO7ZhlxQk.png" alt="maven_home.png"></p><p>选中系统<code>Path</code>变量，点击编辑-&gt;新建，输入<code>%MAVEN_HOME%\bin\</code>，点击确定。</p><p><img src="https://i.loli.net/2020/02/15/pmsHLowja4OdWDu.png" alt="maven_home_path.png"><br><img src="https://i.loli.net/2020/02/15/NcxXsZK68laoOfm.png" alt="maven_home_path_bin.png"></p><p>最后一直确定下去至窗口关闭即可。</p><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，输入命令<code>mvn -v</code>，出现下图所示内容即表示配置成功。</p><p><img src="https://i.loli.net/2020/02/15/meD3iLrZOnCNpyz.png" alt="mvn_v.png"></p><h3 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h3><p>新建一个自定义目录<code>repository</code>作为本地仓库，一般和<code>Maven</code>的解压目录在同级。</p><p>然后在<code>Maven</code>的安装目录下找到<code>conf</code>目录下的<code>settings.xml</code>配置文件，用文本编辑器打开，找到大概第<code>55</code>行的位置，输入以下标签指定本地仓库的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;E:\develop\maven\repository&lt;&#x2F;localRepository&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/15/nAo7qkhJQZgEOjy.png" alt="local_repository.png"></p><p>根据个人安装位置输入仓库路径。</p><h3 id="配置阿里云镜像仓库"><a href="#配置阿里云镜像仓库" class="headerlink" title="配置阿里云镜像仓库"></a>配置阿里云镜像仓库</h3><p><img src="https://i.loli.net/2020/02/15/81W7sY9LOk5T6XD.jpg" alt="aliyun_mirror.png"></p><p>在<code>settings.xml</code>文件大约<code>160</code>行的地方，输入以下内容配置阿里云<code>Maven</code>镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个是配置阿里Maven镜像 --&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">  &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<code>Maven</code>的配置就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 安装配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下Node.js安装与配置</title>
      <link href="2020/02/07/installed/install-nodejs/"/>
      <url>2020/02/07/installed/install-nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可从 <a href="https://nodejs.org/zh-cn/">Node.js中文官网</a> 下载最新长期支持版安装包。</p><p>这里我提供<code>12.15.0</code>长期支持版 <a href="https://pan.baidu.com/s/1GQZYcUpMsBBA0nU20CJplg">百度云盘</a> 供大家下载，提取码：<code>itoe</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>双击安装包文件进行安装，自定义安装位置，其余保持默认一直<code>next</code>下去。</p><p>按下<code>win+R</code>键，输入<code>cmd</code>，回车，分别输入命令<code>node -v</code>和<code>npm -v</code>，出现下图所示内容即表示安装成功。</p><p><img src="https://i.loli.net/2020/02/15/cEe7vjnkqC9m8Ol.png" alt="node_npm_v.png"></p><p>说明：新版本<code>Node.js</code>自带<code>npm</code>，安装<code>Node.js</code>时会一起安装，<code>npm</code>是<code>Node.js</code>的依赖包管理工具，可大致理解成<code>maven</code>/<code>Composer</code>等。</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>在执行类似：<code>npm install express [-g]</code> （后面的可选参数<code>-g</code>，<code>g</code>代表<code>global</code>全局安装的意思）的安装语句时，默认会将安装的模块安装到<code>C:\Users\用户名\AppData\Roaming\npm</code>路径中，占用<code>C</code>盘空间。</p><p>我们希望将全局模块路径和缓存路径放置在自定义目录（非C盘）中。这里我在<code>Node.js</code>安装目录下新建两个文件夹<code>node_global</code>和<code>node_cache</code>。如下图：</p><p><img src="https://i.loli.net/2020/02/15/3Ccqt2zyMBjxPVH.png" alt="node_global_cache.png"></p><p>空文件夹创建完成后，按下<code>win+R</code>键，输入<code>cmd</code>，回车，分别输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\develop\nodejs\node_global&quot;</span><br><span class="line"></span><br><span class="line">npm config set cache &quot;E:\develop\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>鼠标右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量</p><p>在系统变量处点击新建，输入变量名：<code>NODE_HOME</code>，变量值为<code>E:\develop\nodejs\node_global\node_modules</code>：上述全局配置中的<code>node_global</code>路径后再加一个<code>node_modules</code>文件夹（不用手动创建），点击确定。</p><p><img src="https://i.loli.net/2020/02/15/tshAB4IbjM6FuZC.png" alt="node_home.png"></p><p>选中用户变量<code>Path</code>，点击编辑，将默认的<code>C:\Users\用户名\AppData\Roaming\npm</code>改为<code>E:\develop\nodejs\node_global</code>：上述全局配置中的<code>node_global</code>，点击确定。</p><p><img src="https://i.loli.net/2020/02/15/OfKmAPBJXRbyVsd.png" alt="user_node_path.png"></p><p>最后一直确定下去至所有窗口关闭即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，删除默认的<code>C:\Users\lilu\AppData\Roaming\npm</code>文件夹。</p><p>至此<code>Node.js</code>的安装和配置就已完成，可使用<code>npm install -g</code>命令下载任意<code>js</code>依赖检验是否将包下载至了我们指定的路径下。</p>]]></content>
      
      
      <categories>
          
          <category> 安装配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装Windows10系统</title>
      <link href="2020/02/07/installed/install-windows10/"/>
      <url>2020/02/07/installed/install-windows10/</url>
      
        <content type="html"><![CDATA[<ol><li><p>制作重装启动<code>U</code>盘，推荐 <a href="http://www.bigbaicai.com/">大白菜</a> U盘制作工具。</p></li><li><p>下载<code>win10</code>镜像文件，一般去 <a href="https://msdn.itellyou.cn/">MSDN我告诉你</a> 下载。大家都是<code>64</code>位的<code>CPU</code>，你应该下载<code>64</code>位版本的镜像。</p></li><li><p>百度搜索对应机型U盘启动快捷键，进行重装。</p></li><li><p>重装系统启动过程中有一些可选配置项，一般都不勾选，没有必要。在创建用户界面请使用脱机账户登录，脱机账户可手动设置用户名。不要使用<code>outlook</code>邮箱登录，原因是使用<code>outlook</code>邮箱登录的话，由于用户名设置规则，只会取邮箱的前五个字符，作为微软用户绑定的系统管理员用户名。可能会造成<code>C:\Users</code>目录下的用户名不是你想要的。重装完成后再到设置中使用<code>outlook</code>邮箱登录即可。这样系统用户名就是我们自定义的名称。</p></li><li><p>重装完成后系统会自动进行一些基本设置，然后进入桌面会提示等待系统部署完成。这时等待一会即可。一般会安装一些第三方软件，例如<code>360</code>/爱奇艺/淘宝等，大可不必觉得“恶心”，稍后我们会进行清理。</p></li><li><p>一般<code>win10</code>系统安装完成后桌面上没有我的电脑/控制面板等图标，只有一个回收站。可以鼠标右键点击桌面空白处-&gt;个性化设置-&gt;主题-&gt;相关的设置（桌面图标设置），勾选计算机/控制面板等，点击确定即可。这时发现桌面图标排列顺序有点不好，可鼠标右键点击刷新桌面，如果还不行则鼠标右键点击桌面空白处-&gt;排序方式-&gt;名称，重复两遍即可。</p></li><li><p>激活<code>Windows</code>，建议在某宝购买支持重装的激活码，一次购买，多次使用。不推荐使用第三方激活工具激活。</p></li><li><p>开始清理系统初始第三方软件，可利用自动安装的<code>360</code>软件管家，卸载这些应用。最后在卸载<code>360</code>。在卸载应用时注意勾选删除在本机保存的个人配置数据等类似选项。</p></li><li><p>点击开始菜单，在左侧菜单和动态磁贴中一般会有一些没什么用的<code>Windows</code>应用，例如一些游戏等，如果不需要<code>office</code>等也可以进行卸载。点击鼠标右键即有卸载按钮。</p></li><li><p>这时系统基本清理完成，但还是会有一些残留文件夹存在，进入<code>C:/Program Files (x86)</code>目录，如果看到一些<code>360/tencent</code>等文件夹可直接删除，如果提示操作无法完成，因为其中的文件夹或文件已在另一程序中打开，则可先放着，等将其它类似文件夹删除后，稍后重启电脑即可删除。</p></li><li><p>打开我的电脑，点击上方查看，勾选文件扩展名/隐藏的项目。重启电脑，重启完成后即可删除上述所说无法删除的文件夹。</p></li><li><p>下面开始安装我们的个人软件，首先安装<code>360</code>。</p></li></ol><ul><li>为什么安装<code>360</code>？</li></ul><p>有些人觉得<code>360</code>是流氓软件，影响电脑运行速度，但我觉得<code>360</code>有些功能还是可以的，比如清理垃圾/禁止开机启动项等。</p><ul><li>为什么卸载系统安装完成后自带的<code>360</code>？</li></ul><p>因为自带的<code>360</code>安装在<code>C</code>盘，不好。去 <a href="https://www.360.cn/">360官网</a> 下载最新的安装包。双击安装包，选择自定义安装，选择安装路径为自定义盘（非<code>C</code>盘）。</p><ul><li>进行清理优化</li></ul><p>安装完成后打开<code>360</code>主界面，点击功能大全-&gt;我的工具，删除一些没用的自带工具。一般只留一个软件管家即可。点击电脑清理清理系统垃圾。勾选一些痕迹信息和<code>Cookie</code>信息等。点击优化加速禁用一些开机启动项。扫描完成后勾选一些需要优化的项，点击立即优化。</p><ul><li>安装驱动大师更新驱动</li></ul><p>在功能大全中搜索找到<code>360</code>驱动大师，点击安装，进行系统驱动更新。驱动大师会自动进行备份下载更新，备份的目录可在驱动大师的设置中指定，默认与<code>360</code>安装目录在同一盘符下。</p><p>驱动更新完成后重启电脑，重启后删除驱动大师。在<code>360</code>安全卫士中-&gt;功能大全-&gt;我的工具中删除驱动大师，可选择勾选删除已备份和下载的驱动。</p><ul><li>安装其它软件（可选）<ul><li><code>360</code>压缩：解压缩软件有很多选择，比如<code>WinR/7z</code>等，这里由于安装了<code>360</code>，选择<code>360</code>压缩即可。进入<code>360</code>安全卫士主界面-&gt;功能大全-&gt;搜索选择<code>360</code>压缩-&gt;点击进行安装-&gt;安装完成后会弹出主界面-&gt;点击右上角工具-&gt;设置-&gt;取消勾选常规中的开启自动升级/改善计划中的参与“<code>360</code>用户体验改善计划”-&gt;确定。对于右下角可能出现的弹窗，请点击弹窗右上角的<code>×</code>进行关闭。</li><li>搜狗输入法：前往 <a href="https://pinyin.sogou.com/">搜狗输入法官网</a> 下载最新安装包，下载完成后双击运行-&gt;选择自定义安装-&gt;选择安装目录-&gt;点击安装-&gt;取消勾选完成界面的一些捆绑安装的选项。安装完成后进行搜狗输入法的一些基本设置即可，搜狗输入法每天会在右下角弹出一个弹窗，不要点击不在提示，请点击右上角的<code>×</code>，不然会下载搜狗浏览器。</li><li>有道云笔记：前往 <a href="http://note.youdao.com/">有道云笔记官网</a> 下载最新安装包-&gt;双击运行-&gt;自定义安装-&gt;指定安装目录-&gt;取消勾选有道翻译安装。安装完成后进行登录，登录后点击右上角-&gt;设置，取消勾选启动<code>windows</code>时启动有道云笔记/自动检查客户端更新。默认情况下本地文件会保存在<code>C:\Users\用户名\AppData\Local\YNote</code>相关目录下，在安装时指定可能没有效果。如果想让本地文件不保存在<code>C</code>盘可在设置中进行指定，有道云笔记会自动进行数据迁移。</li><li>百度网盘：前往 <a href="https://pan.baidu.com/">百度云网盘官网</a> 下载最新安装包-&gt;双击运行-&gt;自定义安装-&gt;指定安装目录-&gt;完成后登录-&gt;进入主界面后点击右上角设置-&gt;取消勾选开机时启动百度网盘(推荐)。</li></ul></li></ul><p>至此，电脑重装系统基本完成，接下来就可以进行应用软件安装了。</p>]]></content>
      
      
      <categories>
          
          <category> 安装配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法重载Overload</title>
      <link href="2020/01/09/javase/base/method-overload/"/>
      <url>2020/01/09/javase/base/method-overload/</url>
      
        <content type="html"><![CDATA[<p>在日常生活中，相同的词可以表达多种不同的含义——它们被“重载了”。例如：“冬天能穿多少穿多少。夏天能穿多少穿多少。”、“中国足球谁也打不过。中国乒乓球谁也打不过。”。相同的名字但表达出了不同的含义，这就是方法重载。</p><h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>我们知道类的构造器名字必须与类名完全相同，不接受任何参数的构造器叫做默认构造器，同其它方法一样，构造器也能带有形式参数，以便指定如何创建对象。这里就体现了方法重载，它们都有相同的名字，即类名，但形式参数不同。</p><h2 id="区分方法重载"><a href="#区分方法重载" class="headerlink" title="区分方法重载"></a>区分方法重载</h2><p>如果有几个名字相同的方法，Java如何进行区分呢？</p><p>请记住方法重载的概念：方法名相同，但形参列表不同。</p><p>即使形参顺序不同也足以区分两个方法。但是最好别这样做，细想一下，如果只是参数顺序不同，有什么实际的意义呢？这样的重载也会让代码难以琢磨。</p><h2 id="基本数据类型的重载"><a href="#基本数据类型的重载" class="headerlink" title="基本数据类型的重载"></a>基本数据类型的重载</h2><h3 id="传入的实际参数范围小于重载方法声明的形式参数范围"><a href="#传入的实际参数范围小于重载方法声明的形式参数范围" class="headerlink" title="传入的实际参数范围小于重载方法声明的形式参数范围"></a>传入的实际参数范围小于重载方法声明的形式参数范围</h3><p>我们知道Java中有自动类型转换（隐式转换）的概念，基本数据类型能从一个范围“较小”的类型自动转换至一个范围“较大”的类型，此过程一旦涉及到方法重载，可能会造成一些混淆。</p><p>我们来进行一些测试。</p><p>foo1方法包含char/byte/short/int/long/float/double这7种基本数据类型的重载；</p><p>foo2方法包含byte/short/int/long/float/double这6种基本数据类型的重载；</p><p>foo3方法包含short/int/long/float/double这5种基本数据类型的重载；</p><p>foo4方法包含int/long/float/double这4种基本数据类型的重载；</p><p>foo5方法包含long/float/double这3种基本数据类型的重载；</p><p>foo6方法包含float/double这2种基本数据类型的重载；</p><p>foo7方法只有一个double类型参数的方法；</p><p>分别使用常量值6、char类型的’x’、byte类型的1、short类型的1、int类型的1、long类型的1、float类型的1和double类型的1分别调用foo系列的方法，观察输出结果。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.overload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 基本数据类型重载的测试：基本数据类型范围较小的会被自动类型转换（隐式转换）成范围较大的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基本数据类型（除去boolean）范围如下：</span></span><br><span class="line"><span class="comment"> * &#x27;[&#x27; 和 &#x27;]&#x27; 表示闭区间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * byte   |  8 bits | [-128, +127]</span></span><br><span class="line"><span class="comment"> * char   | 16 bits | [&#x27;\u0000&#x27;, &#x27;\uFFFF&#x27;]</span></span><br><span class="line"><span class="comment"> * short  | 16 bits | [-2^15, +2^15 - 1]</span></span><br><span class="line"><span class="comment"> * int    | 32 bits | [-2^31, +2^31 - 1]</span></span><br><span class="line"><span class="comment"> * float  | 32 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * double | 64 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * long   | 64 bits | [-2^63, +2^63 - 1]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallToBigDataTypeOverloadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * const: 6</span></span><br><span class="line"><span class="comment">     * foo1(int x)</span></span><br><span class="line"><span class="comment">     * foo2(int x)</span></span><br><span class="line"><span class="comment">     * foo3(int x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 常量值6被当做int值进行处理。如果没有int类型的重载方法，则自动类型转换成“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;const: 6&quot;</span>);</span><br><span class="line">        foo1(<span class="number">6</span>);</span><br><span class="line">        foo2(<span class="number">6</span>);</span><br><span class="line">        foo3(<span class="number">6</span>);</span><br><span class="line">        foo4(<span class="number">6</span>);</span><br><span class="line">        foo5(<span class="number">6</span>);</span><br><span class="line">        foo6(<span class="number">6</span>);</span><br><span class="line">        foo7(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * char: x</span></span><br><span class="line"><span class="comment">     * foo1(char x)</span></span><br><span class="line"><span class="comment">     * foo2(int x)</span></span><br><span class="line"><span class="comment">     * foo3(int x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 除foo1外，char类型的&#x27;x&#x27;被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     * 在foo2、foo3和foo4中，char类型被直接转换成了int类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;char: &quot;</span> + c);</span><br><span class="line">        foo1(c);</span><br><span class="line">        foo2(c);</span><br><span class="line">        foo3(c);</span><br><span class="line">        foo4(c);</span><br><span class="line">        foo5(c);</span><br><span class="line">        foo6(c);</span><br><span class="line">        foo7(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * byte: 1</span></span><br><span class="line"><span class="comment">     * foo1(byte x)</span></span><br><span class="line"><span class="comment">     * foo2(byte x)</span></span><br><span class="line"><span class="comment">     * foo3(short x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 除foo1和foo2外，byte类型的1被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte: &quot;</span> + b);</span><br><span class="line">        foo1(b);</span><br><span class="line">        foo2(b);</span><br><span class="line">        foo3(b);</span><br><span class="line">        foo4(b);</span><br><span class="line">        foo5(b);</span><br><span class="line">        foo6(b);</span><br><span class="line">        foo7(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * short: 1</span></span><br><span class="line"><span class="comment">     * foo1(short x)</span></span><br><span class="line"><span class="comment">     * foo2(short x)</span></span><br><span class="line"><span class="comment">     * foo3(short x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 除foo1、foo2和foo3外，short类型的1被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;short: &quot;</span> + s);</span><br><span class="line">        foo1(s);</span><br><span class="line">        foo2(s);</span><br><span class="line">        foo3(s);</span><br><span class="line">        foo4(s);</span><br><span class="line">        foo5(s);</span><br><span class="line">        foo6(s);</span><br><span class="line">        foo7(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * int: 1</span></span><br><span class="line"><span class="comment">     * foo1(int x)</span></span><br><span class="line"><span class="comment">     * foo2(int x)</span></span><br><span class="line"><span class="comment">     * foo3(int x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * foo5、foo6和foo7方法，int类型的1都被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;int: &quot;</span> + i);</span><br><span class="line">        foo1(i);</span><br><span class="line">        foo2(i);</span><br><span class="line">        foo3(i);</span><br><span class="line">        foo4(i);</span><br><span class="line">        foo5(i);</span><br><span class="line">        foo6(i);</span><br><span class="line">        foo7(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * long: 1</span></span><br><span class="line"><span class="comment">     * foo1(long x)</span></span><br><span class="line"><span class="comment">     * foo2(long x)</span></span><br><span class="line"><span class="comment">     * foo3(long x)</span></span><br><span class="line"><span class="comment">     * foo4(long x)</span></span><br><span class="line"><span class="comment">     * foo5(long x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * foo6和foo7方法，long类型的1L被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">1L</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;long: &quot;</span> + l);</span><br><span class="line">        foo1(l);</span><br><span class="line">        foo2(l);</span><br><span class="line">        foo3(l);</span><br><span class="line">        foo4(l);</span><br><span class="line">        foo5(l);</span><br><span class="line">        foo6(l);</span><br><span class="line">        foo7(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * float: 1.0</span></span><br><span class="line"><span class="comment">     * foo1(float x)</span></span><br><span class="line"><span class="comment">     * foo2(float x)</span></span><br><span class="line"><span class="comment">     * foo3(float x)</span></span><br><span class="line"><span class="comment">     * foo4(float x)</span></span><br><span class="line"><span class="comment">     * foo5(float x)</span></span><br><span class="line"><span class="comment">     * foo6(float x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * foo7方法中，float类型的1F被自动类型转换成了“较大”的类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">1F</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;float: &quot;</span> + f);</span><br><span class="line">        foo1(f);</span><br><span class="line">        foo2(f);</span><br><span class="line">        foo3(f);</span><br><span class="line">        foo4(f);</span><br><span class="line">        foo5(f);</span><br><span class="line">        foo6(f);</span><br><span class="line">        foo7(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * double: 1.0</span></span><br><span class="line"><span class="comment">     * foo1(double x)</span></span><br><span class="line"><span class="comment">     * foo2(double x)</span></span><br><span class="line"><span class="comment">     * foo3(double x)</span></span><br><span class="line"><span class="comment">     * foo4(double x)</span></span><br><span class="line"><span class="comment">     * foo5(double x)</span></span><br><span class="line"><span class="comment">     * foo6(double x)</span></span><br><span class="line"><span class="comment">     * foo7(double x)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1D</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;double: &quot;</span> + d);</span><br><span class="line">        foo1(d);</span><br><span class="line">        foo2(d);</span><br><span class="line">        foo3(d);</span><br><span class="line">        foo4(d);</span><br><span class="line">        foo5(d);</span><br><span class="line">        foo6(d);</span><br><span class="line">        foo7(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo1 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo2 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo3 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo4 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo5 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo5(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo5(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo5(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo6 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo6(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo6(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo7 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo7</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo7(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现常量值6被foo1/foo2/foo3/foo4方法当做int值进行处理，foo5/foo6/foo7没有int类型的重载方法，被自动类型转换成了“较大”的类型（long/float/double）。</p><p>对于char类型的’x’，foo1方法包含对应类型的重载，剩余6种方法不包含char类型的重载，但foo2/foo3/foo4直接将char类型自动类型转换成了int类型。foo5/foo6/foo7分别将char类型隐式转换成了long/float/double类型。</p><blockquote><p>char类型是不会被自动类型转换成byte/short类型的。其原因可查看这篇文章：<a href="/2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/">传送门</a></p></blockquote><p>对于byte类型的1，foo1/foo2方法包含对应类型的重载；剩余5种方法不包含char类型的重载，被分别隐式转换成了short/int/long/float/double类型。</p><p>对于short类型的1，foo1/foo2/foo3方法包含对应类型的重载；剩余4种方法不包含short类型的重载，被分别隐式转换成了int/long/float/double类型。</p><p>对于int类型的1，foo1/foo2/foo3/foo4方法包含对应类型的重载；foo5/foo6/foo7不包含int类型的重载，被分别隐式转换成了long/float/double类型。</p><p>对于long类型的1，foo1/foo2/foo3/foo4/foo5方法包含对应类型的重载；foo6/foo7不包含long类型的重载，被分别隐式转换成了float/double类型。</p><p>对应float类型的1，foo7不包含float类型的重载，被隐式转换成了double类型；而其它6种方法包含对应类型的重载。</p><p>对于double类型的1,7种方法都有对应类型的重载。</p><p>数值基本类型隐式转换图如下：</p><p><img src="https://i.loli.net/2020/02/15/OeS472iBMyCUz9n.png" alt="basic-data-type-conversion.png"></p><p>实线箭头无精度丢失，虚线箭头可能丢失精度。</p><h3 id="传入的实际参数范围大于重载方法声明的形式参数范围"><a href="#传入的实际参数范围大于重载方法声明的形式参数范围" class="headerlink" title="传入的实际参数范围大于重载方法声明的形式参数范围"></a>传入的实际参数范围大于重载方法声明的形式参数范围</h3><p>反过来，如果传入的实际参数范围大于重载方法声明的形式参数，会是什么情况呢？我们再来测试一下。</p><p>foo1方法包含char/byte/short/int/long/float/double这7种基本数据类型的重载；</p><p>foo2方法包含char/byte/short/int/long/float这6种基本数据类型的重载；</p><p>foo3方法包含char/byte/short/int/long这5种基本数据类型的重载；</p><p>foo4方法包含char/byte/short/int这4种基本数据类型的重载；</p><p>foo5方法包含char/byte/short这3种基本数据类型的重载；</p><p>foo6方法包含char/byte这2种基本数据类型的重载；</p><p>foo7方法只有一个char类型参数的方法；</p><p>使用double类型的3.1415926分别调用foo系列的方法。我们可以看到编译器提示了错误：<code>Cannot resolve method &#39;foo2(double)&#39;</code>等。除了foo1方法外，其余foo系列的方法都不包含double类型的重载，编译器也不会隐式将double类型自动转换成其它基本类型，其原因在于double类型的取值范围（二进制位数）是最大的，如果将double类型的数据隐式转换成其它基本类型，可能会出现精度丢失的问题，这是有风险的，编译器不会自动帮我们做。</p><p>我们需要强制类型转换（显式转换）进行窄化处理，这样做可能会丢失精度。但如果不这样做，我们无法正常进行方法的调用。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.javase.base.overload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/1/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 基本数据类型重载的测试：基本数据类型范围较大的需要强制类型转换（显式转换）进行窄化处理，转换成范围较小的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基本数据类型（除去boolean）范围如下：</span></span><br><span class="line"><span class="comment"> * &#x27;[&#x27; 和 &#x27;]&#x27; 表示闭区间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * byte   |  8 bits | [-128, +127]</span></span><br><span class="line"><span class="comment"> * char   | 16 bits | [&#x27;\u0000&#x27;, &#x27;\uFFFF&#x27;]</span></span><br><span class="line"><span class="comment"> * short  | 16 bits | [-2^15, +2^15 - 1]</span></span><br><span class="line"><span class="comment"> * int    | 32 bits | [-2^31, +2^31 - 1]</span></span><br><span class="line"><span class="comment"> * float  | 32 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * double | 64 bits | IEEE754范围</span></span><br><span class="line"><span class="comment"> * long   | 64 bits | [-2^63, +2^63 - 1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigToSmallDataTypeOverloadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * double: 3.1415926</span></span><br><span class="line"><span class="comment">     * foo1(double x)</span></span><br><span class="line"><span class="comment">     * foo2(float x)</span></span><br><span class="line"><span class="comment">     * foo3(long x)</span></span><br><span class="line"><span class="comment">     * foo4(int x)</span></span><br><span class="line"><span class="comment">     * foo5(short x)</span></span><br><span class="line"><span class="comment">     * foo6(byte x)</span></span><br><span class="line"><span class="comment">     * foo7(char x)</span></span><br><span class="line"><span class="comment">     * (float) d：3.1415925  // 可看到精度已经丢失</span></span><br><span class="line"><span class="comment">     * (long) d：3</span></span><br><span class="line"><span class="comment">     * (int) d：3</span></span><br><span class="line"><span class="comment">     * (short) d：3</span></span><br><span class="line"><span class="comment">     * (byte) d：3</span></span><br><span class="line"><span class="comment">     * (char) d：3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;double: &quot;</span> + d);</span><br><span class="line">        foo1(d);</span><br><span class="line">        foo2((<span class="keyword">float</span>) d);</span><br><span class="line">        foo3((<span class="keyword">long</span>) d);</span><br><span class="line">        foo4((<span class="keyword">int</span>) d);</span><br><span class="line">        foo5((<span class="keyword">short</span>) d);</span><br><span class="line">        foo6((<span class="keyword">byte</span>) d);</span><br><span class="line">        foo7((<span class="keyword">char</span>) d);</span><br><span class="line">        <span class="keyword">float</span> f = (<span class="keyword">float</span>) d;</span><br><span class="line">        System.out.println(<span class="string">&quot;(float) d：&quot;</span> + f);</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">long</span>) d;</span><br><span class="line">        System.out.println(<span class="string">&quot;(long) d：&quot;</span> + l);</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) d;</span><br><span class="line">        System.out.println(<span class="string">&quot;(int) d：&quot;</span> + i);</span><br><span class="line">        <span class="keyword">short</span> s = (<span class="keyword">short</span>) d;</span><br><span class="line">        System.out.println(<span class="string">&quot;(short) d：&quot;</span> + s);</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) d;</span><br><span class="line">        System.out.println(<span class="string">&quot;(byte) d：&quot;</span> + b);</span><br><span class="line">        <span class="keyword">char</span> c = (<span class="keyword">char</span>) d;</span><br><span class="line">        System.out.println(<span class="string">&quot;(char) d：&quot;</span> + (c + <span class="number">1</span> - <span class="number">1</span>)); <span class="comment">// 查看char表示的数值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo1 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo1(double x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo2 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo2(float x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo3 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo3(long x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo4 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo4(int x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo5 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo5(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo5(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo5</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo5(short x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo6 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo6(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo6</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo6(byte x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*==========================foo7 Overload===========================*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo7</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo7(char x)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果中可看到：double类型的3.1415926强制转换成float时变成了3.1415925，精度已经丢失；而强制转换成long/int/short/byte/char时浮点部分直接被舍弃。</p><h2 id="返回值能区分重载方法吗？"><a href="#返回值能区分重载方法吗？" class="headerlink" title="返回值能区分重载方法吗？"></a>返回值能区分重载方法吗？</h2><p>例如有下面两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>我们人用肉眼去看方法的声明很容易分辨这两个同名方法的不同之处。但是当我们去调用foo方法时，如果我们的调用方式是：<code>int x = foo()</code>，那么的确可以明确我们调用的是<code>int foo() &#123;return -1;&#125;</code>；但有时候我们并不在意返回值（只是调用方法去执行某个操作），调用方式为：<code>foo()</code>，这时候Java如何才能判断调用的是哪一个<code>foo()</code>呢？程序员又该如何理解这种代码呢？因此，返回值是不能区分方法重载的。</p><h2 id="int和Integer的形参是重载方法吗？"><a href="#int和Integer的形参是重载方法吗？" class="headerlink" title="int和Integer的形参是重载方法吗？"></a>int和Integer的形参是重载方法吗？</h2><p>例如有下面两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Integer y)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Integer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们是重载方法吗？</p><p>即使int和Integer之间存在自动装箱/拆箱操作，但它们仍是重载的方法。</p><p>我们传递int类型的变量给foo，编译器并不会进行装箱操作，因为有对应的int类型重载方法；相应地，我们传递Integer类型的变量给foo，编译器不会进行拆箱操作，而是调用对应Integer类型的重载方法。</p><p>我们传递字面量1给foo方法，编译器会默认当成基本类型int调用foo。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * int</span></span><br><span class="line"><span class="comment"> * int</span></span><br><span class="line"><span class="comment"> * Integer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字面量值1是int基本数据类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 是重载方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    foo(x);</span><br><span class="line">    Integer y = <span class="number">1</span>;</span><br><span class="line">    foo(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是方法重载Overload的全部内容，完整示例代码地址见：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/JavaSE/src/main/java/com/sunchaser/javase/base/overload">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型char为什么不会被隐式转换成byte或short类型？</title>
      <link href="2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/"/>
      <url>2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/</url>
      
        <content type="html"><![CDATA[<p>Java的基本数据类型中的数值类型包括：byte/char/short/int/float/double/long</p><p>其数值范围如下表所示：</p><table><thead><tr><th>基本类型</th><th align="center">大小</th><th align="left">范围</th></tr></thead><tbody><tr><td>byte</td><td align="center">8 bits</td><td align="left">[-128, +127]</td></tr><tr><td>char</td><td align="center">16 bits</td><td align="left">[‘\u0000’, ‘\uFFFF’] 即 [0, 2^16 - 1]</td></tr><tr><td>short</td><td align="center">16 bits</td><td align="left">[-2^15, +2^15 - 1]</td></tr><tr><td>int</td><td align="center">32 bits</td><td align="left">[-2^31, +2^31 - 1]</td></tr><tr><td>float</td><td align="center">32 bits</td><td align="left">IEEE754范围</td></tr><tr><td>double</td><td align="center">64 bits</td><td align="left">IEEE754范围</td></tr><tr><td>long</td><td align="center">64 bits</td><td align="left">[-2^63, +2^63 - 1]</td></tr></tbody></table><p>注：表格中的 ‘[‘ 和 ‘]’ 表示闭区间；IEEE754范围参考<a href="https://en.wikipedia.org/wiki/IEEE_754-1985">wiki</a></p><p>char类型的表示范围可通过以下代码查看：0-65535</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Character.MIN_VALUE + 1 - 1);</span><br><span class="line">System.out.println(Character.MAX_VALUE + 1 - 1);</span><br></pre></td></tr></table></figure><p>byte类型只占一个字节（8比特），而char和short都占两个字节。char转成byte会出现装不下的情况，精度丢失，所以编译器不会自动进行隐式转换；</p><p>short类型虽然占两个字节，但其最大值是2^15-1，char的最大值是2^16-1，会出现转换不了的情况，所以编译器也不会进行隐式转换。</p><p>int类型是第一个数值范围比char大的类型，所以在涉及到隐式转换时，Java默认将char隐式转换成int。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年度总结</title>
      <link href="2019/12/31/annual-summary/2019/"/>
      <url>2019/12/31/annual-summary/2019/</url>
      
        <content type="html"><![CDATA[<p>2019是日无暇晷的一年。</p><p>从年初的大四准毕业生到现在半年经验的职场少年，一路走来，从技术菜鸟到小有成就，从稚嫩到沉稳，这是成长的印记。</p><p>2019前3个月是艰难的。犹记得2018年9月秋招经历过的恐惧，大三时“听信了”大学老师的谗言：PHP是世界上最好的语言。大三一整年都在学习PHP，某马程序员官网放出的PHP视频教程看了80%多。但现实终究是残酷的，国内大部分企业后端都还是以Java语言为主（别跟我讲百度用PHP）。秋招的PHP岗位实在是太少了，加上我只是一个双非普通一本学历，又没有什么拿得出手的获奖证书，根本就没有一点竞争力。于是修改了简历，项目经验写上了大学Java Web课程设计写的JSP+Servlet项目，就开始转向投递Java岗。</p><p>终于过了一家深圳互联网公司的笔试，来到面试阶段，跟面试官聊了一下大三学PHP的事情，然后开始问技术方面的问题，现在回想起来，当时的问题算得上是非常基础的知识点了。例如：int和Integer的区别？int和Integer作为同名方法的参数，算不算重载？</p><p>这是我的第一次Java面试，面试过程中满怀信心觉得自己都答对了，面试出来后查了下百度，发现好像一个都没答对。“电子竞技，菜是原罪”。</p><p>当时深刻认识到凭当时的自身技术能力想找Java开发的岗位几乎是不可能的，于是做了一个很果断的决定，停止投递简历，系统学习Java知识体系，等待春招。</p><p>某北大学计算机学院的学生宿舍在校外（俗称“三期”公寓），没有独卫，没有空调，六人间。自学是很考验人的，那个时候刚转向Java，疯狂的找学习资料，某马程序员，某硅谷，某学堂，某客网，某宝…几乎所有的免费视频教程我都下载了。面对几十个G的资源，我陷入了迷茫，该从何学起呢？</p><p>那个时候我的知识体系基本是一片空白，只有大学的Java基础课程和J2EE课程学的一点知识储备。听了同学的建议后，决定从某客网高级项目课开始学起，跟随项目需求，对项目中用到的知识点，技术框架进行细致学习。然而一切都是艰难的，这个项目用的技术栈主要是Spring Boot、Mybatis等，对于当时连Spring都不知道的我，实在是太难了。</p><p>于是我打开了某马程序员的Spring入门到精通视频，从传统的Java Web到引入DI/IOC，大概能听懂一点，我开始打开IDE对着视频敲代码，经常一个视频重复播放三遍甚至更多，第一遍是听大概的内容，第二遍是细听，然后跟着敲代码，第三遍是总结性的听，做一些笔记。</p><p>但是我发现，我对Java语言的一些基础性的语法和概念还不是太熟悉，于是我打开了2018年双十一买的《Java编程思想》，开始了解Java语言的一些特性。同时还看了某马程序员创始人张老师的《Java高新技术》视频课程，对我影响甚大，视频内容基本是JDK5的新特性，包括静态导包、可变参数、增强for循环、自动拆/装箱、享元设计模式、枚举、反射、类加载器、双亲委派模型、注解、泛型和动态代理等。这套视频算得上是彻底改变了我，真正的让我入了Java的门。</p><p>此后，还看了张老师的《Java多线程与并发库》这套视频，这套视频奠定了我的Java基础，视频主要讲解了传统线程同步与互斥技术、ThreadLocal类、Callable和Future类、Timer定时器类、线程池、读写锁、闭锁、栅栏、计数器、阻塞队列、原子操作类和同步集合等内容。</p><p>再之后，我接触到了Spring，Spring MVC，Mybatis，Maven，Spring Boot，Redis…等一些技术栈。</p><p>基本熟悉这些框架之后，我继续了某客网高级项目课，春节在家的一个月，跟着视频把代码写的差不多了。然后把这个项目当做项目经验填充在自己的简历上。</p><p>对于这个项目，我并不是完全照搬视频中所讲，而是采用标准前后端分离开发模式，前端选择了Vue全家桶技术栈，后端则是视频中的Spring Boot技术栈，这对于我的项目经验来说是一个加分项。</p><p>经过为期五个月的学习，我开始春招的步伐，经过二月底三月初一个多月的跑宣讲会，参加笔试面试，最终收获了一家武汉的Offer，一切都挺幸运的，这家公司的薪资，技术栈都比较满意。终于是功夫不负有心人。</p><p>7月，入职。</p><p>进入新公司，新环境，成为了社会人，很激动。</p><p>9月，参与的第一个需求上线。老总请喝酒，喝吐了一片人，我也吐倒在门外。</p><p>10月，开始了今年最大的一个项目，加班通宵了两次。很累。</p><p>12月，出差来到了北京，看了天安门，看了紫禁城，看了恭王府，看了水立方，看了鸟巢。不虚此行。</p><p>末了，12月的最后一天进行了转正答辩，应该是转正了。</p><p>且行且珍惜。</p><p>2020年，希望可以遇见更好的自己，提高时间规划能力与自控力，形成自己的知识体系，并深入到技术中。</p>]]></content>
      
      
      <categories>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>☕JavaBucket</title>
      <link href="2019/12/13/java-bucket/"/>
      <url>2019/12/13/java-bucket/</url>
      
        <content type="html"><![CDATA[<h2 id="Java技能树"><a href="#Java技能树" class="headerlink" title="Java技能树"></a><code>Java</code>技能树</h2><p><img src="https://i.loli.net/2020/02/15/KqUBzrXAP4JOjHd.png" alt="gold-road-to-java.png"></p><h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a><code>JavaSE</code></h2><h3 id="JDK源码解析系列"><a href="#JDK源码解析系列" class="headerlink" title="JDK源码解析系列"></a><code>JDK</code>源码解析系列</h3><ul><li><a href="https://lilu.org.cn/2020/03/21/javase/base/serializable/"><code>JDK</code>源码解析之<code>Serializable</code></a></li><li><a href="https://lilu.org.cn/2020/04/26/javase/base/randomaccess/"><code>JDK</code>源码解析之<code>RandomAccess</code></a></li><li><a href="https://lilu.org.cn/2020/04/26/javase/base/cloneable/"><code>JDK</code>源码解析之<code>Cloneable</code></a></li><li><a href="https://lilu.org.cn/2020/05/05/javase/base/list/"><code>JDK</code>源码解析之<code>List</code></a></li><li><a href="https://lilu.org.cn/2020/05/05/javase/base/collection/"><code>JDK</code>源码解析之<code>Collection</code></a></li><li><a href="https://lilu.org.cn/2020/05/05/javase/base/abstract-collection/"><code>JDK</code>源码解析之<code>AbstractCollection</code></a></li><li><a href="https://lilu.org.cn/2020/05/08/javase/base/abstract-list/"><code>JDK</code>源码解析之<code>AbstractList</code></a></li><li><a href="https://lilu.org.cn/2020/05/11/javase/base/queue/"><code>JDK</code>源码解析之<code>Queue</code></a></li><li><a href="https://lilu.org.cn/2020/05/11/javase/base/deque/"><code>JDK</code>源码解析之<code>Deque</code></a></li><li><a href="https://lilu.org.cn/2020/05/27/javase/base/linkedlist/"><code>JDK</code>源码解析之<code>LinkedList</code></a></li><li><a href="https://lilu.org.cn/2020/05/27/javase/base/abstract-sequential-list/"><code>JDK</code>源码解析之<code>AbstractSequentialList</code></a></li><li><a href="https://lilu.org.cn/2020/06/01/javase/base/arraylist/"><code>JDK</code>源码解析之<code>ArrayList</code></a></li><li><a href="https://lilu.org.cn/2020/11/17/javase/base/hashmap/">面试必问<code>HashMap</code></a></li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><a href="https://lilu.org.cn/2020/04/26/javase/base/depth-shallow-copy/">深入理解深浅拷贝</a></li><li><a href="https://lilu.org.cn/2020/01/09/javase/base/method-overload/">方法重载<code>Overload</code></a></li><li><a href="https://lilu.org.cn/2020/01/09/javase/base/why-char-cannot-be-converted-to-byte-or-short/">基本数据类型<code>char</code>为什么不会被隐式转换成<code>byte</code>或<code>short</code>类型？</a></li><li><a href="https://lilu.org.cn/2020/06/29/javase/base/string/">关于<code>Java</code>，你不得不学的<code>java.lang.String</code>类</a></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><code>JVM</code></h3><ul><li><a href="https://lilu.org.cn/2020/07/20/javase/jvm/what-is-quote/">何为引用</a></li><li><a href="https://lilu.org.cn/2020/07/20/javase/jvm/run-class/"><code>Java</code>虚拟机是如何运行字节码的</a></li><li><a href="https://lilu.org.cn/2020/07/20/javase/jvm/object-is-alive-or-dead/">对象是“生”是“死”</a></li><li><a href="https://lilu.org.cn/2020/07/20/javase/jvm/finalize-before-gc/">回收前的自救</a></li><li><a href="https://lilu.org.cn/2020/07/23/javase/jvm/gcer/">垃圾收集器</a></li><li><a href="https://lilu.org.cn/2020/07/23/javase/jvm/gc-algorithm/">垃圾收集算法</a></li></ul><h2 id="数据结构-算法"><a href="#数据结构-算法" class="headerlink" title="数据结构-算法"></a>数据结构-算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/data-structure-linkedlist-base/">数据结构之链表-基础知识</a></li><li><a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/non-recursive-reverse-link/">数据结构之链表-使用非递归法实现单链表的反转</a></li><li><a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/middle-linknode/">数据结构之链表-奇数个元素的链表的中间节点</a></li></ul><h3 id="LeetCode题解"><a href="#LeetCode题解" class="headerlink" title="LeetCode题解"></a><code>LeetCode</code>题解</h3><ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E7%AE%97%E6%B3%95/LeetCode%E9%A2%98%E8%A7%A3/docs/%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md">（简单）两数之和</a></li><li><a href="https://lilu.org.cn/2020/12/04/algorithm/leetcode/easy/7/">（简单）整数反转</a></li><li><a href="https://lilu.org.cn/2020/07/14/algorithm/leetcode/easy/242/">（简单）有效的字母异位词</a></li><li><a href="https://lilu.org.cn/2020/07/14/algorithm/leetcode/linkedlist/intersection-of-two-linked-lists-lcci/">链表标签：面试题：链表相交</a></li></ul><h3 id="LeetCode链表标签简单题"><a href="#LeetCode链表标签简单题" class="headerlink" title="LeetCode链表标签简单题"></a><code>LeetCode</code>链表标签简单题</h3><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://lilu.org.cn/2020/12/23/algorithm/leetcode/tag/linkedlist/kth-node-from-end-of-list-lcci/">返回倒数第<code>k</code>个节点</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://lilu.org.cn/2020/12/27/algorithm/leetcode/tag/linkedlist/delete-middle-node-lcci/">删除中间节点</a></li><li><input disabled="" type="checkbox"> 合并两个有序链表</li><li><input disabled="" type="checkbox"> 回文链表</li><li><input disabled="" type="checkbox"> 删除链表中的节点</li><li><input disabled="" type="checkbox"> 删除链表的节点</li><li><input checked="" disabled="" type="checkbox"> <a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/middle-linknode/">链表的中间节点</a></li><li><input disabled="" type="checkbox"> 移除链表元素</li><li><input disabled="" type="checkbox"> 两个链表的第一个公共节点</li><li><input checked="" disabled="" type="checkbox"> <a href="https://lilu.org.cn/2020/12/12/algorithm/base/datastructure/non-recursive-reverse-link/">反转链表</a></li><li><input disabled="" type="checkbox"> 二进制链表转整数</li><li><input disabled="" type="checkbox"> 链表相交</li><li><input checked="" disabled="" type="checkbox"> <a href="https://lilu.org.cn/2020/07/14/algorithm/leetcode/tag/linkedlist/intersection-of-two-linked-lists-lcci/">相交链表</a></li><li><input disabled="" type="checkbox"> 回文链表</li><li><input checked="" disabled="" type="checkbox"> 反转链表</li><li><input disabled="" type="checkbox"> 删除链表M个节点后的N个节点</li><li><input disabled="" type="checkbox"> 删除排序链表中的重复元素</li><li><input checked="" disabled="" type="checkbox"> <a href="https://lilu.org.cn/2020/12/22/algorithm/base/datastructure/link-has-cycle/">环形链表</a></li><li><input disabled="" type="checkbox"> 移除重复节点</li><li><input disabled="" type="checkbox"> 从尾到头打印链表</li></ul><h3 id="勇闯算法"><a href="#勇闯算法" class="headerlink" title="勇闯算法"></a>勇闯算法</h3><ul><li><a href="https://lilu.org.cn/2020/06/04/algorithm/base/recursive-reverse-link/">勇闯算法-递归法拿下反转链表的三杀</a></li><li><a href="https://lilu.org.cn/2020/07/14/algorithm/coding-interview-guide/arraysandmatrices/solution01/">勇闯算法-在行列都排好序的矩阵中找指定的数</a></li></ul><h2 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a><code>JavaEE</code></h2><ul><li><a href="https://lilu.org.cn/2020/12/11/javaee/maven/maven-must-know-and-know/"><code>Apache Maven</code>必知必会</a></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><code>Redis</code></h3><ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/String%E5%AD%97%E7%AC%A6%E4%B8%B2.md"><code>String</code>字符串</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/List%E5%88%97%E8%A1%A8.md"><code>List</code>列表</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Hash%E5%93%88%E5%B8%8C.md"><code>Hash</code>哈希</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Set%E9%9B%86%E5%90%88.md"><code>Set</code>集合</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/ZSet%E9%9B%86%E5%90%88.md"><code>ZSet</code>集合</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE.md"><code>Redis</code>集群配置</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%80%9A%E7%94%A8Redis%E5%91%BD%E4%BB%A4.md">通用<code>Redis</code>命令</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86.md"><code>Redis</code>扩展知识</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E5%85%B6%E5%AE%83Redis%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4.md">其它<code>Redis</code>服务器命令</a></li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><a href="https://lilu.org.cn/2020/07/12/database/mysql/transaction-characteristics-and-isolation-levels/">事务的特性和隔离级别</a></li><li><a href="https://lilu.org.cn/2020/07/12/database/mysql/why-does-mysql-choose-repeatable-read-as-the-default-isolation-level/"><code>MySQL</code>为什么选择可重复读作为默认的隔离级别？</a></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li><code>Apache ShardingSphere</code><ul><li><a href="https://lilu.org.cn/2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/">分库分表中间件之<code>ShardingSphere</code>-入门案例</a></li></ul></li><li><code>xxl-job</code><ul><li><a href="https://lilu.org.cn/2020/02/13/middleware/xxl-job/build-local-dispatch-platform/">修炼<code>xxl-job</code>之搭建本地调度平台</a></li><li><a href="https://lilu.org.cn/2020/02/13/middleware/xxl-job/demo-executor-xxljobconfig-sourcecode-analysis/">修炼<code>xxl-job</code>之示例执行器XxlJobConfig配置类源码解析</a></li><li><a href="https://lilu.org.cn/2020/02/26/middleware/xxl-job/dispatch-center-start-process-analysis/">修炼<code>xxl-job</code>之调度中心启动流程解析</a></li><li><a href="https://lilu.org.cn/2020/02/27/middleware/xxl-job/initI18n/">修炼<code>xxl-job</code>之调度中心—初始化国际化组件</a></li><li><a href="https://lilu.org.cn/2020/02/29/middleware/xxl-job/registry-center-heartbeat-renewal/">修炼<code>xxl-job</code>之调度中心—初始化注册中心“心跳续约”服务</a></li><li><a href="https://lilu.org.cn/2020/03/03/middleware/xxl-job/job-fail-monitor/">修炼<code>xxl-job</code>之调度中心—初始化失败任务管理中心</a></li></ul></li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>待完善…</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>待完善…</p><h2 id="项目管理-持续集成"><a href="#项目管理-持续集成" class="headerlink" title="项目管理-持续集成"></a>项目管理-持续集成</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><code>Linux</code></h3><ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Linux/Linux%E5%91%BD%E4%BB%A4.md"><code>Linux</code>命令</a></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><code>Docker</code></h3><ul><li><a href="https://lilu.org.cn/2020/02/19/docker/docker-common-commands/"><code>Docker</code>常用命令</a></li><li><a href="https://lilu.org.cn/2020/02/19/docker/create-mysql-container/">创建<code>MySQL5.7</code>的<code>Docker</code>容器</a></li></ul><h3 id="常用软件安装系列"><a href="#常用软件安装系列" class="headerlink" title="常用软件安装系列"></a>常用软件安装系列</h3><ul><li><a href="https://lilu.org.cn/2020/02/07/installed/install-windows10/">重装<code>Windows10</code>系统</a></li><li><a href="https://lilu.org.cn/2020/02/07/installed/install-nodejs/"><code>Windows 10</code>下<code>Node.js</code>安装与配置</a></li><li><a href="https://lilu.org.cn/2020/02/07/installed/install-maven/"><code>Windows 10</code>下<code>Maven</code>安装及配置</a></li><li><a href="https://lilu.org.cn/2020/02/07/installed/install-jdk/"><code>Windows 10</code>下<code>JDK</code>安装及环境变量配置</a></li><li><a href="https://lilu.org.cn/2020/02/07/installed/install-idea/"><code>Windows 10</code>下<code>IntelliJ IDEA 2019.3.2</code>安装和常用配置</a></li><li><a href="https://lilu.org.cn/2020/02/07/installed/install-git/"><code>Windows 10</code>下<code>Git</code>安装及<code>SSH</code>公私钥配置</a></li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><code>Git</code></h3><p>待完善…</p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><code>Jenkins</code></h3><p>待完善…</p><h2 id="优秀书籍"><a href="#优秀书籍" class="headerlink" title="优秀书籍"></a>优秀书籍</h2><ul><li><code>Java 8</code>实战<ul><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-I-Basics/">《Java 8实战》读书笔记系列——第一部分：基础知识</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-II-Functional-Data-Processing/">《Java 8实战》读书笔记系列——第二部分：函数式数据处理</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(1)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(2)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(3)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想</a></li><li><a href="https://lilu.org.cn/2019/12/12/reading-notes/Java8-in-action/Part-III-Efficient-Java8-Programming(4)/">《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API</a></li></ul></li></ul><p>待完善…</p><ul><li>《剑指<code>Offer</code>》<ul><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md">实现线程安全的单例模式</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%88%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%89.md">数组中重复的数（题目一）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%88%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%89.md">数组中重复的数（题目二）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md">二维数组中的查找</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.md">替换空格</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%9D%A2%E8%AF%95%E9%A2%985%EF%BC%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%89.md">面试题5（相关题目）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md">从尾到头打印链表</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md">重建二叉树</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.md">二叉树的下一个节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97.md">两个栈实现一个队列</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88.md">两个队列实现一个栈</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%96%90%E6%B3%A2%E9%82%A3%E6%A5%94%E6%95%B0%E5%88%97.md">斐波那楔数列</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.md">青蛙跳台阶问题</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%E6%89%A9%E5%B1%95%EF%BC%88%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89.md">青蛙跳台阶问题扩展（变态跳台阶）</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.md">矩形覆盖</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%87%A0%E4%B8%87%E4%B8%AA%E5%91%98%E5%B7%A5%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F.md">几万个员工年龄排序</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.md">旋转数组的最小数字</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.md">矩阵中的路径</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.md">机器人的运动范围</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%89%AA%E7%BB%B3%E5%AD%90.md">剪绳子</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.md">二进制中1的个数</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.md">数值的整数次方</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.md">打印从1到最大的n位数</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.md">在O(1)时间内删除链表节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9.md">删除链表中重复的节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.md">正则表达式匹配</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.md">表示数值的字符串</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.md">链表中倒数第k个节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9.md">链表中环的入口节点</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a></li><li><a href="https://github.com/sunchaser-lilu/gold-road-to-Java/blob/master/book-notes/%E5%89%91%E6%8C%87Offer/docs/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.md">合并两个排序的链表</a></li></ul></li></ul><p>待完善…</p><ul><li>《程序员代码面试指南-IT名企算法和数据结构题目最优解》</li></ul><p>待完善…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件设计模式的概念与意义</title>
      <link href="2019/12/12/design-patterns/gof/Design-pattern-overview/"/>
      <url>2019/12/12/design-patterns/gof/Design-pattern-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="软件设计模式的概念与意义"><a href="#软件设计模式的概念与意义" class="headerlink" title="软件设计模式的概念与意义"></a>软件设计模式的概念与意义</h2><h3 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h3><p>设计模式，是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。在很多开源框架中都有设计模式思想的体现，尽管有些设计模式逐渐被编程语言的新语法特性给颠覆，但其设计思想依旧是值得我们学习的。</p><h3 id="设计模式的意义"><a href="#设计模式的意义" class="headerlink" title="设计模式的意义"></a>设计模式的意义</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>学习设计模式有以下意义：</p><ul><li>可以提高思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li><li>有利于阅读一些开源框架源码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> GOF设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> GOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoF的23种设计模式</title>
      <link href="2019/12/12/design-patterns/gof/GoF&#39;s-23-design-patterns/"/>
      <url>2019/12/12/design-patterns/gof/GoF&#39;s-23-design-patterns/</url>
      
        <content type="html"><![CDATA[<h2 id="GoF设计模式简介"><a href="#GoF设计模式简介" class="headerlink" title="GoF设计模式简介"></a>GoF设计模式简介</h2><p>GoF是设计模式的经典名著Design Patterns: Elements of Reusable Object-Oriented Software（中译本名为《设计模式——可复用面向对象软件的基础》）的四位作者，他们分为是：Elich Gamma、Richard Helm、Ralph Johnson、以及John Vlissides。这四个人常被称为Gang of Four， 即四人组，简称GoF。这本书中总结的23种设计模式称为GoF设计模式。</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>设计模式有两种分类方法：根据模式的目的划分和根据模式的作用范围划分。</p><h3 id="根据目的划分"><a href="#根据目的划分" class="headerlink" title="根据目的划分"></a>根据目的划分</h3><p>根据模式是用来完成什么工作来划分，可分为创建型模式、结构型模式和行为型模式。</p><ul><li>创建型模式：用于描述“如何创建对象”，主要特点是“将对象的创建和使用分离”。GoF的创建型模式包括单例模式、原型模式、工厂方法模式、抽象工厂模式和建造者模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构。GoF的结构型模式包括代理模式、适配器模式、桥接模式、装饰器模式、外观模式、享元模式和组合模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF的行为型模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。</li></ul><h3 id="根据作用范围划分"><a href="#根据作用范围划分" class="headerlink" title="根据作用范围划分"></a>根据作用范围划分</h3><p>根据模式是主要作用于类上还是主要作用于对象上来划分，可分为类模式和对象模式。</p><ul><li>类模式：用于处理类和子类之间的关系，这些关系通过继承来建立，是静态的，在编译时期就确定了。GoF的类模式包括工厂方法模式、适配器模式（类）、模板方法模式和解释器模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合和聚合来实现，在运行时期是可以动态改变的。GoF中除了类模式，其余都是对象模式。</li></ul><p>下表描述了设计模式的分类：</p><table><thead><tr><th>范围\目的</th><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法模式</td><td>适配器模式（类）</td><td>模板方法模式<br />解释器模式</td></tr><tr><td>对象模式</td><td>单例模式<br />原型模式<br />抽象工厂模式<br />建造者模式</td><td>代理模式<br />适配器模式（对象）<br />桥接模式<br />装饰器模式<br />外观模式<br />享元模式<br />组合模式</td><td>策略模式<br />命令模式<br />责任链模式<br />状态模式<br />观察者模式<br />中介者模式<br />迭代器模式<br />访问者模式<br />备忘录模式</td></tr></tbody></table><h2 id="GoF的23种设计模式"><a href="#GoF的23种设计模式" class="headerlink" title="GoF的23种设计模式"></a>GoF的23种设计模式</h2><ol><li>单例模式（Singleton）：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型模式（Prototype）：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法模式（Factory Method）：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂模式（AbstractFactory）：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者模式（Builder）：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li>代理模式（Proxy）：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接模式（Bridge）：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰模式（Decorator）：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观模式（Facade）：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元模式（Flyweight）：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合模式（Composite）：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>模板方法模式（TemplateMethod）：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略模式（Strategy）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令模式（Command）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链模式（Chain of Responsibility）：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态模式（State）：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者模式（Observer）：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者模式（Mediator）：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器模式（Iterator）：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者模式（Visitor）：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录模式（Memento）<br>：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><p>值得注意的是，这23种设计模式不是孤立存在的，很多模式之间存在一定的关联关系。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> GOF设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> GOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表中间件之ShardingSphere-入门案例</title>
      <link href="2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/"/>
      <url>2019/12/12/middleware/sharding-sphere/sharding-jdbc-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="ShardingSphere的前尘往事"><a href="#ShardingSphere的前尘往事" class="headerlink" title="ShardingSphere的前尘往事"></a>ShardingSphere的前尘往事</h2><p>ShardingSphere的前身是Sharding-JDBC，起源于当当网内部应用框架，于2016年初开源。</p><p>2017年，Sharding-JDBC进入2.x阶段，核心功能是数据库治理。</p><p>2018年春节前夕，Sharding-JDBC团队于京东数科重新组建，并将其定位为面向云原生的数据库中间件，正式更名为ShardingSphere。Sharding-JDBC进入了3.x时代，功能重心转向了Sharding-proxy及分布式事务上。</p><p>美国时间2018年11月10日，分布式数据库中间件生态圈 ShardingSphere正式进入Apache基金会孵化器。</p><p>预祝ShardingSphere项目早日成功毕业。</p><h2 id="Apache-ShardingSphere简介"><a href="#Apache-ShardingSphere简介" class="headerlink" title="Apache ShardingSphere简介"></a>Apache ShardingSphere简介</h2><p>Apache ShardingSphere (Incubator) 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。</p><p>Apache官方发布从4.0.0版本开始。</p><p><a href="https://shardingsphere.apache.org/document/current/cn/overview/">Apache ShardingSphere官方文档</a></p><h2 id="Sharding-JDBC简介"><a href="#Sharding-JDBC简介" class="headerlink" title="Sharding-JDBC简介"></a>Sharding-JDBC简介</h2><p>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><h2 id="Sharding-JDBC快速入门"><a href="#Sharding-JDBC快速入门" class="headerlink" title="Sharding-JDBC快速入门"></a>Sharding-JDBC快速入门</h2><p>我们以一库两表的案例来快速入门。</p><h3 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h3><p>这里我们以简单的订单表为例，作为入门学习使用。</p><p>首先建立一库两表的数据库结构。数据库名为sharding_jdbc_db，建立t_order_1和t_order_2两张表。</p><p>建表sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分表结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> t_order_1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> t_order_2;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sharding_jdbc_db`.`t_order_1`  (</span><br><span class="line">  `order_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键：订单id&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单金额&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`order_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sharding_jdbc_db`.`t_order_2`  (</span><br><span class="line">  `order_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键：订单id&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单金额&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`order_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><h3 id="创建sharding-jdbc-simple项目"><a href="#创建sharding-jdbc-simple项目" class="headerlink" title="创建sharding-jdbc-simple项目"></a>创建sharding-jdbc-simple项目</h3><p>使用IDEA创建一个maven的空模板项目，项目名为sharding-jdbc-simple。</p><p>在pom.xml文件中需添加的sharding-jdbc-spring-boot-starter依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- apache sharding-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于我的项目使用了自己定义的统一依赖管理，所以没有指定各个jar包的版本号。</p><p>读者可以参考 <a href="https://github.com/sunchaser-lilu/plaid-umbrella/tree/master/sunchaser-boot-dependencies">sunchaser-boot-dependencies</a> 进行实现，或者单独指定对应版本号。</p><p>完整的pom.xml内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>中间件<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunchaser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sunchaser.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sunchaser-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- sharding-jdbc依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- test依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- web依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- druid连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><p>springboot项目可使用properties配置或yaml配置。二选一即可。</p><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>配置tomcat端口号、应用名和允许重复定义的bean进行覆盖。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">520</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">sharding-jdbc-simple-demo</span></span><br><span class="line"><span class="comment"># 重复的bean定义进行覆盖</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">520</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sharding-jdbc-simple-demo</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="comment"># 重复的bean会进行覆盖</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="配置mybatis"><a href="#配置mybatis" class="headerlink" title="配置mybatis"></a>配置mybatis</h4><p>主要配置xml文件映射路径和下划线自动转驼峰。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     mybatis配置</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># xml映射文件路径</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/**/*.xml</span></span><br><span class="line"><span class="comment"># 下划线自动转驼峰</span></span><br><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># xml映射文件路径</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 自动转驼峰</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>此入门案例是一库两表，只有一个数据源需要配置。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     数据源配置</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># 数据源名称，多数据源以逗号分隔</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span>=<span class="string">ds1</span></span><br><span class="line"><span class="comment"># 数据源ds1详情配置</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/sharding_jdbc_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.password</span>=<span class="string">ll970722</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 数据源配置</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="comment"># 数据源名称，多数据源以逗号分隔</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds1</span></span><br><span class="line">      <span class="comment"># 数据源ds1详情配置</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/sharding_jdbc_db?useUnicode=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ll970722</span></span><br></pre></td></tr></table></figure><h4 id="配置分片规则"><a href="#配置分片规则" class="headerlink" title="配置分片规则"></a>配置分片规则</h4><p>使用默认的inline表达式配置分片策略，分片策略包含分片键和分片算法，需符合groovy语法。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分片规则配置</span></span><br><span class="line"><span class="comment"># 真实数据节点，由数据源名 + 表名组成，以小数点分隔</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.actual-data-nodes</span>=<span class="string">ds1.t_order_$-&gt;&#123;1..2&#125;</span></span><br><span class="line"><span class="comment"># 主键列名称，缺省表示不使用自增主键生成器</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="comment"># 自增列值生成器类型，缺省表示使用默认自增列值生成器。</span></span><br><span class="line"><span class="comment"># 可使用自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID/LEAF_SEGMENT</span></span><br><span class="line"><span class="comment"># 这里使用SNOWFLAKE雪花算法</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br><span class="line"><span class="comment"># 分片策略（分片键和分片算法）</span></span><br><span class="line"><span class="comment"># 分片键</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.sharding-column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="comment"># 分片算法 生成的ID为奇数，插入到t_order_2中，偶数则插入到t_order_1中</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.algorithm-expression</span>=<span class="string">t_order_$-&gt;&#123;order_id % 2 + 1&#125;</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="comment"># sharding-jdbc分片规则配置</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">t_order:</span></span><br><span class="line">          <span class="comment"># 数据节点</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds1.t_order_$-&gt;&#123;1..2&#125;</span></span><br><span class="line">          <span class="comment"># 主键列和主键生成策略：雪花算法</span></span><br><span class="line">          <span class="attr">key-generator:</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">order_id</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">          <span class="comment"># 分片策略</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="comment"># 分片键</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">order_id</span></span><br><span class="line">              <span class="comment"># 分片算法：生成的ID为奇数，插入到t_order_2中，偶数则插入到t_order_1中</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">t_order_$-&gt;&#123;order_id</span> <span class="string">%</span> <span class="number">2</span> <span class="string">+</span> <span class="number">1</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="配置日志相关"><a href="#配置日志相关" class="headerlink" title="配置日志相关"></a>配置日志相关</h4><p>配置打印执行的真实sql与日志级别。</p><p>properties配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印sharding-jdbc的真实执行sql日志</span></span><br><span class="line"><span class="meta">spring.shardingsphere.props.sql.show</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 日志级别配置</span></span><br><span class="line"><span class="meta">logging.level.root</span>=<span class="string">info</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">info</span></span><br><span class="line"><span class="meta">logging.level.com.sunchaser.shardingjdbc</span>=<span class="string">debug</span></span><br><span class="line"><span class="meta">logging.level.druid.sql</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="comment"># 打印sharding-jdbc的真实执行sql日志</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">org:</span></span><br><span class="line">      <span class="attr">springframework:</span></span><br><span class="line">        <span class="attr">web:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">com:</span></span><br><span class="line">      <span class="attr">sunchaser:</span></span><br><span class="line">        <span class="attr">shardingjdbc:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">sql:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>至此，配置部分完成，开始编写后端代码。</p><h3 id="后端测试代码编写"><a href="#后端测试代码编写" class="headerlink" title="后端测试代码编写"></a>后端测试代码编写</h3><p>项目包结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">└─src</span><br><span class="line">    ├─main</span><br><span class="line">    │  ├─java</span><br><span class="line">    │  │  └─com</span><br><span class="line">    │  │      └─sunchaser</span><br><span class="line">    │  │          └─shardingjdbc  ------ 存放启动类</span><br><span class="line">    │  │              ├─entity  -------- 存放实体类</span><br><span class="line">    │  │              └─mapper  -------- 存放mapper接口</span><br><span class="line">    │  └─resources</span><br><span class="line">    │      ├─db  ----------------------- 存放建表语句</span><br><span class="line">    │      └─mapper  ------------------- 存放xml映射文件</span><br><span class="line">    └─test</span><br><span class="line">        └─java</span><br><span class="line">            └─com</span><br><span class="line">                └─sunchaser</span><br><span class="line">                    └─shardingjdbc</span><br><span class="line">                        └─mapper  ------ 存放单元测试类</span><br></pre></td></tr></table></figure><p>入门案例主要是使用Sharding-JDBC进行新增和查询，mybatis的mapper接口和xml映射文件编写方式保持不变。</p><h4 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingJdbcSimpleApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ShardingJdbcSimpleApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写订单实体类"><a href="#编写订单实体类" class="headerlink" title="编写订单实体类"></a>编写订单实体类</h4><p>使用lombok工具包的@Data和@Builder注解生成getter、setter和建造者模式代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单id：雪花算法生成的分布式唯一ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写mapper接口"><a href="#编写mapper接口" class="headerlink" title="编写mapper接口"></a>编写mapper接口</h4><ol><li>插入订单（注解实现）</li><li>根据订单ID的集合查询订单信息集合（注解实现）</li><li>根据订单ID的集合查询订单信息集合（XML实现）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sunchaser.shardingjdbc.entity.OrderEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderEntity 订单实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响记录行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into t_order(price,user_id,status) values(#&#123;price&#125;,#&#123;userId&#125;,#&#123;status&#125;)&quot;)</span></span><br><span class="line">    <span class="function">Integer <span class="title">insert</span><span class="params">(OrderEntity orderEntity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解实现</span></span><br><span class="line"><span class="comment">     * 根据订单id集合查询订单集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderIds 订单ID集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 订单集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot; &lt;script&gt; &quot; +</span></span><br><span class="line"><span class="meta">            &quot; select * from t_order t where t.order_id in &quot; +</span></span><br><span class="line"><span class="meta">            &quot; &lt;foreach collection=&#x27;orderIds&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27; item=&#x27;orderId&#x27;&gt; &quot; +</span></span><br><span class="line"><span class="meta">            &quot; #&#123;orderId&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot; &lt;/foreach&gt; &quot; +</span></span><br><span class="line"><span class="meta">            &quot; &lt;/script&gt; &quot;)</span></span><br><span class="line">    <span class="function">List&lt;OrderEntity&gt; <span class="title">selectByAnnotation</span><span class="params">(<span class="meta">@Param(&quot;orderIds&quot;)</span> List&lt;Long&gt; orderIds)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xml 实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderIds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;OrderEntity&gt; <span class="title">selectByXml</span><span class="params">(<span class="meta">@Param(&quot;orderIds&quot;)</span> List&lt;Long&gt; orderIds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderMapper的selectByXml方法对应的XML配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sunchaser.shardingjdbc.mapper.OrderMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByXml&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;com.sunchaser.shardingjdbc.entity.OrderEntity&quot;</span>&gt;</span></span><br><span class="line">        select * from t_order where order_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&#x27;orderIds&#x27;</span> <span class="attr">item</span>=<span class="string">&#x27;orderId&#x27;</span> <span class="attr">open</span>=<span class="string">&#x27;(&#x27;</span> <span class="attr">separator</span>=<span class="string">&#x27;,&#x27;</span> <span class="attr">close</span>=<span class="string">&#x27;)&#x27;</span>&gt;</span></span><br><span class="line">            #&#123;orderId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写单元测试代码"><a href="#编写单元测试代码" class="headerlink" title="编写单元测试代码"></a>编写单元测试代码</h4><p>首先循环调用OrderMapper的insert方法插入20条订单数据，然后分别选择同一个订单表的两个订单orderId和选择不同订单表的两个orderId进行<code>in</code>查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sunchaser.shardingjdbc.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> com.sunchaser.shardingjdbc.entity.OrderEntity;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunchaser</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            OrderEntity orderEntity = OrderEntity.builder()</span><br><span class="line">                    .price(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.11&quot;</span>))</span><br><span class="line">                    .userId(<span class="string">&quot;2019xxxxxxxx&quot;</span>)</span><br><span class="line">                    .status(<span class="string">&quot;SUCCESS&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            Integer success = orderMapper.insert(orderEntity);</span><br><span class="line">            System.out.println(success);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Long&gt; orderIds = Lists.newArrayList(<span class="number">406907714078244865L</span>,<span class="number">407114454203891712L</span>);</span><br><span class="line">        List&lt;OrderEntity&gt; orderEntities = orderMapper.selectByAnnotation(orderIds);</span><br><span class="line">        System.out.println(orderEntities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Long&gt; orderIds = Lists.newArrayList(<span class="number">406907714078244865L</span>,<span class="number">407114454203891712L</span>);</span><br><span class="line">        List&lt;OrderEntity&gt; orderEntities = orderMapper.selectByXml(orderIds);</span><br><span class="line">        System.out.println(orderEntities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面配置了sql日志打印，我们可在控制台看到执行的逻辑SQL和真实SQL。</p><p>以查询方法selectByAnnotation为例，执行日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2019-12-12 11:05:36.399 DEBUG 17328 --- [           main] c.s.s.m.OrderMapper.selectByAnnotation   : &#x3D;&#x3D;&gt;  Preparing: select * from t_order t where t.order_id in ( ? , ? ) </span><br><span class="line">2019-12-12 11:05:36.459 DEBUG 17328 --- [           main] c.s.s.m.OrderMapper.selectByAnnotation   : &#x3D;&#x3D;&gt; Parameters: 406907714078244865(Long), 407114454203891712(Long)</span><br><span class="line">2019-12-12 11:05:37.778  INFO 17328 --- [           main] ShardingSphere-SQL                       : Rule Type: sharding</span><br><span class="line">2019-12-12 11:05:37.783  INFO 17328 --- [           main] ShardingSphere-SQL                       : Logic SQL: select * from t_order t where t.order_id in   (    ?   ,   ?   )</span><br><span class="line">2019-12-12 11:05:37.784  INFO 17328 --- [           main] ShardingSphere-SQL                       : SQLStatement: SelectStatement(super&#x3D;DQLStatement(super&#x3D;AbstractSQLStatement(type&#x3D;DQL, tables&#x3D;Tables(tables&#x3D;[Table(name&#x3D;t_order, alias&#x3D;Optional.of(t))]), routeConditions&#x3D;Conditions(orCondition&#x3D;OrCondition(andConditions&#x3D;[AndCondition(conditions&#x3D;[Condition(column&#x3D;Column(name&#x3D;order_id, tableName&#x3D;t_order), operator&#x3D;IN, compareOperator&#x3D;null, positionValueMap&#x3D;&#123;&#125;, positionIndexMap&#x3D;&#123;0&#x3D;0, 1&#x3D;1&#125;)])])), encryptConditions&#x3D;Conditions(orCondition&#x3D;OrCondition(andConditions&#x3D;[])), sqlTokens&#x3D;[TableToken(tableName&#x3D;t_order, quoteCharacter&#x3D;NONE, schemaNameLength&#x3D;0)], parametersIndex&#x3D;2, logicSQL&#x3D;select * from t_order t where t.order_id in   (    ?   ,   ?   ))), containStar&#x3D;true, firstSelectItemStartIndex&#x3D;7, selectListStopIndex&#x3D;7, groupByLastIndex&#x3D;0, items&#x3D;[StarSelectItem(owner&#x3D;Optional.absent())], groupByItems&#x3D;[], orderByItems&#x3D;[], limit&#x3D;null, subqueryStatement&#x3D;null, subqueryStatements&#x3D;[], subqueryConditions&#x3D;[])</span><br><span class="line">2019-12-12 11:05:37.786  INFO 17328 --- [           main] ShardingSphere-SQL                       : Actual SQL: ds1 ::: select * from t_order_1 t where t.order_id in   (    ?   ,   ?   ) ::: [406907714078244865, 407114454203891712]</span><br><span class="line">2019-12-12 11:05:37.786  INFO 17328 --- [           main] ShardingSphere-SQL                       : Actual SQL: ds1 ::: select * from t_order_2 t where t.order_id in   (    ?   ,   ?   ) ::: [406907714078244865, 407114454203891712]</span><br><span class="line">2019-12-12 11:05:38.062 DEBUG 17328 --- [           main] c.s.s.m.OrderMapper.selectByAnnotation   : &lt;&#x3D;&#x3D;      Total: 2</span><br><span class="line">[OrderEntity(orderId&#x3D;407114454203891712, price&#x3D;1.11, userId&#x3D;2019xxxxxxxx, status&#x3D;SUCCESS), OrderEntity(orderId&#x3D;406907714078244865, price&#x3D;1.11, userId&#x3D;2019xxxxxxxxxxxxxxx, status&#x3D;SUCCESS)]</span><br></pre></td></tr></table></figure><p>可看到执行的Logic SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order t <span class="keyword">where</span> t.order_id <span class="keyword">in</span> ( ? , ? )</span><br></pre></td></tr></table></figure><p>Sharding-JDBC的路由引擎根据解析上下文匹配数据库和表的分片策略，路由到具体的库和表。再经过改写引擎，将逻辑SQL改写为真正执行的SQL。</p><p>从日志中可看到改写后的Actual SQL为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order_1 t <span class="keyword">where</span> t.order_id <span class="keyword">in</span>   (    ?   ,   ?   ) ::: [<span class="number">406907714078244865</span>, <span class="number">407114454203891712</span>]</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order_2 t <span class="keyword">where</span> t.order_id <span class="keyword">in</span>   (    ?   ,   ?   ) ::: [<span class="number">406907714078244865</span>, <span class="number">407114454203891712</span>]</span><br></pre></td></tr></table></figure><p>结果归并，真实的SQL执行后会返回多个结果集，归并引擎从各个数据节点拿到结果集后组合成一个结果集并返回给客户端。</p><p>至此，入门案例就演示结束。源码地址：<a href="https://github.com/sunchaser-lilu/gold-road-to-Java/tree/master/%E4%B8%AD%E9%97%B4%E4%BB%B6/sharding-jdbc-simple">传送门</a></p><p>下一篇文章将对Sharding-JDBC中的一些核心概念进行具体的解释。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这篇文章主要是对Apache ShardingSphere 4.x与Spring Boot 2.1.x进行整合，使用了内置的SNOWFLAKE雪花算法生成分布式全局唯一ID和使用默认的inline表达式配置分片策略，完成了最简单的一库两表的分库分表，并对新增和查询操作进行了测试。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 分库分表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache ShardingSphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8实战》读书笔记系列——第一部分：基础知识</title>
      <link href="2019/12/12/reading-notes/java8-in-action/Part-I-Basics/"/>
      <url>2019/12/12/reading-notes/java8-in-action/Part-I-Basics/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：为什么要关心Java-8"><a href="#第一章：为什么要关心Java-8" class="headerlink" title="第一章：为什么要关心Java 8"></a>第一章：为什么要关心Java 8</h2><p>第一章主要需要了解Java语言的发展历史。</p><h3 id="Java-8的前世今生"><a href="#Java-8的前世今生" class="headerlink" title="Java 8的前世今生"></a>Java 8的前世今生</h3><p>从第一个Java版本诞生到现在已经有23年的时间了。沧海桑田一瞬间，转眼24年过去了，如今JDK 8以上的版本也开始收费了，JDK 11成为目前长期支持的版本。版本不断变更的这几年，很多企业项目还是在用JDK 8或更低的版本进行维护。但是对于我们开发者来说，始终要不断地学习了解新特性和新技术，否则大浪淘沙，终有一日将成为沙滩上的一条咸鱼。</p><p>时间在变，但我们对技术的那份初心永不会变。作为一个Java开发工程师，很有必要来了解一下Java语言发展史。</p><p><img src="https://i.loli.net/2020/02/15/cWvm6DXU2Yz1kqP.png" alt="1-JavaTimeline.png"></p><p>1995年5月23日，从Oak（橡树）到Java，Java语言第一次提出了”Write Once, Run Anywhere”的口号。</p><p>1996年1月23日，Java语言的第一个正式版本的运行环境JDK 1.0发布。</p><p>1998年12月4日，JDK的第一个里程碑式的版本JDK 1.2发布，工程代号为Playground（竞技场）。sun公司在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。</p><p>2000年5月8日，工程代号为Kestrel（美洲红隼 [sǔn] ）的JDK 1.3发布，它还有一个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），于2001年5月17日发布。从这个版本开始，Sun公司维持了一个习惯：大约每隔两年发布一个JDK的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程名称。</p><p>2002年2月13日，工程代号为Merlin（灰背隼）的JDK 1.4发布。后续还有两个修正版本：2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的JDK 1.4.1和2003年6月26日发布的工程代号为Mantis（螳螂）的JDK 1.4.2。</p><p>2004年9月30日，工程代号为Tiger（老虎）的JDK 1.5发布。这个版本的JDK在我看来是Java语言能发展到今天的基石。它提供了自动装箱、泛型、动态注解、枚举、可变长参数、foreach循环和java.util.concurrent并发包等新特性，这些新特性都是Java语言的生命之所在。官方从这个版本开始，在正式文档与宣传上都不再使用类似JDK 1.5的命名，而是使用JDK 5，JDK 6，JDK 7…。只有在程序员内部使用的开发版本号（例如java-version的输出）中才继续沿用1.5，1.6，1.7的版本号。</p><p>2006年12月11日，工程代号为Mustang（野马）的JDK 6发布。在这个版本中，Sun公司终结了从JDK 1.2开始已经有8年历史的J2EE、J2SE、J2ME的命名方式，启用Java SE、Java EE、Java ME的命名方式。同年11月13日的JavaOne大会上，Sun公司宣布将Java开源，并建立OpenJDK组织对开源代码进行管理。</p><p>2009年2月19日，工程代号为Dolphin（海豚）的JDK 7的第一个版本发布。JDK 7本应是一个包含许多重要改进的版本，JDK 8中的Lambda项目原本计划安排在JDK 7中发布，但由于各种商业原因，Sun公司无力进行JDK 7的研发工作。同年4月20日，Oracle公司收购Sun公司，将很多未实现的改进进行裁剪延期，以保证JDK 7的正式版能够在2011年7月28日准时发布。</p><p>2011年7月28日，Oracle公司发布工程代号为Dolphin（海豚）的JDK 7正式版。</p><p>2014年3月18日，Oracle公司发布工程代号为Spider（蜘蛛）的JDK 8。</p><p>2017年9月21日，Oracle公司发布JDK 9。</p><h3 id="Java-8的新特性列表"><a href="#Java-8的新特性列表" class="headerlink" title="Java 8的新特性列表"></a>Java 8的新特性列表</h3><ul><li>Lambda表达式和方法引用</li><li>流处理StreamAPI</li><li>默认方法</li><li>Optional类</li><li>CompletableFuture接口</li><li>新的日期时间API</li></ul><h2 id="第二章：通过行为参数化传递代码"><a href="#第二章：通过行为参数化传递代码" class="headerlink" title="第二章：通过行为参数化传递代码"></a>第二章：通过行为参数化传递代码</h2><ol><li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li><li>行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。</li><li>传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。</li><li>Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。</li></ol><h2 id="第三章：Lambda表达式"><a href="#第三章：Lambda表达式" class="headerlink" title="第三章：Lambda表达式"></a>第三章：Lambda表达式</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口就是只定义一个抽象方法的接口。<br>接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。<br>哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p><p>函数式接口的抽象方法的签名称为函数描述符。</p><h3 id="Java8-内置四大核心函数式接口"><a href="#Java8-内置四大核心函数式接口" class="headerlink" title="Java8 内置四大核心函数式接口"></a>Java8 内置四大核心函数式接口</h3><p>java.util.function包下：</p><ol><li>消费型接口：<code>Consumer&lt;T&gt; &#123;void accept(T t);&#125;</code></li><li>供给型接口：<code>Supplier&lt;T&gt; &#123;T get();&#125;</code></li><li>函数型接口：<code>Function&lt;T,R&gt; &#123;R apply(T t);&#125;</code></li><li>断言型接口：<code>Predicate&lt;T&gt; &#123;boolean test(T t);&#125;</code></li></ol><h3 id="原始类型特化函数式接口"><a href="#原始类型特化函数式接口" class="headerlink" title="原始类型特化函数式接口"></a>原始类型特化函数式接口</h3><p>为了避免装箱操作，对<code>Predicate&lt;T&gt;</code>和<code>Function&lt;T, R&gt;</code>等通用函数式接口的原始类型特化：<code>IntPredicate</code>、<code>IntToLongFunction</code>等。 </p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>如果一个Lambda代表的只是“直接调用这个方法”，那好还是用名称来调用它，而不是去描述如何调用它。</p><h4 id="如何构建方法引用"><a href="#如何构建方法引用" class="headerlink" title="如何构建方法引用"></a>如何构建方法引用</h4><p>方法引用主要有三类。 </p><p>(1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作<code>Integer::parseInt</code>）。</p><p>(2) 指向任意类型实例方法的方法引用（例如String 的 length 方法，写作<code>String::length</code>）。</p><p>(3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量<code>expensiveTransaction</code>用于存放<code>Transaction</code>类型的对象，它支持实例方法getValue，那么你就可以写<code>expensive- Transaction::getValue</code>）。</p><h4 id="将Lambda表达式重构为等价的方法引用"><a href="#将Lambda表达式重构为等价的方法引用" class="headerlink" title="将Lambda表达式重构为等价的方法引用"></a>将Lambda表达式重构为等价的方法引用</h4><p>(1) Lambda：<code>(args) -&gt; ClassName.staticMethod(args)</code></p><p>等价的方法引用为：<code>ClassName::staticMethod</code>。</p><p>(2) Lambda：<code>(arg0,test) -&gt; arg0.instanceMethod(test)</code></p><p>等价的方法引用为：<code>ClassName::instanceMethod</code>，其中arg0的类型是ClassName。</p><p>(3) Lambda：<code>(args) -&gt; expr.instanceMethod(args)</code></p><p>等价的方法引用为：<code>expr::instanceMethod</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java 8实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8实战》读书笔记系列——第二部分：函数式数据处理</title>
      <link href="2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/"/>
      <url>2019/12/12/reading-notes/java8-in-action/Part-II-Functional-Data-Processing/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章：引入流"><a href="#第四章：引入流" class="headerlink" title="第四章：引入流"></a>第四章：引入流</h2><h3 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h3><p>从支持数据处理操作的源生成的元素序列。</p><h3 id="元素序列"><a href="#元素序列" class="headerlink" title="元素序列"></a>元素序列</h3><p>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。</p><p>因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。</p><p>但流的目的在于表达计算，比如前面见到的filter、sorted和map。</p><p>集合讲的是数据，流讲的是计算。</p><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><p>流会使用一个提供数据的源，如集合、数组或输入/输出资源。</p><p>请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</p><h3 id="数据处理操作"><a href="#数据处理操作" class="headerlink" title="数据处理操作"></a>数据处理操作</h3><p>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，</p><p>如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。 </p><h3 id="流操作的特点"><a href="#流操作的特点" class="headerlink" title="流操作的特点"></a>流操作的特点</h3><h4 id="1-流水线"><a href="#1-流水线" class="headerlink" title="1. 流水线"></a>1. 流水线</h4><p>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</p><p>这让之后章节中的一些优化成为可能，如延迟和短路。</p><p>流水线的操作可以看作对数据源进行数据库式（链式）查询。</p><h4 id="2-内部迭代"><a href="#2-内部迭代" class="headerlink" title="2. 内部迭代"></a>2. 内部迭代</h4><p>与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的（内部迭代）。</p><h4 id="3-流只能被消费一次"><a href="#3-流只能被消费一次" class="headerlink" title="3. 流只能被消费一次"></a>3. 流只能被消费一次</h4><p>终止操作只能有一次，重复消费会抛出java.lang.IllegalStateException异常。</p><h4 id="4-对流的操作分为两类：中间操作和终止操作"><a href="#4-对流的操作分为两类：中间操作和终止操作" class="headerlink" title="4. 对流的操作分为两类：中间操作和终止操作"></a>4. 对流的操作分为两类：中间操作和终止操作</h4><ul><li>中间操作总是会惰性执行：执行一个中间操作不会在原流上做任何处理，而是创建一个标记了该操作的新流返回。</li><li>终止操作才会进行真实的计算：计算发生时会把所有中间操作积攒的操作以Pipeline的方式执行，这样可以减少迭代次数，计算完成后流即失效。</li></ul><h3 id="集合与流的不同点："><a href="#集合与流的不同点：" class="headerlink" title="集合与流的不同点："></a>集合与流的不同点：</h3><ul><li>无存储：Stream不是一种数据结构，它只是某种数据源的一个视图。数据源可以是一个数组、Java容器或I/O资源等。</li><li>为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对一个流执行filter过滤操作并不会删除被过滤的元素，而是会产生一个新的不包含被过滤元素的新流。</li><li>惰性执行：对流的中间操作并不会立即执行，只有等一个终止操作来临时才会一次性全部执行。</li><li>可消费性：一个流只能被消费一次，一旦产生终止操作，流即被消费。</li></ul><h2 id="第五章：使用流"><a href="#第五章：使用流" class="headerlink" title="第五章：使用流"></a>第五章：使用流</h2><h3 id="1-筛选和切片"><a href="#1-筛选和切片" class="headerlink" title="1.  筛选和切片"></a>1.  筛选和切片</h3><p>选择流中的元素：用谓词筛选，筛选出各不相同的元素，忽略流 中的头几个元素，或将流截短至指定长度。</p><h4 id="1-1-用谓词筛选"><a href="#1-1-用谓词筛选" class="headerlink" title="1.1 用谓词筛选"></a>1.1 用谓词筛选</h4><p>Streams接口支持<code>filter</code>方法。该操作会接受一个谓词（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p><h4 id="1-2-筛选各异的元素"><a href="#1-2-筛选各异的元素" class="headerlink" title="1.2 筛选各异的元素"></a>1.2 筛选各异的元素</h4><p>流支持一个叫作<code>distinct</code>的方法，它会返回一个元素各异（根据流所生成元素的 hashCode和equals方法实现）的流。</p><h4 id="1-3-截短流"><a href="#1-3-截短流" class="headerlink" title="1.3 截短流"></a>1.3 截短流</h4><p>流支持<code>limit(n)</code>方法，该方法会返回一个不超过给定长度的流。</p><p>所需的长度作为参数传递给limit。如果流是有序的，则多会返回前n个元素。</p><h4 id="1-4-跳过元素"><a href="#1-4-跳过元素" class="headerlink" title="1.4 跳过元素"></a>1.4 跳过元素</h4><p>流还支持<code>skip(n)</code>方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。</p><p>请注意，<code>limit(n)</code>和<code>skip(n)</code>是互补的。</p><h3 id="2-映射"><a href="#2-映射" class="headerlink" title="2. 映射"></a>2. 映射</h3><p>一个非常常见的数据处理套路就是从某些对象中选择信息。</p><p>比如在SQL里，你可以从表中选择一列。Stream API也通过<code>map</code>和<code>flatMap</code>方法提供了类似的工具。</p><h4 id="2-1-对流中每一个元素应用函数"><a href="#2-1-对流中每一个元素应用函数" class="headerlink" title="2.1 对流中每一个元素应用函数"></a>2.1 对流中每一个元素应用函数</h4><p>流支持<code>map</code>方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，</p><p>并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）。</p><h4 id="2-2-流的扁平化"><a href="#2-2-流的扁平化" class="headerlink" title="2.2 流的扁平化"></a>2.2 流的扁平化</h4><p>流支持<code>flatMap</code>方法，将各个单独的流合并起来，扁平化成一个流。</p><p><code>flatMap</code>方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p><h3 id="3-查找和匹配"><a href="#3-查找和匹配" class="headerlink" title="3. 查找和匹配"></a>3. 查找和匹配</h3><p>另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。</p><p>Stream API通过<code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code>、<code>findAny</code>和<code>findFirst</code>方法提供了这样的工具。</p><h4 id="3-1-检查谓词是否至少匹配一个元素"><a href="#3-1-检查谓词是否至少匹配一个元素" class="headerlink" title="3.1 检查谓词是否至少匹配一个元素"></a>3.1 检查谓词是否至少匹配一个元素</h4><p><code>anyMatch()</code>：流中是否有一个元素能匹配给定的谓词。</p><p>返回一个boolean，因此是一个终端操作。</p><h4 id="3-2-检查谓词是否匹配所有元素"><a href="#3-2-检查谓词是否匹配所有元素" class="headerlink" title="3.2 检查谓词是否匹配所有元素"></a>3.2 检查谓词是否匹配所有元素</h4><p><code>allMatch()</code>：流中的元素是否都能匹配给定的谓词。是一个终端操作。</p><h4 id="3-3-检查谓词是否不匹配所有元素"><a href="#3-3-检查谓词是否不匹配所有元素" class="headerlink" title="3.3 检查谓词是否不匹配所有元素"></a>3.3 检查谓词是否不匹配所有元素</h4><p><code>noneMatch()</code>：流中没有任何元素与给定的谓词匹配。</p><h4 id="3-4-查找元素"><a href="#3-4-查找元素" class="headerlink" title="3.4 查找元素"></a>3.4 查找元素</h4><p><code>findAny()</code>：将返回当前流中的任意元素。如果流中没有元素，返回值可能为空，于是Java 8引入了<code>Optional&lt;T&gt;</code>类。</p><h3 id="Optional简介"><a href="#Optional简介" class="headerlink" title="Optional简介"></a>Optional简介</h3><p><code>Optional&lt;T&gt;</code>类（<code>java.util.Optional</code>）是一个容器类，代表一个值存在或不存在。</p><p>方法简介：</p><p>1、<code>isPresent()</code>：将在Optional包含值的时候返回true, 否则返回false。</p><p>2、<code>ifPresent(Consumer&lt;T&gt; block)</code>：会在值存在的时候执行给定的代码块。</p><p>3、<code>T get()</code>：会在值存在时返回值，否则抛出一个<code>NoSuchElement</code>异常。</p><p>4、<code>T orElse(T other)</code>：会在值存在时返回值，否则返回一个默认值。 </p><h4 id="3-5-查找第一个元素"><a href="#3-5-查找第一个元素" class="headerlink" title="3.5 查找第一个元素"></a>3.5 查找第一个元素</h4><p><code>findFirst()</code>：返回流中的第一个元素。同样地，如果流中没有元素，返回值可能为空，返回类型为<code>Optional&lt;T&gt;</code>类。</p><p>有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，可能想要找到第一个元素。</p><h3 id="4-归约"><a href="#4-归约" class="headerlink" title="4. 归约"></a>4. 归约</h3><p><code>reduce()</code>：将流中所有元素反复结合起来，得到一个值。</p><p><code>reduce()</code>方法有两个重载的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param identity 归约的初始值</span><br><span class="line"> * @param accumulator 归约操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param accumulator 归约操作</span><br><span class="line"> * @return Optional&lt;T&gt;对象，由于没有初始值，流中元素可能为空，故返回值会存在空的情况。</span><br><span class="line"> *&#x2F;</span><br><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure><p>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，因为它很容易并行化。</p><h3 id="5-数值流"><a href="#5-数值流" class="headerlink" title="5. 数值流"></a>5. 数值流</h3><p>流中的元素是数值型的，例如int，long，double。尽管可以把这些数值型元素放入流中，但实际上是暗含了装箱操作，将数值型元素转换成对应的包装类型，从而形成对象流。</p><p>Stream API提供了原始类型流特化，专门支持处理数值流的方法。减去装箱操作的损耗。</p><h4 id="5-1-原始类型流特化"><a href="#5-1-原始类型流特化" class="headerlink" title="5.1 原始类型流特化"></a>5.1 原始类型流特化</h4><p>Java 8引入了三个原始类型特化流接口：<code>IntStream</code>、<code>DoubleStream</code>和<code>LongStream</code>，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p><p>每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找到大元素的max。此外还有在必要时再把它们转换回对象流的方法。</p><h5 id="5-1-1-映射到数值流"><a href="#5-1-1-映射到数值流" class="headerlink" title="5.1.1 映射到数值流"></a>5.1.1 映射到数值流</h5><p>将流转换为特化版本的常用方法是<code>mapToInt</code>、<code>mapToDouble</code>和<code>mapToLong</code>。这些方法map方法的工作方式一样，只是它们返回的是一个特化流，而不是<code>Stream&lt;T&gt;</code>。</p><h5 id="5-1-2-转换回对象流"><a href="#5-1-2-转换回对象流" class="headerlink" title="5.1.2 转换回对象流"></a>5.1.2 转换回对象流</h5><p>一旦有了数值流，可能需要将其转换回非特化流。</p><h5 id="5-1-3-默认值OptionalInt"><a href="#5-1-3-默认值OptionalInt" class="headerlink" title="5.1.3 默认值OptionalInt"></a>5.1.3 默认值OptionalInt</h5><p>对于原始类型特化流接口中的max，min，average等方法的返回值。如果流是空的，这些方法的返回值为空，但不能默认为0。因为可能真实计算的结果恰好为0。</p><p>可以使用Optional类来解决返回值为空的情况。但<code>Optional&lt;T&gt;</code>只能接收包装类型。传递原始类型会触发自动装箱操作，产生损耗。</p><p>Java 8同样引入了Optional原始类型特化版本：<code>OptionalInt</code>、<code>OptionalDouble</code>和<code>OptionalLong</code>，用这些Optional类来解决传递原始类型时自动装箱的问题。</p><h4 id="5-2-数值范围"><a href="#5-2-数值范围" class="headerlink" title="5.2 数值范围"></a>5.2 数值范围</h4><p>和数字打交道时，有一个常用的东西就是数值范围。比如生成1和100之间的所有数字。</p><p>Java 8引入了两个可以用于<code>IntStream</code>和<code>LongStream</code>的静态方法，帮助生成这种范围： <code>range</code>和<code>rangeClosed</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * range方法表示的范围为：[startInclusive,endExclusive)</span><br><span class="line"> * @param startInclusive 数值范围开始</span><br><span class="line"> * @param endExclusive 数值范围结束（不包含该值）</span><br><span class="line"> *&#x2F;</span><br><span class="line">IntStream range(int startInclusive, int endExclusive);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * rangeClosed方法表示的范围为：[startInclusive,endExclusive]</span><br><span class="line"> * @param startInclusive 数值范围开始</span><br><span class="line"> * @param endExclusive 数值范围结束（包含该值）</span><br><span class="line"> *&#x2F;</span><br><span class="line">IntStream rangeClosed(int startInclusive, int endInclusive);</span><br></pre></td></tr></table></figure><p>这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但<code>range</code>是不包含结束值的，而<code>rangeClosed</code>则包含结束值。</p><h3 id="6-构建流"><a href="#6-构建流" class="headerlink" title="6. 构建流"></a>6. 构建流</h3><p>介绍如何从值序列、数组、文件来创建流，甚至由生成函数来创建无限流。</p><h4 id="6-1-由值创建流"><a href="#6-1-由值创建流" class="headerlink" title="6.1 由值创建流"></a>6.1 由值创建流</h4><p>使用静态方法<code>Stream.of(T...values)</code>，通过显式值创建一个流。它可以接受任意数量的参数。</p><p>使用静态方法<code>Stream.empty()</code>，创建一个空流。</p><h4 id="6-2-由数组创建流"><a href="#6-2-由数组创建流" class="headerlink" title="6.2 由数组创建流"></a>6.2 由数组创建流</h4><p>使用静态方法<code>Arrays.stream</code>从数组创建一个流。它接受一个数组作为参数。</p><h4 id="6-3、由文件生成流"><a href="#6-3、由文件生成流" class="headerlink" title="6.3、由文件生成流"></a>6.3、由文件生成流</h4><p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。</p><p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。</p><p>例如，<code>Files.lines</code>，它会返回一个由指定文件中的各行构成的字符串流。</p><h4 id="6-4-由函数生成流：创建无限流"><a href="#6-4-由函数生成流：创建无限流" class="headerlink" title="6.4 由函数生成流：创建无限流"></a>6.4 由函数生成流：创建无限流</h4><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。</p><p>这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。</p><p>由<code>iterate</code>和<code>generate</code>产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！</p><p>一般来说，应该使用<code>limit(n)</code>来对这种流加以限制，以避免打印无穷多个值。</p><h2 id="第六章：用流收集数据"><a href="#第六章：用流收集数据" class="headerlink" title="第六章：用流收集数据"></a>第六章：用流收集数据</h2><h3 id="1-汇总"><a href="#1-汇总" class="headerlink" title="1. 汇总"></a>1. 汇总</h3><p><code>Collectors</code>类专门为汇总提供了一个工厂方法：<code>Collectors.summingInt</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>它可接受一个把对象映射为求和所需int的函数，并返回一个收集器，该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。</p><p>类似的还有<code>Collectors.summingDouble</code>方法和<code>Collectors.summingLong</code>方法，汇总为double和long类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>汇总不仅仅只有求和。</p><p>平均数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>一次操作取得多个汇总结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper);</span><br><span class="line">Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper);</span><br></pre></td></tr></table></figure><p>可以通过对用getter方法取得汇总结果。</p><h3 id="2-连接字符串"><a href="#2-连接字符串" class="headerlink" title="2. 连接字符串"></a>2. 连接字符串</h3><p><code>joining</code>工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。</p><p><code>joining</code>方法有3个重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部使用StringBuilder拼接</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param delimiter 表示每个字符串连接时的分隔符</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param delimiter 分隔符</span><br><span class="line"> * @param prefix 字符串前缀</span><br><span class="line"> * @param suffix 字符串后缀</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix);</span><br></pre></td></tr></table></figure><h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h3><p><code>groupingBy</code>：跟数据库中的group by分组操作一样。同时支持多级分组。</p><p><code>groupingBy</code>方法有多个重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用的是带两个参数的groupingBy方法，第二个参数传递的是Collectors.toList()。 </span><br><span class="line"> * @param classifier 一个Function函数型接口。</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用的是三个参数的groupingBy方法。</span><br><span class="line"> * @param classifier 一个Function函数型接口</span><br><span class="line"> * @param downstream 一个收集器对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 有三个参数，groupingBy分组的具体实现。</span><br><span class="line"> *&#x2F;</span><br><span class="line">groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt;M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure><p>可以把第二个<code>groupingBy</code>收集器传递给外层收集器来实现多级分组。 但进一步说，传递给第一个<code>groupingBy</code>的第二个收集器可以是任何类型，而不一定是另一个<code>groupingBy</code>。</p><p>收集器返回的结果可能是Optional包装后的对象，对于多级分组来说，第二个收集器对象参数返回的Optional对象可能没什么用。第一层groupingBy已经把为空的情况给排除掉了。</p><p>Collectors收集器提供了<code>collectingAndThen</code>方法将收集器进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 返回转换后的另一个收集器</span><br><span class="line"> * @param downstream 需要转换的收集器</span><br><span class="line"> * @param finisher 转换函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T,A,RR&gt; Collectors.collectingAndThen(Collector&lt;T,A,R&gt; downstream,Function&lt;R,RR&gt; finisher);</span><br></pre></td></tr></table></figure><p><code>groupingBy</code>可以联合其它收集器使用，经常使用的是mapping方法。它可以让接受特定类型元素的收集器适应不同类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param mapper 一个函数型接口,对流中的元素做映射</span><br><span class="line"> * @param downstream 一个收集器，将映射后的元素收集起来</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper,Collector&lt;? super U, A, R&gt; downstream);</span><br></pre></td></tr></table></figure><h3 id="4-分区"><a href="#4-分区" class="headerlink" title="4. 分区"></a>4. 分区</h3><p><code>partitioningBy</code>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。</p><p>分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它多可以分为两组——true是一组，false是一组。</p><p><code>partitioningBy</code>收集器有两个重载的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 内部调用了两个参数的重载方法，第二个参数传递的是一个Collectors.toList()收集器。</span><br><span class="line"> * @param predicate 断言型接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param predicate 断言型接口</span><br><span class="line"> * @param downstream 收集器</span><br><span class="line"> *&#x2F;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate,Collector&lt;? super T, A, D&gt; downstream);</span><br></pre></td></tr></table></figure><p>分区也可用相同的谓词使用<code>filter</code>筛选来实现。</p><h4 id="分区的好处："><a href="#分区的好处：" class="headerlink" title="分区的好处："></a>分区的好处：</h4><ul><li>保留了分区函数返回true或false的两套流元素列表。</li><li>使用filter筛选需要操作两次，一次利用谓词，一次利用谓词的非。</li></ul><h2 id="第七章：并行数据处理与性能"><a href="#第七章：并行数据处理与性能" class="headerlink" title="第七章：并行数据处理与性能"></a>第七章：并行数据处理与性能</h2><h3 id="并行处理数据一定比串行处理快吗？"><a href="#并行处理数据一定比串行处理快吗？" class="headerlink" title="并行处理数据一定比串行处理快吗？"></a>并行处理数据一定比串行处理快吗？</h3><p>答案是不一定。</p><p>假设你现在要进行数字累加的操作，例如计算1至100万之间所有数字的和。</p><p>现在有三种方案可供选择。</p><p>方案一：原始迭代方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long iterateSum(long n) &#123;</span><br><span class="line">    long result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        result +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：使用<code>Stream</code>串行流处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static long streamSum(long n) &#123;</span><br><span class="line">    Long result &#x3D; Stream.iterate(0L, i -&gt; i + 1)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：使用<code>ParallelStream</code>并行流处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static long parallelSum(long n) &#123;</span><br><span class="line">    Long result &#x3D; Stream.iterate(0L, i -&gt; i + 1)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始迭代方案中不需要对原始类型的数字进行装箱操作。</p><p>串行流方案中利用<code>Stream</code>接口的<code>iterate</code>方法生成0到n的自然数流，默认是串行流，然后归约求和。</p><p>并行流方案中利用<code>Stream</code>接口的<code>iterate</code>方法生成0到n的自然数流，使用<code>parallel</code>方法将流转换成并行流，然后归约求和。</p><p>测试方法：运行10次，取最短时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static long measureSumPerf(Function&lt;Long,Long&gt; adder,long n) &#123;</span><br><span class="line">    long fastest &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        long start &#x3D; System.nanoTime();</span><br><span class="line">        long sum &#x3D; adder.apply(n);</span><br><span class="line">        long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_100_100;</span><br><span class="line">        if (duration &lt; fastest) &#123;</span><br><span class="line">            fastest &#x3D; duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return fastest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; test</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 原始迭代方式更快，它不需要对原始类型进行装箱&#x2F;拆箱操作</span><br><span class="line">    System.out.println(&quot;iterate sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::iterateSum, 100000000));</span><br><span class="line">    &#x2F;&#x2F; iterate生成的是装箱的对象，必须拆箱成数字才能求和。</span><br><span class="line">    System.out.println(&quot;stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::streamSum, 100000000));</span><br><span class="line">    &#x2F;&#x2F; 整个数字在过程开始时并没有准备好，无法有效的把流划分为小块来并行处理。</span><br><span class="line">    System.out.println(&quot;parallel stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::parallelSum, 100000000));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始迭代方案最快：iterate sum min time:11</span><br><span class="line">串行流方案第二快：stream sum min time:198</span><br><span class="line">并行流方案最慢：parallel stream sum min time:267</span><br></pre></td></tr></table></figure><p>可见并行执行并不比串行执行快。但实际上这次试验的很大一部分时间消耗在对原始数据类型进行装箱的操作上。因为<code>Stream</code>接口的<code>iterate</code>方法生成的是包装对象，求和时需要拆箱成数字。同时使用<code>iterate</code>方法在程序开始时并没有把整个数字序列准备好，无法有效的把流划分为小块来并行处理。</p><p>接下来使用原始类型特化流来生成数字流。</p><p>原始类型特化流串行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static long longStreamSum(long n) &#123;</span><br><span class="line">   long result &#x3D; LongStream.rangeClosed(1, n).reduce(0L, Long::sum);</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始类型特化流并行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static long longParallelSum(long n) &#123;</span><br><span class="line">    long result &#x3D; LongStream.rangeClosed(1, n).parallel().reduce(0L, Long::sum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; LongStream.rangeClosed直接产生原始类型的long数字，没有装箱拆箱的开销。</span><br><span class="line">System.out.println(&quot;long stream sum min time:&quot; + measureSumPerf(</span><br><span class="line">    StreamPerformanceTest::longStreamSum,100000000));</span><br><span class="line">&#x2F;&#x2F; LongStream.rangeClosed在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。</span><br><span class="line">System.out.println(&quot;long parallel stream sum min time:&quot; +   measureSumPerf(StreamPerformanceTest::longParallelSum,100000000));</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始类型特化流串行处理：long stream sum min time:7</span><br><span class="line">原始类型特化流并行处理：long parallel stream sum min time:1</span><br></pre></td></tr></table></figure><p><code>LongStream.rangeClosed</code>直接产生原始类型的long数字，没有装箱拆箱的开销。</p><p><code>LongStream.rangeClosed</code>在过程开始时就会生成数字范围，很容易拆分为独立的小块进行并行处理。</p><h3 id="并行流有时候比串行流慢的原因"><a href="#并行流有时候比串行流慢的原因" class="headerlink" title="并行流有时候比串行流慢的原因"></a>并行流有时候比串行流慢的原因</h3><p>并行流有时候比串行流慢的原因：</p><ol><li>没有使用合理的使用数据结构，导致时间浪费在其它非流处理的操作上。</li><li>并行流的底层实现是Fork/Join框架。它是基于多线程的，线程之间进行上下文切换需要耗时。同时线程是操作系统进行调度的。线程自己无法控制时间。</li></ol><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。体现了分治法的思想。Fork的意思是拆分，Join的意思是合并。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和， 最终汇总这10个子任务的结果。Fork/Join框架的运行流程图如下：</p><p><img src="https://i.loli.net/2020/02/15/4YvPn3qOA8BeKtw.jpg" alt="Fork-Join.png"></p><p>Fork/Join的拆分重点在于任务什么时候足够小或不可分，不可再拆分的任务顺序执行，不同的任务之间并行执行。所有不可拆分的子任务分配到多个任务队列中等待线程去执行，每个队列都有一个单独的线程去执行任务。理想情况下，划分并行任务时，应该让每个任务都用相同的时间完成，让所有的CPU都同样繁忙，充分的利用CPU。但实际中，由于线程是由操作系统根据时间片进行调度的，每个子任务所花的时间可能天差地别。于是会出现一个任务队列的任务全部执行完了，另一个队列中还有很多任务的情况。这个时候CPU的利用率没有最大化。Java 8采用工作窃取算法来解决这一问题。</p><h3 id="工作窃取（work-stealing）算法"><a href="#工作窃取（work-stealing）算法" class="headerlink" title="工作窃取（work-stealing）算法"></a>工作窃取（work-stealing）算法</h3><p>工作窃取算法是指某个线程从其它队列中窃取任务来执行。某个线程，自己队列中的任务执行完了，就去别的还有任务的队列中窃取一个任务来执行。这个时候会存在线程竞争关系，窃取线程和被窃取线程之间同时访问同一个队列。通常使用双端队列来解决。被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><h4 id="工作窃取算法的优点："><a href="#工作窃取算法的优点：" class="headerlink" title="工作窃取算法的优点："></a>工作窃取算法的优点：</h4><p>充分利用线程进行并行计算，减少了线程间的竞争。</p><h4 id="工作窃取算法的缺点："><a href="#工作窃取算法的缺点：" class="headerlink" title="工作窃取算法的缺点："></a>工作窃取算法的缺点：</h4><p>在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h3 id="Fork-Join框架的设计思路"><a href="#Fork-Join框架的设计思路" class="headerlink" title="Fork/Join框架的设计思路"></a>Fork/Join框架的设计思路</h3><ol><li>首先需要一个Fork类去把大任务进行递归Fork拆分，直至拆分成不可再分的小任务。</li><li>拆分出来的子任务均匀地分配到n个双端队列中，启动n个线程分别从双端队列中获取任务执行。每个子任务执行完的结果统一放在一个结果队列中，启动一个线程从结果队列中取结果，然后Join合并成最终结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java 8实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（一）：接口重构和新特性</title>
      <link href="2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/"/>
      <url>2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章：重构、测试和调试"><a href="#第八章：重构、测试和调试" class="headerlink" title="第八章：重构、测试和调试"></a>第八章：重构、测试和调试</h2><h3 id="1-为改善可读性和灵活性重构代码"><a href="#1-为改善可读性和灵活性重构代码" class="headerlink" title="1. 为改善可读性和灵活性重构代码"></a>1. 为改善可读性和灵活性重构代码</h3><p>如果方向错了，停下来就是前进。</p><p>看完老员工留下来的代码，无力吐槽。如果以系统稳定可用为原则，不去改善代码可维护性，那等到将来需求变动需要修改时，对我们这些底层码农来说简直是一种折磨。欠下的技术债迟早是要还的。</p><h4 id="1-1-从匿名类到Lambda表达式的转换"><a href="#1-1-从匿名类到Lambda表达式的转换" class="headerlink" title="1.1 从匿名类到Lambda表达式的转换"></a>1.1 从匿名类到Lambda表达式的转换</h4><p>匿名类和Lambda表达式中的<code>this</code>含义是不同的。在匿名类中，this指代的是匿名类本身。但是在Lambda中，<code>this</code>指代的是包含Lambda表达式的类。</p><p>匿名类可以屏蔽包含类的变量，而Lambda表达式不能（编译都不能通过），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testAnonymityToLambda() &#123;</span><br><span class="line">    int a &#x3D; 10;</span><br><span class="line">    Runnable r1 &#x3D; () -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 再次定义a变量会报错</span><br><span class="line">        &#x2F;&#x2F; int a &#x3D; 1;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;;</span><br><span class="line">    Runnable r2 &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int a &#x3D; 2;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-使用Lambda重构设计模式"><a href="#1-2-使用Lambda重构设计模式" class="headerlink" title="1.2 使用Lambda重构设计模式"></a>1.2 使用Lambda重构设计模式</h4><p>Lambda表达式为解决传统设计模式所面对的问题提供了新的解决方案。使用Lambda表达式后， 很多现存的略显臃肿的面向对象设计模式能够用更精简的方式实现了。<br>例如：</p><ul><li>策略模式</li><li>模板方法设计模式</li><li>责任链模式</li><li>工厂模式</li></ul><h3 id="2-测试Lambda表达式"><a href="#2-测试Lambda表达式" class="headerlink" title="2. 测试Lambda表达式"></a>2. 测试Lambda表达式</h3><p>使用Stream接口提供的<code>peek</code>方法可查看流水线中每个操作的中间状态，方便调试排错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void testPeek() &#123;</span><br><span class="line">    List&lt;Integer&gt; nums &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7);</span><br><span class="line">    nums.stream()</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before map&quot; + x))</span><br><span class="line">            .map(x -&gt; x + 17)</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before filter&quot; + x))</span><br><span class="line">            .filter(x -&gt; x % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before limit&quot; + x))</span><br><span class="line">            .limit(3)</span><br><span class="line">            .peek(x -&gt; System.out.println(&quot;before collect&quot; + x))</span><br><span class="line">            .collect(Collectors.toList())</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第九章：默认方法"><a href="#第九章：默认方法" class="headerlink" title="第九章：默认方法"></a>第九章：默认方法</h2><p>先来回顾一下接口的相关知识。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>使用<code>interface</code>关键字声明，访问修饰符可以为<code>public</code>和默认（不写）；同时可以使用<code>abstract</code>关键字修饰，因为接口可以理解成一种完全抽象。使用<code>abstract</code>关键字编译器会让你通过编译，但一般没有人这样做。</p><h4 id="Java-8-前"><a href="#Java-8-前" class="headerlink" title="Java 8 前"></a>Java 8 前</h4><ul><li>接口中的成员变量的修饰符全部默认为<code>public static final</code>，也可以不是静态<code>static</code>的，但一般没有人这样做。</li><li>接口中的方法只能是抽象方法。</li><li>接口中方法的修饰符全部默认为<code>public abstract</code>。</li></ul><h4 id="Java-8-后"><a href="#Java-8-后" class="headerlink" title="Java 8 后"></a>Java 8 后</h4><ul><li>接口中新增默认方法–使用<code>default</code>关键字声明。</li><li>接口中可以声明静态方法。</li></ul><h3 id="为什么要有默认方法？"><a href="#为什么要有默认方法？" class="headerlink" title="为什么要有默认方法？"></a>为什么要有默认方法？</h3><p>如果原来的接口已经被很多人使用了，现在要在原来的接口中新增一个方法，在Java 8之前，所有的实现类都需要去显式实现这个方法，会造成很多不必要的麻烦，也许有些实现类根本就不需要用到新增的这个方法，反而需要强制在代码中写一个显式的空实现。正是由于这个原因，Java 8提供了默认方法，接口中新增的方法使用<code>default</code>关键字修饰，就可以在接口中提供一个默认实现，实现类不再需要强制显式实现这个新增方法。这个新特性主要是面向类库开发者。</p><h3 id="默认方法引发的多实现冲突问题"><a href="#默认方法引发的多实现冲突问题" class="headerlink" title="默认方法引发的多实现冲突问题"></a>默认方法引发的多实现冲突问题</h3><p>一个类只能继承一个父类，但是可以实现多个接口。由于出现了默认方法，当一个类有多个实现时可能会出现方法继承冲突的问题。</p><h3 id="解决问题的三个原则"><a href="#解决问题的三个原则" class="headerlink" title="解决问题的三个原则"></a>解决问题的三个原则</h3><ul><li><p>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p></li><li><p>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。</p></li><li><p>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</p></li></ul><h3 id="冲突情况分析"><a href="#冲突情况分析" class="headerlink" title="冲突情况分析"></a>冲突情况分析</h3><h4 id="情形一"><a href="#情形一" class="headerlink" title="情形一"></a>情形一</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，同时提供自己的默认<code>hello</code>方法。</li><li>实现类<code>ImplClassC</code>实现<code>InterfaceA</code>接口和<code>InterfaceB</code>接口，没有显式实现<code>hello</code>方法。</li></ul><p><img src="https://i.loli.net/2020/02/15/WIXnvM6jawk92zU.png" alt="9-case1.png"></p><p>接口<code>InterfaceB</code>继承了<code>InterfaceA</code>，接口<code>InterfaceB</code>中的<code>hello</code>方法更具体，所以实现类<code>ImplClassC</code>拥有的是<code>InterfaceB</code>接口中的<code>hello</code>方法。</p><h4 id="情形二"><a href="#情形二" class="headerlink" title="情形二"></a>情形二</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，同时提供自己的默认<code>hello</code>方法。</li><li>实现类<code>ImplClassD</code>实现<code>InterfaceA</code>接口，未显式重写接口的<code>hello</code>方法。</li><li>实现类<code>ImplClassC</code>继承<code>ImplClassD</code>类，同时实现<code>InterfaceA</code>和<code>InterfaceB</code>接口，没有显式实现<code>hello</code>方法。</li></ul><p><img src="https://i.loli.net/2020/02/15/e4NTXoVklfH18B3.png" alt="9-case2.png"></p><p><code>ImplClassC</code>和<code>ImplClassD</code>类中都未实现<code>hello</code>方法，<code>InterfaceB</code>继承<code>InterfaceA</code>接口，所以<code>InterfaceB</code>接口中的方法更具体，所以<code>ImplClassC</code>类具有的是<code>InterfaceB</code>中的<code>hello</code>方法。</p><h4 id="情形三"><a href="#情形三" class="headerlink" title="情形三"></a>情形三</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，同时提供自己的默认<code>hello</code>方法。</li><li>实现类<code>ImplClassD</code>实现了<code>InterfaceA</code>接口，并显式重写了接口的<code>hello</code>方法。</li><li>实现类<code>ImplClassC</code>继承了<code>ImplClassD</code>实现类，并实现了<code>InterfaceA</code>和<code>InterfaceB</code>接口，没有显式实现<code>hello</code>方法。</li></ul><p><img src="https://i.loli.net/2020/02/15/XTn2dPVH6ycYmDJ.png" alt="9-case3.png"></p><p><code>ImplClassC</code>和<code>ImplClassD</code>类中都未实现<code>hello</code>方法，<code>InterfaceB</code>继承<code>InterfaceA</code>接口，所以<code>InterfaceB</code>接口中的方法更具体，所以<code>ImplClassC</code>类具有的是<code>InterfaceB</code>中的<code>hello</code>方法。</p><h4 id="情形四"><a href="#情形四" class="headerlink" title="情形四"></a>情形四</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>中定义了默认方法<code>hello</code>，未继承。</li><li>实现类<code>ImplClassC</code>实现<code>InterfaceA</code>和<code>InterfaceB</code>接口。</li></ul><p><img src="https://i.loli.net/2020/02/15/mPzwXtpCIKxqLea.png" alt="9-case4.png"></p><p>如果实现类<code>ImplClassC</code>不重写<code>hello</code>方法，编译器会抛出编译错误：<br><code>ImplClassC inherits unrelated defaults for hello() from types InterfaceA and InterfaceB</code>。</p><p>可以直接在实现类中重新写一个<code>hello</code>方法的实现，也可以使用<code>super</code>关键字调用父接口的默认实现。</p><h4 id="情形五"><a href="#情形五" class="headerlink" title="情形五"></a>情形五</h4><ul><li>接口<code>InterfaceA</code>中定义了默认方法<code>hello</code>。</li><li>接口<code>InterfaceB</code>继承了接口<code>InterfaceA</code>，未提供任何方法。</li><li>接口<code>InterfaceC</code>继承了接口<code>InterfaceA</code>，未提供任何方法。</li><li>实现类<code>ImplClassD</code>实现<code>InterfaceB</code>和<code>InterfaceC</code>接口。</li></ul><p><img src="https://i.loli.net/2020/02/15/DcACmO42doKHy8q.png" alt="9-case5.png"></p><p><code>InterfaceB</code>和<code>InterfaceC</code>接口中都没有<code>hello</code>实现，它们的父接口<code>InterfaceA</code>中才有<code>hello</code>的默认实现，所以实现类<code>ImplClassD</code>拥有接口<code>InterfaceA</code>中<code>hello</code>方法。</p><h4 id="情形五扩展"><a href="#情形五扩展" class="headerlink" title="情形五扩展"></a>情形五扩展</h4><p>如果<code>InterfaceB</code>中也提供<code>hello</code>默认实现，根据规则第二点，编译器会选择<code>InterfaceB</code>中声明的默认方法。</p><p>如果<code>InterfaceB</code>和<code>InterfaceC</code>都提供<code>hello</code>默认实现，就会出现冲突，<code>ImplClassD</code>实现类必须实现<code>hello</code>方法。</p><p>如果<code>InterfaceC</code>接口中添加非默认抽象方法<code>hello</code>，那么它比继承<code>InterfaceA</code>接口而来的<code>hello</code>优先级高，此时实现类<code>ImplClassD</code>必须显式实现<code>InterfaceC</code>的<code>hello</code>抽象方法。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java 8实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（二）：优雅的解决NPE问题</title>
      <link href="2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(2)/"/>
      <url>2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="第十章：用Optional取代null"><a href="#第十章：用Optional取代null" class="headerlink" title="第十章：用Optional取代null"></a>第十章：用Optional取代null</h2><p><code>null</code>引用的想法最初由一位英国计算机科学家提出。他认为这是为”不存在的值“建模最容易的方式。设计初衷是通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的。近些年出现的现代程序设计语言包括Java在内，都采用了相同的设计方式。</p><h3 id="null-引用带来的问题"><a href="#null-引用带来的问题" class="headerlink" title="null 引用带来的问题"></a>null 引用带来的问题</h3><ul><li>错误之源：程序员对对象的字段进行检查，判断字段的值是否为期望的格式，最终却发现访问的并不是一个对象，而是一个<code>null</code>引用–空指针，于是抛出一个<code>NullPointerException</code>异常。</li><li>代码膨胀：为了防止<code>null</code>，我们经常会写出这样类似的代码：<code>if (xxx != null) &#123; // dosomething&#125;</code>。这样你的代码就会充斥着深度嵌套的<code>null</code>检查，代码可读性极差。</li><li>毫无意义：<code>null</code>自身没有任何的语义，尤其是，它代表的是在静态类型语言中以一种错误的方式对缺失变量值的建模。</li><li>破坏哲学：Java一直试图避免让程序员意识到指针的存在，唯一的例外是：null指针。</li></ul><h3 id="使用防御式编程思想减少NPE问题"><a href="#使用防御式编程思想减少NPE问题" class="headerlink" title="使用防御式编程思想减少NPE问题"></a>使用防御式编程思想减少NPE问题</h3><p><code>NullPointerException</code>简称NPE。</p><p>采用防御式编程–快速失败的思想可以有效减少NPE问题。</p><p>如下的代码是推荐的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (param1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">if (param2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; do service</span><br></pre></td></tr></table></figure><p>不要使用<code>try-catch</code>的方式来处理。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    param.function();</span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种防御式编程的方法能有效解决问题，但仍然极易出错，一旦忘记检查那个可能为null的属性就会埋下一个隐藏的bug。</p><h3 id="优雅的解决方式"><a href="#优雅的解决方式" class="headerlink" title="优雅的解决方式"></a>优雅的解决方式</h3><p>Java 8中引入了一个新的类<code>java.util.Optional&lt;T&gt;</code>来优雅的解决NPE问题。</p><p>假设现在有一个<code>Person</code>类，有一个成员变量：汽车<code>Car</code>类；汽车<code>Car</code>类中又有一个成员变量：保险公司<code>Insurance</code>类；保险公司<code>Insurance</code>类中有一个成员变量：<code>String</code>类型的公司名。你可能会按下面的方式设计。<br><code>Person</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private Car car;</span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Car</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    private Insurance insurance;</span><br><span class="line">    public Insurance getInsurance() &#123;</span><br><span class="line">        return insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Insurance</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们知道一个人可能有车也可能没有车，当一个人没车时需要将<code>null</code>引用赋值给<code>car</code>变量，于是我们应该将<code>car</code>变量声明为<code>Optional&lt;Car&gt;</code>类型；一辆车可能买了保险也可能没买保险，于是<code>Car</code>类中的<code>insurance</code>字段也应该声明为<code>Optional&lt;Insurance&gt;</code>类型；保险公司一定有一个公司名称，所以<code>Insurance</code>类中的<code>name</code>字段不用声明成<code>Optional</code>类型。新的类定义如下：<br><code>Person</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Optional&lt;Car&gt; car;</span><br><span class="line">    public Optional&lt;Car&gt; getCar() &#123;</span><br><span class="line">        return car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Car</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Optional&lt;Insurance&gt; insurance;</span><br><span class="line">    public Optional&lt;Insurance&gt; getInsurance() &#123;</span><br><span class="line">        return insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Insurance</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>car</code>变量存在时，<code>Optional</code>类只是对<code>Car</code>类简单封装。当变量不存在时，缺失的值会被建模成一个“空” 的<code>Optional</code>对象，由方法<code>Optional.empty()</code>返回。<code>Optional.empty()</code>方法是一个静态工厂 方法，它返回<code>Optional</code>类的特定单一实例，与<code>null</code>完全不一样。</p><h3 id="何时使用Optional类？"><a href="#何时使用Optional类？" class="headerlink" title="何时使用Optional类？"></a>何时使用Optional类？</h3><p>在实际业务编码中，我们只能靠自己对业务模型的理解进行判断，需要判断出一个<code>null</code>是否属于某个变量的有效范围。</p><p>值得注意的是：如果一个类包含了<code>Optional</code>成员变量，则该类无法进行序列化和反序列化。</p><p>原因是<code>Optional</code>类未实现序列化<code>Serializable</code>接口。所以如果你的类是类似<code>Dubbo</code>服务提供者返回的模型对象，则不能将类成员设计成<code>Optional</code>类型。</p><p>Java语言的架构师Brian Goetz曾经非常明确地陈述过，<code>Optional</code>的设计初衷仅仅是要支持能返回<code>Optional</code>对象的语法。由于<code>Optional</code>类设计时就没特别考虑将其作为类的字段使用，所以它并未实现<code>Serializable</code>接口。</p><h3 id="应用Optional的几种模式"><a href="#应用Optional的几种模式" class="headerlink" title="应用Optional的几种模式"></a>应用Optional的几种模式</h3><h4 id="1-创建Optional对象"><a href="#1-创建Optional对象" class="headerlink" title="1. 创建Optional对象"></a>1. 创建Optional对象</h4><ul><li>声明一个空的<code>Optional</code>：通过静态工厂方法<code>Optional.empty</code>，创建一个空的<code>Optional</code>对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar &#x3D; Optional.empty();</span><br></pre></td></tr></table></figure></li><li>依据一个非空值创建<code>Optional</code>：使用静态工厂方法<code>Optional.of</code>，依据一个非空值创建一个<code>Optional</code>对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar &#x3D; Optional.of(car);</span><br></pre></td></tr></table></figure><p>如果<code>car</code>变量是一个<code>null</code>值，则这段代码会立即抛出<code>NullPointerException</code>，而不是等到试图访问<code>car</code>的属性时才返回一个错误。</p><ul><li>可接受<code>null</code>的<code>Optional</code>：使用静态工厂方法<code>Optional.ofNullalbe</code>，创建一个允许<code>null</code>值的<code>Optional</code>对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Car&gt; optCar &#x3D; Optional.ofNullable(car);</span><br></pre></td></tr></table></figure>如果<code>car</code>变量是一个<code>null</code>值，那么得到的<code>Optional</code>对象就是个空对象。</li></ul><h4 id="2-使用map从Optional对象中提取和转换值"><a href="#2-使用map从Optional对象中提取和转换值" class="headerlink" title="2. 使用map从Optional对象中提取和转换值"></a>2. 使用map从Optional对象中提取和转换值</h4><p><code>Optional</code>类的<code>map</code>方法和<code>Stream</code>类的<code>map</code>方法相差无几。<code>map</code>方法会将流中的每个元素通过提供的函数进行映射。可以把<code>Optional</code>对象看成一个特殊的集合，它最多包含一个元素。如果<code>Optional</code>包含一个值，那map方法就会把该值通过提供的函数映射成其它值，否则什么也不做。</p><h4 id="3-使用flatMap链接Optional对象"><a href="#3-使用flatMap链接Optional对象" class="headerlink" title="3. 使用flatMap链接Optional对象"></a>3. 使用flatMap链接Optional对象</h4><p>同样的，<code>Optional</code>类的<code>flatMap</code>方法和流的用法也类似。<code>flatMap</code>方法接收一个函数作为参数，这个函数的返回值是另一个流。这个函数会应用到流中的每一个元素上，于是每个元素被映射成一个小流，每个小流又形成一个大流作为<code>flatMap</code>方法的返回值。但是<code>flatMap</code>会将这个大流中的小流扁平化成一个单一的流。即流中不包含流，只包含各个元素。</p><h4 id="4-默认行为及解引用Optional对象"><a href="#4-默认行为及解引用Optional对象" class="headerlink" title="4. 默认行为及解引用Optional对象"></a>4. 默认行为及解引用Optional对象</h4><p><code>Optional</code>类提供了多种方法读取<code>Optional</code>实例中的变量值。</p><ul><li><code>get()</code>：如果变量存在，直接返回封装的变量值，否则抛出一个<code>NoSuchElementException</code>异常。</li><li><code>orElse(T other)</code>：允许在<code>Optional</code>对象不包含值时提供一个默认值。</li><li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：是<code>orElse</code>方法的延时调用版，<code>Supplier</code>方法只有在<code>Optional</code>对象不含值时才执行调用。如果创建默认值是件耗时操作，考虑使用该方法；或者非常确定某个方法仅在<code>Optional</code>为空时才执行调用，也考虑使用该方法。</li><li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：和<code>get</code>方法类似，如果取出的值为空都会抛出一个异常，使用<code>orElseThrow</code>可以定制希望抛出的异常类型。</li><li><code>ifPresent(Consumer&lt;? extends T&gt;)</code>：在变量值存在时执行一个传入的<code>Consumer</code>方法，否则不做任何处理。</li></ul><h4 id="5-使用filter剔除特定的值"><a href="#5-使用filter剔除特定的值" class="headerlink" title="5. 使用filter剔除特定的值"></a>5. 使用filter剔除特定的值</h4><p>我们经常需要调用某个对象的方法，查看它的某些属性。比如，我们可能需要检查保险公司的名称是否为<code>CambridgeInsurance</code>，为了以一种安全的方式进行这些操作，我们首先需要确定引用指向的<code>Insurance</code>对象是否为<code>null</code>，之后再调用它的<code>getName</code>方法。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Insurance insurance &#x3D; ...;</span><br><span class="line">if (insurance !&#x3D; null &amp;&amp; &quot;CambridgeInsurance&quot;.equals(insurance.getName())) &#123;</span><br><span class="line">    System.out.println(&quot;ok&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>Optional</code>对象的<code>filter</code>方法，这段代码可以重构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Insurance&gt; optInsurance &#x3D; ...;</span><br><span class="line">optInsurance.filter(ins -&gt; &quot;CambridgeInsurance&quot;.equals(ins.getName()))</span><br><span class="line">.ifPresent(x -&gt; System.out.println(&quot;ok&quot;));</span><br></pre></td></tr></table></figure><p>如果<code>Optional</code>对象包含的值为空，它不做任何操作；反之，它对<code>Optional</code>对象包含的值添加谓词操作，如果该操作的结果为<code>true</code>，它不做任何改变，直接返回该<code>Optional</code>对象，否则就将该值过滤掉，将<code>Optional</code>的值置为空。</p><h3 id="Optional类的方法"><a href="#Optional类的方法" class="headerlink" title="Optional类的方法"></a>Optional类的方法</h3><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">empty</td><td align="left">返回一个空的 Optional 实例</td></tr><tr><td align="left">filter</td><td align="left">如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象；否则返回一个空的 Optional 对象</td></tr><tr><td align="left">flatMap</td><td align="left">如果值存在，就对该值执行提供的mapping映射函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象</td></tr><tr><td align="left">get</td><td align="left">如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常</td></tr><tr><td align="left">ifPresent</td><td align="left">如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td align="left">isPresent</td><td align="left">如果值存在就返回 true，否则返回 false</td></tr><tr><td align="left">map</td><td align="left">如果值存在，就对该值执行提供的 mapping映射函数调用</td></tr><tr><td align="left">of</td><td align="left">将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常</td></tr><tr><td align="left">ofNullable</td><td align="left">将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象</td></tr><tr><td align="left">orElse</td><td align="left">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="left">orElseGet</td><td align="left">如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值</td></tr><tr><td align="left">orElseThrow</td><td align="left">如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td></tr></tbody></table><h3 id="基础类型的Optional对象，以及为什么应该避免使用它们"><a href="#基础类型的Optional对象，以及为什么应该避免使用它们" class="headerlink" title="基础类型的Optional对象，以及为什么应该避免使用它们"></a>基础类型的Optional对象，以及为什么应该避免使用它们</h3><p>与<code>Stream</code>对象一样，<code>Optional</code>也提供了类似的基础类型：<code>OptionalInt</code>、<code>OptionalLong</code>以及<code>OptionalDouble</code>。</p><p>如果<code>Stream</code>对象包含了大量元素，出于性能的考量， 使用基础类型是不错的选择，但对于<code>Optional</code>对象而言，这个理由就不成立了，因为<code>Optional</code>对象多只包含一个值。</p><p>不推荐大家使用基础类型的<code>Optional</code>对象，因为基础类型的<code>Optional</code>不支持<code>map</code>、<code>flatMap</code>和<code>filter</code>等方法。而这些却是<code>Optional</code>类最有用的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java 8实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（三）：从一个生产环境的事故到异步编程思想</title>
      <link href="2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(3)/"/>
      <url>2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(3)/</url>
      
        <content type="html"><![CDATA[<h2 id="第十一章：CompletableFuture组合式异步编程"><a href="#第十一章：CompletableFuture组合式异步编程" class="headerlink" title="第十一章：CompletableFuture组合式异步编程"></a>第十一章：CompletableFuture组合式异步编程</h2><p>在介绍这部分内容之前，先介绍一下由于我和另外一位开发人员的考虑不周造成的一次线上事故场景（考虑企业隐私，屏蔽了一些关键词）。</p><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>卡劵系统的后台管理系统，用于处理用户投诉补偿以及发错券补偿的场景。</p><h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>两种情况会使用到这次我们开发的功能。</p><ol><li>可能会出现用户投诉未领取到优惠券的情况，这个时候直接给用户补发一张。避免浪费人力去查线上日志找原因。</li><li>运营人员操作失误发错劵，需要手动给用户补发劵。</li></ol><p>由于功能急需上线，产品经理想尽量简化开发，设计的轻量化一些，不将补发记录入库。每次补发完成页面就显示成功多少个，失败多少个，失败的UIDs是哪些。</p><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><ol><li>一个补发劵页面，运营人员首先输入劵ID查询劵信息，包含劵名称和可用库存。</li><li>上传需要进行补发的UIDs到后台进行解析（解析的过程就是去数据库中查是否存在该UID对应的用户）。</li><li>给有效的UIDs对应的用户进行劵补发操作，调用发劵接口。</li><li>等待所有用户全部调用发劵接口完毕，记录失败的UIDs，响应给前端。</li></ol><h3 id="事故分析"><a href="#事故分析" class="headerlink" title="事故分析"></a>事故分析</h3><ul><li><p>事故描述：运营人员上传了250个用户UID进行补发劵，点击补发按钮，等待了约2分钟页面显示失败了215个UID。</p></li><li><p>排查情况：线上环境将应用部署到了2台服务器。我们在A和B两台服务器的日志上都查到了补发请求相关日志。服务器A上的日志显示补发失败35条，服务器B上的日志显示补发失败215条。</p></li><li><p>原因分析：</p><ul><li>A服务器上的日志显示控制器层接收到请求的时刻是：<code>2019-09-06 10:51:19.075</code>，响应请求的时刻是：<code>2019-09-06 10:52:40.171</code>；</li><li>B服务器上的日志显示控制器层接收到请求的时刻是：<code>2019-09-06 10:52:19.061</code>，响应请求的时刻是：<code>2019-09-06 10:52:40.022</code>。</li><li>A服务器上记录的失败的35个UIDs在B服务器上发劵成功；B服务器上记录的失败的215个UIDs在A服务器上发劵成功。另外从日志中可看出发劵接口做了幂等校验。</li></ul></li></ul><p>初步排查：由于后端服务器接收到了两个请求，判断是否运营人员点了两次补发按钮？经过对前端页面的测试，点了一次补发按钮后，页面出现loading遮罩层，不能第二次点击补发按钮。排除运营人员操作的问题。</p><p>进一步分析：A和B两台服务器接收到请求的时间间隔恰好是1分钟左右，是否是前端Ajax请求的响应超时会自动重试？由于前端页面是使用jQuery发送Ajax请求，并且请求类型是POST，浏览器并不会自动重试。</p><p>最终得出结论：在向指导人请教后，推测是线上环境有Nginx进行负载均衡，当ajax请求得到响应的时间超过Nginx默认的60秒时，请求会自动重发到另一台服务器。向部门经理确认系统架构后，线上环境确实存在负载均衡，使用的是阿里的SLB。（由于我们刚接手该项目，对线上环境还不太熟悉）阿里的SLB开启了超时自动重发机制，超时时间是60秒。</p><h3 id="事故结论"><a href="#事故结论" class="headerlink" title="事故结论"></a>事故结论</h3><p>一个补发劵的请求经过SLB负载均衡到后端服务器，后端服务器执行业务代码时间超过了一分钟，过了60秒后，SLB认为该请求超时，触发重试机制，将同样的请求负载到另外一台后端服务器上，两台服务器上的线程开始并发调用发劵接口，由于发劵接口做了接口幂等性校验，所以并未出现发劵重复的情况。最终250个UIDs都成功的完成了补发。</p><ul><li>解决方案：<ul><li>运营人员每次上传少量UIDs，保证响应时间小于60秒。</li><li>产品经理提出迭代需求，版本升级。</li></ul></li></ul><h3 id="值得思考的问题"><a href="#值得思考的问题" class="headerlink" title="值得思考的问题"></a>值得思考的问题</h3><p>产品经理提出需求时，说要简化开发，设计轻量化等。但我们作为Java开发工程师，我们不能和产品经理想的一样，将系统想的过于简化。仍然要从一个程序的角度出发来考虑问题。</p><h3 id="代码升级方案"><a href="#代码升级方案" class="headerlink" title="代码升级方案"></a>代码升级方案</h3><p>我们知道，在原生安卓项目开发中，所有的网络请求都必须在子线程中执行。</p><p>安卓为什么要这样限制呢？我想，安卓一定是考虑到所有的网络请求都是有可能出现超时的，即使网络请求只是去简单的获取一个资源，但仍可能会出现网络延迟的情况。如果在主线程中执行，一旦出现延迟或者超时，给用户的感觉就是界面卡住。于是安卓进行了异步化设计。限制网络请求只能在子线程中执行。</p><p>对于Web应用系统，如果有执行时间较长的请求，我们也要尽量将其放在子线程中执行。避免因为等待远程服务的返回，或者对数据库的查询，而阻塞主线程的执行，浪费宝贵的计算资源，影响用户体验。</p><p>这次线上事故的根本原因就是开发经验不足，考虑不周，不了解线上情况，未进行异步化设计。由于一次请求需要补发较多的用户，导致一次HTTP请求迟迟未完成三次握手四次挥手过程，SLB服务器认为请求超时，触发了重试机制，将同样的请求打到另外一台服务器上。</p><p>在Java语言中，<code>Future</code>接口，尤其是它在Java 8中的新版实现<code>CompletableFuture</code>，是进行异步化设计的利器。</p><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p><code>Future</code>接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在<code>Future</code>中触发那些潜在耗时的操作把调用线程解放出来，让它能及时响应客户端或者继续执行其它有价值的工作，不再需要呆呆的等到耗时的操作完成。</p><p>上述补发劵业务最初的同步代码大致如下（考虑企业隐私，屏蔽关键词）：</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 同步 劵补发操作</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @return 失败的用户UID集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; syncReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    List&lt;String&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;UserInfoModel&gt; userInfoModelList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 循环验证UID有效性</span><br><span class="line">    for (String uId : uIds) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询UID对应用户信息</span><br><span class="line">        UserInfoModel userInfoModel &#x3D; reSupplyCouponService.queryUserInfo(uId);</span><br><span class="line">        if (userInfoModel !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; UID存在，放入待进行补发用户集合</span><br><span class="line">            userInfoModelList.add(userInfoModel);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; UID不存在，放入返回结果集合</span><br><span class="line">            result.add(uId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 循环进行劵补发</span><br><span class="line">    for (UserInfoModel userInfoModel : userInfoModelList) &#123;</span><br><span class="line">        Boolean flag &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            flag &#x3D; reSupplyCouponService.reSupplyCoupon(couponId,userInfoModel.getUid());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 异常处理</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            &#x2F;&#x2F; 补发劵失败，放入返回结果集合</span><br><span class="line">            result.add(userInfoModel.getUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查询用户信息</span><br><span class="line"> * @param uId 用户UID</span><br><span class="line"> * @return 用户信息model</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public UserInfoModel queryUserInfo(String uId) &#123;</span><br><span class="line">    return reSupplyCouponIntegration.queryUserInfo(uId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 补发劵操作</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @param uId 用户ID</span><br><span class="line"> * @return 补发结果：成功或失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Boolean reSupplyCoupon(String couponId, String uId) &#123;</span><br><span class="line">    return reSupplyCouponIntegration.reSupplyCoupon(couponId,uId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Integration</code>防腐层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;UserInfoModel&gt; users &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化操作，模拟远程用户数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">static &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 250; i++) &#123;</span><br><span class="line">        users.add(new UserInfoModel(String.valueOf(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 模拟查找用户操作，不存在则UID则新增一个。</span><br><span class="line"> * @param uId 用户UID</span><br><span class="line"> * @return 用户信息model</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public UserInfoModel queryUserInfo(String uId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟调用远程服务耗时</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return users.get(Integer.valueOf(uId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 模拟补发劵操作</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @param uId 用户id</span><br><span class="line"> * @return 补发劵结果：成功或失败</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Boolean reSupplyCoupon(String couponId, String uId) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟调用远程服务耗时</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 模拟成功或失败概率</span><br><span class="line">    return new Random().nextInt(100) &lt; 90;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段同步执行的代码中存在的问题：包含2个for循环中通过RPC调用远程服务提供方进行数据库操作，如果UID集合数据量较大，这个方法的执行时间是非常长的，例如这次事故中运营人员上传了250个UID，执行时间就花了2分钟左右。耗时过长，SLB负载均衡服务器认为请求超时，进行重试。</p><p>使用Future接口进行代码异步化改造：将耗时的操作封装到一个<code>Callable</code>对象中，再将它提交给ExecutorService线程池。</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 初始化线程池</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 声明Future</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Future&lt;List&lt;String&gt;&gt; future;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用Callable封装耗时操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">class AsyncReSupplyCouponCallable implements Callable&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过构造函数间接传递参数给call方法</span><br><span class="line">    private List&lt;String&gt; uIds;</span><br><span class="line">    private String couponId;</span><br><span class="line">    public AsyncReSupplyCouponCallable(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">        this.uIds &#x3D; uIds;</span><br><span class="line">        this.couponId &#x3D; couponId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; call() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用同步的补发劵方法</span><br><span class="line">        return syncReSupplyCoupon(uIds,couponId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 异步 劵补发操作 基于JDK 5的Future接口</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void asyncFutureReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    future &#x3D; executorService.submit(new AsyncReSupplyCouponCallable(uIds,couponId));</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取补发劵失败的UIDs在前端显示</span><br><span class="line"> * 由前端控制调用该方法的时机</span><br><span class="line"> * 根据上传的UIDs数量做轮询，时间可以设置久一点。</span><br><span class="line"> * @return 补发失败的UID集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; getFailedUIDs() &#123;</span><br><span class="line">    List&lt;String&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (future !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果调用get方法时，Callable中的任务还未执行完，则线程阻塞在这里。</span><br><span class="line">            &#x2F;&#x2F; 使用重载的get方法设置超时时间为50秒。如果发生阻塞，则最多等待50秒后退出。</span><br><span class="line">            result &#x3D; future.get(50, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程等待过程中被中断</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算抛出一个异常</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在Future对象完成之前超时已过期</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步化改造基本已经完成。以上代码已经能够有效避免这次线上事故再次发生了。</p><h3 id="接口性能提升"><a href="#接口性能提升" class="headerlink" title="接口性能提升"></a>接口性能提升</h3><p>基于<code>Future</code>接口的异步改造已经能够避免事故再次发生，但是耗时的补发劵操作在子线程执行仍然是同步的。子线程中验证同步执行验证250个UIDs是否合法，给250个用户补发劵。耗时仍然很长。如何提升接口的性能呢？如果让不同的UID之间的操作并行，则可显著提升性能。</p><h3 id="方案一：使用Java-8的并行流"><a href="#方案一：使用Java-8的并行流" class="headerlink" title="方案一：使用Java 8的并行流"></a>方案一：使用Java 8的并行流</h3><p>利用Java 8的并行流避免每个UID的顺序执行。</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用并行流 补发劵</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @return 补发失败的用户UIDs集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; parallelReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    List&lt;String&gt; failUidList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 使用并行流验证UID是否合法，按是否合法进行分区：不存在的为true区</span><br><span class="line">    Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; userInfoModelMap &#x3D; uIds.parallelStream()</span><br><span class="line">            .map(uId -&gt; reSupplyCouponService.queryUserInfo(uId))</span><br><span class="line">            .collect(Collectors.partitioningBy(Objects::isNull));</span><br><span class="line">    &#x2F;&#x2F; 取出不合法的UID加入补发失败的集合中</span><br><span class="line">    userInfoModelMap.get(true)</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList()); &#x2F;&#x2F; 触发中间操作</span><br><span class="line">    &#x2F;&#x2F; 取出合法的UID进行补发劵操作</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; reSupplyCouponResult &#x3D; userInfoModelMap.get(false)</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .map(userInfoModel -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 从补发劵结果中取出补发失败的加入补发失败的集合中</span><br><span class="line">    reSupplyCouponResult.parallelStream()</span><br><span class="line">            .filter(map -&gt; !(Boolean) map.get(&quot;result&quot;))</span><br><span class="line">            .map(map -&gt; failUidList.add(String.valueOf(map.get(&quot;uId&quot;))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return failUidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础Service层中新增接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 补发劵操作</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @param uId 用户ID</span><br><span class="line"> * @return [UID,&quot;成功或失败&quot;]，返回对应UID。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Map&lt;String, Object&gt; reSupplyCouponWithUid(String couponId, String uId) &#123;</span><br><span class="line">    Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;uId&quot;,uId);</span><br><span class="line">    Boolean result &#x3D; reSupplyCouponIntegration.reSupplyCoupon(couponId,uId);</span><br><span class="line">    map.put(&quot;result&quot;,result);</span><br><span class="line">    return map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：使用Java-8的CompletableFuture接口"><a href="#方案二：使用Java-8的CompletableFuture接口" class="headerlink" title="方案二：使用Java 8的CompletableFuture接口"></a>方案二：使用Java 8的CompletableFuture接口</h3><p>利用Java 8的<code>CompletableFuture</code>接口异步化。每一个UID的操作之间都是异步的。</p><p>需要对所有的<code>CompletableFuture</code>对象执行<code>join</code>操作，一个一个等待它们执行完毕。<code>CompletableFuture</code>类中的<code>join</code>方法和<code>Future</code>接口中的<code>get</code>方法有相同的含义，并且也声明在<code>Future</code>接口中，唯一的不同是<code>join</code>方法不会抛出任何检测到的异常。所以不会显得Lambda表达式过于臃肿。</p><p>业务Service层代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 异步 劵补发操作 每一个UID之间都是异步的 基于JDK 8的CompletableFuture接口</span><br><span class="line"> * @param uIds</span><br><span class="line"> * @param couponId</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; asyncCompletableFutureReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123; </span><br><span class="line">    List&lt;String&gt; failUidList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 使用CompletableFuture异步操作：验证UID是否存在系统中</span><br><span class="line">    List&lt;CompletableFuture&lt;UserInfoModel&gt;&gt; list &#x3D; uIds.stream()</span><br><span class="line">            .map(uId -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.queryUserInfo(uId))</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，分区筛选出存在的UIDs和不存在的UIDs</span><br><span class="line">    Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; joinMap &#x3D; list.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.partitioningBy(Objects::isNull));</span><br><span class="line">    &#x2F;&#x2F; 将不存在的UIDs加入补发失败的集合中</span><br><span class="line">    joinMap.get(true)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 使用CompletableFuture异步给存在的UIDs补发劵</span><br><span class="line">    List&lt;CompletableFuture&lt;Map&lt;String, Object&gt;&gt;&gt; reSupplyCouponResult &#x3D; joinMap.get(false)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()))</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，筛选出补发劵失败的UIDs存入返回结果集合中</span><br><span class="line">    reSupplyCouponResult.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .filter(r -&gt; !(Boolean) r.get(&quot;result&quot;))</span><br><span class="line">            .map(r -&gt; failUidList.add(String.valueOf(r.get(&quot;uId&quot;))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return failUidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较并行流和异步接口的快慢"><a href="#比较并行流和异步接口的快慢" class="headerlink" title="比较并行流和异步接口的快慢"></a>比较并行流和异步接口的快慢</h3><p>初始化8个UID进行测试。</p><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;String&gt; uIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化8个UIDs，模拟待补发用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">static &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">        uIds.add(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试使用Java 8的并行流进行的补发劵操作</span><br><span class="line"> *</span><br><span class="line"> * 8个UID</span><br><span class="line"> * done in 312msecs</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testParallelReSupplyCoupon() &#123;</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;String&gt; failedUIDs &#x3D; reSupplyCouponBizService.parallelReSupplyCoupon(uIds, &quot;1&quot;);</span><br><span class="line">    long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">    System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;);</span><br><span class="line">    failedUIDs.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试 异步 劵补发操作 每一个UID之间都是异步的 基于JDK 8的CompletableFuture接口</span><br><span class="line"> *</span><br><span class="line"> * 8个UID</span><br><span class="line"> * done in 610msecs</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testAsyncCompletableFutureReSupplyCoupon() &#123;</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;String&gt; failedUIDs &#x3D; reSupplyCouponBizService.asyncCompletableFutureReSupplyCoupon(uIds, &quot;1&quot;);</span><br><span class="line">    long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">    System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;);</span><br><span class="line">    failedUIDs.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果让人相当失望。使用<code>CompletableFuture</code>新接口的耗时大约是使用并行流版本的两倍。难道这种场景下使用<code>CompletableFuture</code>真的是浪费时间吗？也许我们漏掉了某些很重要的东西？我们运行测试代码的电脑是否足以以并行方式运行8个线程？</p><p>并行流的版本运行的足够快，那是因为它能并行的执行的8个线程，它能为每个UID的操作分配一个线程。但是，如果现在我们初始化9个UID进行测试，我们来看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并行流版本</span><br><span class="line">9个UID</span><br><span class="line">done in 617msecs</span><br><span class="line"></span><br><span class="line">异步接口版本</span><br><span class="line">9个UID</span><br><span class="line">done in 611msecs</span><br></pre></td></tr></table></figure><p>并行流版本9个UID的测试结果比之前大概多消耗了3秒，这个时间间隔刚好是一次模拟调用远程服务接口的耗时。因为可以并行运行的8个线程开始都处于工作状态，都在对前8个UID进行补发劵等操作。第9个UID的操作只能等到前面某个操作完成释放出空闲线程才能继续。</p><p>异步接口版本的测试结果和并行流版本相差无几。究其原因都一样：它们内部采用的是同样的通用线程池，默认都使用固定数量的线程，具体线程数取决于<code>Runtime.getRuntime().availableProcessors()</code>的返回值。然而，<code>CompletableFuture</code>具有一定优势，它可以定制执行器，自定义线程池的大小。这是并行流API无法实现的。</p><h3 id="定制异步接口的执行器"><a href="#定制异步接口的执行器" class="headerlink" title="定制异步接口的执行器"></a>定制异步接口的执行器</h3><p>创建一个配有线程池的执行器很容易，但是我们该如何选择合适的线程数目呢？</p><blockquote><p>《Java并发编程实战》书中介绍到，Brian Goetz和合著者们为线程池大小的优化提供了不少中肯的建议。这非常重要，如果线程池中线程的数量过多，最终它们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。Brian Goetz建议，线程池大小与处理器的利用率之比可以使用下面的公式进行估算：<br><strong>N</strong><sub>threads</sub> = <strong>N</strong><sub>CPU</sub> * <strong>U</strong><sub>CPU</sub> * (1 + <strong>W</strong>/<strong>C</strong>)<br>其中：</p><ul><li><strong>N</strong><sub>threads</sub>是处理器的核的数目，可以通过<code>Runtime.getRuntime().availableProcessors()</code>得到；</li><li><strong>U</strong><sub>CPU</sub>是期望的CPU利用率（该值应该介于0和1之间）</li><li><strong>W</strong>/<strong>C</strong>是等待时间与计算时间的比率</li></ul></blockquote><p>补发劵接口99%的时间都在等待远程服务的响应，所以估算出的W/C的比率为100。如果期望的CPU利用率为100%，则需要创建一个拥有800个线程的线程池。但实际上，线程池中的有些线程根本没机会被使用，反而是一种浪费。所以建议将执行器使用的线程数，与实际需要的线程数（UIDs的数量）设定为同样的值。这样每个UID都对应一个服务线程。但是，当UIDs数量过大时，运行代码的机器必然会因超负荷而崩溃，所以最好还是有一个上限。</p><p>业务Service层相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定制执行器-线程池大小为UIDs的数量：设置为守护线程，当程序退出时，线程也会被回收。</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final Executor executor &#x3D; Executors.newFixedThreadPool(125, r -&gt; &#123;</span><br><span class="line">    Thread t &#x3D; new Thread(r);</span><br><span class="line">    t.setDaemon(true);</span><br><span class="line">    return t;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 异步 劵补发操作 定制CompletableFuture接口的执行器</span><br><span class="line"> * @param uIds 用户UID集合</span><br><span class="line"> * @param couponId 优惠券ID</span><br><span class="line"> * @return 补发失败的用户UID集合</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public List&lt;String&gt; asyncCompletableFutureCustomExecutorReSupplyCoupon(List&lt;String&gt; uIds, String couponId) &#123;</span><br><span class="line">    List&lt;String&gt; failUidList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 使用定制执行器的CompletableFuture异步操作：验证UID是否存在系统中</span><br><span class="line">    List&lt;CompletableFuture&lt;UserInfoModel&gt;&gt; list &#x3D; uIds.stream()</span><br><span class="line">            .map(uId -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.queryUserInfo(uId),executor)</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，分区筛选出存在的UIDs和不存在的UIDs</span><br><span class="line">    Map&lt;Boolean, List&lt;UserInfoModel&gt;&gt; joinMap &#x3D; list.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.partitioningBy(Objects::isNull));</span><br><span class="line">    &#x2F;&#x2F; 将不存在的UIDs加入补发失败的集合中</span><br><span class="line">    joinMap.get(true)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; failUidList.add(userInfoModel.getUid()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 使用定制执行器的CompletableFuture异步给存在的UIDs补发劵</span><br><span class="line">    List&lt;CompletableFuture&lt;Map&lt;String, Object&gt;&gt;&gt; reSupplyCouponResult &#x3D; joinMap.get(false)</span><br><span class="line">            .stream()</span><br><span class="line">            .map(userInfoModel -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; reSupplyCouponService.reSupplyCouponWithUid(couponId, userInfoModel.getUid()),executor)</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line">    &#x2F;&#x2F; 等待所有异步操作执行结束，筛选出补发劵失败的UIDs存入返回结果集合中</span><br><span class="line">    reSupplyCouponResult.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .filter(r -&gt; !(Boolean) r.get(&quot;result&quot;))</span><br><span class="line">            .map(r -&gt; failUidList.add(String.valueOf(r.get(&quot;uId&quot;))))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    return failUidList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用125个UID进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;String&gt; uIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化操作，模拟待补发用户</span><br><span class="line"> *&#x2F;</span><br><span class="line">static &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 125; i++) &#123;</span><br><span class="line">        uIds.add(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试 异步 劵补发操作 定制CompletableFuture接口的执行器</span><br><span class="line"> *</span><br><span class="line"> * 125个UID</span><br><span class="line"> * done in 369msecs</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testAsyncCompletableFutureCustomExecutorReSupplyCoupon() &#123;</span><br><span class="line">    long start &#x3D; System.nanoTime();</span><br><span class="line">    List&lt;String&gt; failedUIDs &#x3D; reSupplyCouponBizService.asyncCompletableFutureCustomExecutorReSupplyCoupon(uIds, &quot;1&quot;);</span><br><span class="line">    long duration &#x3D; (System.nanoTime() - start) &#x2F; 1_000_000;</span><br><span class="line">    System.out.println(&quot;done in &quot; + duration + &quot;msecs&quot;);</span><br><span class="line">    failedUIDs.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<code>done in 369msecs</code>，显而易见，耗时和8个UID的并行流版本很接近。性能显著提升。一般而言，随着UID数量继续增多，耗时不会相差太多，直到达到之前计算的阈值800（CPU利用率达到100%）。</p><h3 id="在并行流和CompletableFuture之间进行选择"><a href="#在并行流和CompletableFuture之间进行选择" class="headerlink" title="在并行流和CompletableFuture之间进行选择"></a>在并行流和CompletableFuture之间进行选择</h3><p>并行流底层的Fork/Join框架使用通用的线程池，无法个性化定制。新的<code>CompletableFuture</code>接口可以定制执行器，调整线程池大小，能够更加充分的利用CPU资源。</p><p>建议如下：</p><blockquote><ul><li>如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实<br>现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要<br>创建比处理器核数更多的线程）。</li><li>反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用<br>CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者<br>W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的<br>流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，建议进行异步化设计，使用<code>CompletableFuture</code>类提供的特性可轻松实现异步API。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java 8实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8实战》读书笔记系列——第三部分：高效Java 8编程（四）：使用新的日期时间API</title>
      <link href="2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(4)/"/>
      <url>2019/12/12/reading-notes/java8-in-action/Part-III-Efficient-Java8-Programming(4)/</url>
      
        <content type="html"><![CDATA[<h2 id="第十二章：新的日期时间API"><a href="#第十二章：新的日期时间API" class="headerlink" title="第十二章：新的日期时间API"></a>第十二章：新的日期时间API</h2><p>在Java 8之前，我们常用的日期时间API是<code>java.util.Date</code>和<code>java.util.Calendar</code>这两个类。</p><p>如果我们要构建一个指定年月日的日期时间对象，比如<code>2019-9-2</code>，使用<code>java.util.Date</code>类的构造方法<code>Date(int year, int month, int date)</code>，传入的年份year参数必须是年份2019减去1900，即传入119。每次创建对象前还需要先进行计算，很不方便。</p><p>JDK 1.1提供的<code>java.util.Calendar</code>类在使用时也有很多不方便的地方，比如对一个日期加两天，使用<code>add</code>方法，传入2；对一个日期减两天，也使用<code>add</code>方法，传入-2。还有一点是这个类默认每周第一天是周日。使用起来也有点不方便。</p><p>归根到底，JDK1.8之前的日期时间API都是可变的，是线程不安全的。</p><p>另外，对时间日期进行格式化的类<code>SimpleDateFormat</code>在<code>java.text</code>包下，该类的定义位置不规范。它也是线程不安全的。</p><p>而在Java 8中，时间格式转化器是<code>java.time.format.DateTimeFormatter</code>类，它被声明为<code>final</code>，是不可变的类，线程安全。</p><p>另外，Java 8中提供的新日期时间API包含两类：一个是为了便于人阅读使用，包含<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>这三个类，它们都是用<code>final</code>修饰的类，是不可变的对象，分别表示<code>ISO-8601</code>日历系统中的日期、时间、日期和时间。另外一个是便于机器处理的类，<code>Instant</code>：用来表示机器的日期和时间格式：时间戳。</p><blockquote><p>ISO-8601日历系统：是国际标准化组织制定的现代公民的日期和时间的表示法。<br>时间戳：从UNIX元年：1970年1月1日 00:00:00到某个时间之间的毫秒值。</p></blockquote><h3 id="传统时间格式转换器SimpleDateFormat线程安全问题演示"><a href="#传统时间格式转换器SimpleDateFormat线程安全问题演示" class="headerlink" title="传统时间格式转换器SimpleDateFormat线程安全问题演示"></a>传统时间格式转换器SimpleDateFormat线程安全问题演示</h3><p>当多个线程同时操作同一个<code>SimpleDateFormat</code>对象时，就会出现线程安全问题。</p><p>演示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    &#x2F;&#x2F; 使用线程池模拟多线程</span><br><span class="line">    ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">    &#x2F;&#x2F; 定义解析日期字符串任务：使用SimpleDateFormat对象解析</span><br><span class="line">    Callable&lt;Date&gt; task &#x3D; () -&gt; sdf.parse(&quot;2019-8-29&quot;);</span><br><span class="line">    &#x2F;&#x2F; 存储结果容器</span><br><span class="line">    List&lt;Future&lt;Date&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行得到解析结果</span><br><span class="line">        result.add(threadPool.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遍历输出</span><br><span class="line">    for (Future&lt;Date&gt; r : result) &#123;</span><br><span class="line">        System.out.println(r.get());</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.NumberFormatException: multiple points</span><br></pre></td></tr></table></figure><p>解决方法：<br>1、将<code>SimpleDateFormat</code>定义为方法内的局部变量，且方法中没有多线程的操作。<br>2、使用<code>ThreadLocal</code>进行线程封闭。为每个线程保存一个<code>SimpleDateFormat</code>对象。</p><h3 id="传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭"><a href="#传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭" class="headerlink" title="传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭"></a>传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭</h3><p>线程封闭类代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package cn.org.lilu.chapter12;</span><br><span class="line"></span><br><span class="line">import java.text.DateFormat;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: lilu</span><br><span class="line"> * @Date: 2019&#x2F;8&#x2F;29</span><br><span class="line"> * @Description: 传统时间格式转换器线程安全问题解决方案：使用ThreadLocal进行线程封闭</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TraditionalSimpleDateFormatThreadLocal &#123;</span><br><span class="line">    private static final ThreadLocal&lt;DateFormat&gt; threadLocal &#x3D; new ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected DateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static Date convert(String source) throws Exception &#123;</span><br><span class="line">        return threadLocal.get().parse(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用线程池模拟多线程</span><br><span class="line">    ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">    &#x2F;&#x2F; 定义解析日期字符串任务：每个任务都有一份SimpleDateFormat对象的副本</span><br><span class="line">    Callable&lt;Date&gt; task &#x3D; () -&gt; TraditionalSimpleDateFormatThreadLocal.convert(&quot;2019-8-29&quot;);</span><br><span class="line">    &#x2F;&#x2F; 解析结果容器</span><br><span class="line">    List&lt;Future&lt;Date&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行得到解析结果</span><br><span class="line">        result.add(threadPool.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遍历输出</span><br><span class="line">    for (Future&lt;Date&gt; r : result) &#123;</span><br><span class="line">        System.out.println(r.get());</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果正常。</p><h3 id="Java-8新的时间格式转化器DateTimeFormatter"><a href="#Java-8新的时间格式转化器DateTimeFormatter" class="headerlink" title="Java 8新的时间格式转化器DateTimeFormatter"></a>Java 8新的时间格式转化器DateTimeFormatter</h3><p><code>DateTimeFormatter</code>类定义在<code>java.time.format</code>包下，且声明为<code>final</code>类，不可变，线程安全。</p><p>代码演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 按照哪种格式进行格式转换</span><br><span class="line">    &#x2F;&#x2F; DateTimeFormatter dtf &#x3D; DateTimeFormatter.ISO_LOCAL_DATE;</span><br><span class="line">    DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;);</span><br><span class="line">    &#x2F;&#x2F; LocalDate.parse(&quot;20190829&quot;,dtf)：将第一个字符串参数按照第二个参数定义的格式器解析，返回一个LocalDate对象</span><br><span class="line">    Callable&lt;LocalDate&gt; task &#x3D; () -&gt; LocalDate.parse(&quot;20190829&quot;,dtf);</span><br><span class="line">    ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">    List&lt;Future&lt;LocalDate&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result.add(threadPool.submit(task));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遍历输出</span><br><span class="line">    for (Future&lt;LocalDate&gt; r : result) &#123;</span><br><span class="line">        System.out.println(r.get());</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-8日期时间API：LocalDate、LocalTime、LocalDateTime"><a href="#Java-8日期时间API：LocalDate、LocalTime、LocalDateTime" class="headerlink" title="Java 8日期时间API：LocalDate、LocalTime、LocalDateTime"></a>Java 8日期时间API：LocalDate、LocalTime、LocalDateTime</h3><p>这三个类的用法几乎一样，<code>LocalDate</code>表示日期，<code>LocalTime</code>表示时间，<code>LocalDateTime</code>包含前两者，表示日期和时间。</p><p>可由前两个类组合出第三个类，也可由第三个类提取出前两个类。</p><h4 id="年月日对象：LocalDate"><a href="#年月日对象：LocalDate" class="headerlink" title="年月日对象：LocalDate"></a>年月日对象：LocalDate</h4><p>可使用静态工厂方法<code>now</code>获取当前日期；</p><p>可使用静态工厂方法<code>of</code>创建一个<code>LocalDate</code>日期对象，可从一个<code>LocalDate</code>日期对象中获取该日期的年份、月份、这个月的第几天、这周的星期几、今年的第几天、这个月的长度（有几天）和是否为闰年等信息。</p><p>代码演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalDate：年月日</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLocalDate() &#123;</span><br><span class="line">    &#x2F;&#x2F; 静态工厂方法now获取当前日期</span><br><span class="line">    LocalDate now &#x3D; LocalDate.now();</span><br><span class="line">    &#x2F;&#x2F; 静态工厂方法of创建一个LocalDate实例</span><br><span class="line">    LocalDate date &#x3D; LocalDate.of(2019,8,26);</span><br><span class="line">    &#x2F;&#x2F; 年份</span><br><span class="line">    int year &#x3D; date.getYear();</span><br><span class="line">    &#x2F;&#x2F; 月份</span><br><span class="line">    Month month &#x3D; date.getMonth();</span><br><span class="line">    &#x2F;&#x2F; 这个月第几天</span><br><span class="line">    int dayOfMonth &#x3D; date.getDayOfMonth();</span><br><span class="line">    &#x2F;&#x2F; 这周星期几</span><br><span class="line">    DayOfWeek dayOfWeek &#x3D; date.getDayOfWeek();</span><br><span class="line">    &#x2F;&#x2F; 今年第几天</span><br><span class="line">    int dayOfYear &#x3D; date.getDayOfYear();</span><br><span class="line">    &#x2F;&#x2F; 这个月的长度（有几天）</span><br><span class="line">    int lengthOfMonth &#x3D; date.lengthOfMonth();</span><br><span class="line">    &#x2F;&#x2F; 是否闰年</span><br><span class="line">    boolean leapYear &#x3D; date.isLeapYear();</span><br><span class="line">    System.out.println(now); &#x2F;&#x2F; 2019-09-02</span><br><span class="line">    System.out.println(year); &#x2F;&#x2F; 2019</span><br><span class="line">    System.out.println(month); &#x2F;&#x2F; AUGUST</span><br><span class="line">    System.out.println(dayOfMonth); &#x2F;&#x2F; 26</span><br><span class="line">    System.out.println(dayOfWeek); &#x2F;&#x2F; MONDAY</span><br><span class="line">    System.out.println(dayOfYear); &#x2F;&#x2F; 238</span><br><span class="line">    System.out.println(lengthOfMonth); &#x2F;&#x2F; 31</span><br><span class="line">    System.out.println(leapYear); &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时分秒对象：LocalTime"><a href="#时分秒对象：LocalTime" class="headerlink" title="时分秒对象：LocalTime"></a>时分秒对象：LocalTime</h4><p>可使用静态工厂方法<code>now</code>获取当前时间的时分秒（包含纳秒）。</p><p>可使用静态工厂方法<code>of</code>创建一个<code>LocalTime</code>时间对象，可从一个<code>LocalTime</code>时间对象中获取该时间的时、分、秒和纳秒等信息。</p><p><code>of</code>方法包含三个重载，方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param hour  the hour-of-day to represent, from 0 to 23</span><br><span class="line"> * @param minute  the minute-of-hour to represent, from 0 to 59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static LocalTime of(int hour, int minute);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param hour  the hour-of-day to represent, from 0 to 23</span><br><span class="line"> * @param minute  the minute-of-hour to represent, from 0 to 59</span><br><span class="line"> * @param second  the second-of-minute to represent, from 0 to 59</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static LocalTime of(int hour, int minute, int second);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param hour  the hour-of-day to represent, from 0 to 23</span><br><span class="line"> * @param minute  the minute-of-hour to represent, from 0 to 59</span><br><span class="line"> * @param second  the second-of-minute to represent, from 0 to 59</span><br><span class="line"> * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static LocalTime of(int hour, int minute, int second, int nanoOfSecond);</span><br></pre></td></tr></table></figure><p>使用代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalTime：时分秒</span><br><span class="line"> * 一天中的时间，比如：13:45:20，可以使用LocalTime类表示</span><br><span class="line"> * 可以使用of重载的三个静态工厂方法创建LocalTime实例</span><br><span class="line"> * 第一个重载方法接收小时和分钟</span><br><span class="line"> * 第二个重载方法同时还接收秒</span><br><span class="line"> * 第三个重载方法同时还接收纳秒</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLocalTime() &#123;</span><br><span class="line">    LocalTime now &#x3D; LocalTime.now();</span><br><span class="line">    LocalTime localTime &#x3D; LocalTime.of(13, 45, 20,1);</span><br><span class="line">    int hour &#x3D; localTime.getHour();</span><br><span class="line">    int minute &#x3D; localTime.getMinute();</span><br><span class="line">    int second &#x3D; localTime.getSecond();</span><br><span class="line">    int nano &#x3D; localTime.getNano();</span><br><span class="line">    System.out.println(now); &#x2F;&#x2F; 19:47:51.212</span><br><span class="line">    System.out.println(hour); &#x2F;&#x2F; 13</span><br><span class="line">    System.out.println(minute); &#x2F;&#x2F; 45</span><br><span class="line">    System.out.println(second); &#x2F;&#x2F; 20</span><br><span class="line">    System.out.println(nano); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期时间字符串解析"><a href="#日期时间字符串解析" class="headerlink" title="日期时间字符串解析"></a>日期时间字符串解析</h4><p>LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse。一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalDate和LocalTime都可以通过解析代表它们的字符串创建。使用静态方法parse。</span><br><span class="line"> * 一旦传递的字符串参数无法被解析为合法的LocalDate或LocalTime对象，</span><br><span class="line"> * 这两个parse方法都会抛出一个继承自RuntimeException的DateTimeParseException异常。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testParse() &#123;</span><br><span class="line">    &#x2F;&#x2F; 小于10的必须在前面补0，否则抛出异常</span><br><span class="line">    LocalDate localDate &#x3D; LocalDate.parse(&quot;2019-08-26&quot;);</span><br><span class="line">    LocalTime localTime &#x3D; LocalTime.parse(&quot;13:45:20&quot;);</span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    System.out.println(localTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="年月日时分秒对象：LocalDateTime"><a href="#年月日时分秒对象：LocalDateTime" class="headerlink" title="年月日时分秒对象：LocalDateTime"></a>年月日时分秒对象：LocalDateTime</h4><p>可使用静态工厂方法<code>now</code>获取当前时间的年月日时分秒纳秒；</p><p>可使用静态工厂方法<code>of</code>创建一个<code>LocalDateTime</code>日期时间对象；</p><p>可由<code>LocalDate</code>和<code>LocalTime</code>组合出<code>LocalDateTime</code>对象；</p><p>可从<code>LocalDateTime</code>对象中提取出<code>LocalDate</code>和<code>LocalTime</code>。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * LocalDateTime：年月日时分秒</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testLocalDateTime() &#123;</span><br><span class="line">    LocalDateTime localDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">    LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2019, Month.AUGUST, 26, 10, 47, 20);</span><br><span class="line">    LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line">    LocalTime localTime &#x3D; LocalTime.now();</span><br><span class="line">    &#x2F;&#x2F; 由LocalDate和LocalTime组合出LocalDateTime</span><br><span class="line">    LocalDateTime localDateTime2 &#x3D; LocalDateTime.of(localDate,localTime);</span><br><span class="line">    LocalDateTime localDateTime3 &#x3D; localDate.atTime(10,51,32);</span><br><span class="line">    LocalDateTime localDateTime4 &#x3D; localDate.atTime(localTime);</span><br><span class="line">    LocalDateTime localDateTime5 &#x3D; localTime.atDate(localDate);</span><br><span class="line">    &#x2F;&#x2F; 由LocalDateTime提取出LocalDate和LocalTime</span><br><span class="line">    LocalDate localDateFromLocalDateTime &#x3D; localDateTime2.toLocalDate();</span><br><span class="line">    LocalTime localTimeFromLocalDateTime &#x3D; localDateTime2.toLocalTime();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDateTime); &#x2F;&#x2F; 2019-09-02T19:57:16.516</span><br><span class="line">    System.out.println(localDateTime1); &#x2F;&#x2F; 2019-08-26T10:47:20</span><br><span class="line">    System.out.println(localDateTime2); &#x2F;&#x2F; 2019-09-02T19:57:16.517</span><br><span class="line">    System.out.println(localDateTime3); &#x2F;&#x2F; 2019-09-02T10:51:32</span><br><span class="line">    System.out.println(localDateTime4); &#x2F;&#x2F; 2019-09-02T19:57:16.517</span><br><span class="line">    System.out.println(localDateTime5); &#x2F;&#x2F; 2019-09-02T19:57:16.517</span><br><span class="line">    System.out.println(localDateFromLocalDateTime); &#x2F;&#x2F; 2019-09-02</span><br><span class="line">    System.out.println(localTimeFromLocalDateTime); &#x2F;&#x2F; 19:57:16.517</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间戳对象：Instant"><a href="#时间戳对象：Instant" class="headerlink" title="时间戳对象：Instant"></a>时间戳对象：Instant</h4><p>机器的日期和时间格式：从UNIX元年时间开始到现在所经过的秒数对时间进行建模。包含的是由秒及纳秒组成的数字。</p><p>使用静态工厂方法<code>now</code>获取当前时刻的时间戳，默认获取的是UTC时区（世界协调时间）所在的时刻，可做时区偏移运算获取带偏移量的日期时间对象<code>OffsetDateTime</code>。可使用<code>toEpochMilli</code>方法获取表示的时间戳秒数。</p><p>可使用静态工厂方法<code>ofEpochSecond</code>等对时间戳进行运算。</p><p><code>Instant</code>的设计初衷是为了便于机器使用。它包含的是由秒及纳秒所构成的数字。所以，它无法处理那些我们非常容易理解的时间单位。比如下面这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int day &#x3D; Instant.now().get(ChronoField.DAY_OF_MONTH);</span><br></pre></td></tr></table></figure><p>它会抛出如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Instant：从UNIX元年时间开始到现在所经过的秒数对时间进行建模。包含的是由秒及纳秒组成的数字。</span><br><span class="line"> *</span><br><span class="line"> * 静态工厂方法：ofEpochSecond包含两个重载版本</span><br><span class="line"> * &#x2F;&#x2F; 传入一个代表秒数的值创建一个Instant实例</span><br><span class="line"> * Instant ofEpochSecond(long epochSecond)</span><br><span class="line"> * &#x2F;&#x2F; 第一个参数：代表秒数的值，第二个参数：纳秒数，对第一个参数传入的秒数进行调整，确保保存的纳秒分片在0到999 999 999之间。</span><br><span class="line"> * Instant ofEpochSecond(long epochSecond, long nanoAdjustment)</span><br><span class="line"> *</span><br><span class="line"> * 静态工厂方法：now</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testInstant() &#123;</span><br><span class="line">    Instant instant1 &#x3D; Instant.ofEpochSecond(3);</span><br><span class="line">    Instant instant2 &#x3D; Instant.ofEpochSecond(3, 0);</span><br><span class="line">    Instant instant3 &#x3D; Instant.ofEpochSecond(2, 1_000_000_000);</span><br><span class="line">    Instant instant4 &#x3D; Instant.ofEpochSecond(4, -1_000_000_000);</span><br><span class="line">    System.out.println(instant1);</span><br><span class="line">    System.out.println(instant2);</span><br><span class="line">    System.out.println(instant3);</span><br><span class="line">    System.out.println(instant4);</span><br><span class="line"></span><br><span class="line">    Instant now &#x3D; Instant.now(); &#x2F;&#x2F; 默认获取UTC时区的时间</span><br><span class="line">    System.out.println(now);</span><br><span class="line">    &#x2F;&#x2F; 时区偏移运算：获取偏移8小时的时区的时间。OffsetDateTime：带偏移量的日期时间对象</span><br><span class="line">    OffsetDateTime offsetDateTime &#x3D; now.atOffset(ZoneOffset.ofHours(8));</span><br><span class="line">    System.out.println(offsetDateTime);</span><br><span class="line">    &#x2F;&#x2F; 转化成时间戳</span><br><span class="line">    System.out.println(now.toEpochMilli());</span><br><span class="line">    &#x2F;&#x2F; java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span><br><span class="line">    int day &#x3D; now.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算两个时间之间的间隔：Duration-和计算两个日期之间的间隔：Period"><a href="#计算两个时间之间的间隔：Duration-和计算两个日期之间的间隔：Period" class="headerlink" title="计算两个时间之间的间隔：Duration 和计算两个日期之间的间隔：Period"></a>计算两个时间之间的间隔：Duration 和计算两个日期之间的间隔：Period</h4><p>可以使用<code>Duration</code>类的静态方法<code>between</code>计算两个时间点之间的间隔，<code>between</code>方法接收的参数是两个<code>Temporal</code>对象，虽然<code>LocalDateTime</code>和<code>Instant</code>都是<code>Temporal</code>接口的实现类，但是它们是为不同的目的而设计的，一个是为了便于人阅读使用， 另一个是为了便于机器处理，所以我们不能将它们混用，即不能计算<code>LocalDateTime</code>和<code>Instant</code>对象之间的间隔。</p><p>可以使用<code>Period</code>类的静态方法<code>between</code>计算两个日期之间的间隔。</p><p>也可使用静态工厂方法直接创建<code>Duration</code>和<code>Period</code>类的对象。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算两个时间之间的间隔：Duration</span><br><span class="line"> * 计算两个日期之间的间隔：Period</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testDuration() throws Exception &#123;</span><br><span class="line">    LocalTime localTime1 &#x3D; LocalTime.parse(&quot;13:45:20&quot;);</span><br><span class="line">    LocalTime localTime2 &#x3D; LocalTime.parse(&quot;13:45:30&quot;);</span><br><span class="line">    LocalDateTime localDateTime1 &#x3D; LocalDateTime.now();</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">    LocalDateTime localDateTime2 &#x3D; LocalDateTime.now();</span><br><span class="line">    Instant instant1 &#x3D; Instant.ofEpochSecond(3);</span><br><span class="line">    Instant instant2 &#x3D; Instant.ofEpochSecond(6);</span><br><span class="line">    System.out.println(Duration.between(localTime1,localTime2)); &#x2F;&#x2F; PT10S</span><br><span class="line">    System.out.println(Duration.between(localDateTime1,localDateTime2)); &#x2F;&#x2F; PT0.1S</span><br><span class="line">    System.out.println(Duration.between(instant1,instant2)); &#x2F;&#x2F; PT3S</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算两个LocalDate之间的时长</span><br><span class="line">    Period periodBetween &#x3D; Period.between(LocalDate.of(2019, 8, 26), LocalDate.of(2019, 8, 28));</span><br><span class="line">    System.out.println(periodBetween); &#x2F;&#x2F; P1D</span><br><span class="line">    System.out.println(periodBetween.getDays()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Duration和Period的静态工厂方法直接创建实例</span><br><span class="line">    Duration durationOfMinutes &#x3D; Duration.ofMinutes(3);</span><br><span class="line">    Duration durationOf &#x3D; Duration.of(3, ChronoUnit.MINUTES);</span><br><span class="line">    Period periodOfDays &#x3D; Period.ofDays(10);</span><br><span class="line">    Period periodOfWeeks &#x3D; Period.ofWeeks(3);</span><br><span class="line">    Period periodOf &#x3D; Period.of(2, 6, 1);</span><br><span class="line">    System.out.println(durationOfMinutes); &#x2F;&#x2F; PT3M</span><br><span class="line">    System.out.println(durationOf); &#x2F;&#x2F; PT3M</span><br><span class="line">    System.out.println(periodOfDays); &#x2F;&#x2F; P10D</span><br><span class="line">    System.out.println(periodOfWeeks); &#x2F;&#x2F; P21D</span><br><span class="line">    System.out.println(periodOf); &#x2F;&#x2F; P2Y6M1D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作、解析和格式化日期"><a href="#操作、解析和格式化日期" class="headerlink" title="操作、解析和格式化日期"></a>操作、解析和格式化日期</h4><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>以及<code>Instant</code>这样表示时间点的日期-时间类提供了很多通用的方法用来操作日期-时间。所有的方法都返回一个修改了属性的对象。它们都不会修改原来的对象。</p><p>最直接也最简单的方法是使用”<code>withAttribute</code>“方法。”<code>withAttribute</code>“方法会创建对象的一个副本，并按照需要修改它的属性。</p><p>也可使用通用的<code>with</code>方法，它接受的第一个参数是一个<code>TemporalField</code>对象，第二个参数是需要修改的值。</p><p><code>with</code>方法还有一个重载的方法，它接收一个日期调整器<code>TemporalAdjuster</code>对象，更加灵活地处理日期。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 操纵、解析和格式化日期</span><br><span class="line"> *</span><br><span class="line"> * LocalDate、LocalTime和LocalDateTime类都为final类，不可变，每次操作后都返回一个新的对应对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testUpdateTime() &#123;</span><br><span class="line">    LocalDate date1 &#x3D; LocalDate.of(2019, 8, 26);</span><br><span class="line">    LocalDate date2 &#x3D; date1.withYear(2020);</span><br><span class="line">    LocalDate date3 &#x3D; date2.withDayOfMonth(25);</span><br><span class="line">    LocalDate date4 &#x3D; date3.with(ChronoField.MONTH_OF_YEAR, 9);</span><br><span class="line">    System.out.println(date1); &#x2F;&#x2F; 2019-08-26</span><br><span class="line">    System.out.println(date2); &#x2F;&#x2F; 2020-08-26</span><br><span class="line">    System.out.println(date3); &#x2F;&#x2F; 2020-08-25</span><br><span class="line">    System.out.println(date4); &#x2F;&#x2F; 2020-09-25</span><br><span class="line"></span><br><span class="line">    LocalDate date5 &#x3D; LocalDate.of(2019,8,26);</span><br><span class="line">    LocalDate date6 &#x3D; date5.plusWeeks(1); &#x2F;&#x2F; 加一周</span><br><span class="line">    LocalDate date7 &#x3D; date6.minusYears(3); &#x2F;&#x2F; 减三年</span><br><span class="line">    LocalDate date8 &#x3D; date7.plus(6, ChronoUnit.MONTHS); &#x2F;&#x2F; 加六月</span><br><span class="line">    System.out.println(date5); &#x2F;&#x2F; 2019-08-26</span><br><span class="line">    System.out.println(date6); &#x2F;&#x2F; 2019-09-02</span><br><span class="line">    System.out.println(date7); &#x2F;&#x2F; 2016-09-02</span><br><span class="line">    System.out.println(date8); &#x2F;&#x2F; 2017-03-02</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期调整器：TemporalAdjuster"><a href="#日期调整器：TemporalAdjuster" class="headerlink" title="日期调整器：TemporalAdjuster"></a>日期调整器：TemporalAdjuster</h4><p><code>TemporalAdjuster</code>是一个函数式接口，接口方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Temporal adjustInto(Temporal temporal);</span><br></pre></td></tr></table></figure><p>接收一个<code>Temporal</code>对象，返回一个<code>Temporal</code>对象。由于所有的日期时间API都实现了<code>Temporal</code>接口，故它可以用来自定义更加复杂的日期时间操作。</p><p>Java 8提供了<code>TemporalAdjusters</code>类，该类通过静态方法提供了大量的常用<code>TemporalAdjuster</code>的实现。</p><p>同时还支持定制<code>TemporalAdjuster</code>，定制的方式有两种：</p><p>一：实现<code>TemporalAdjuster</code>接口；</p><p>二：使用Lambda表达式定制<code>TemporalAdjuster</code>对象，推荐使用<code>TemporalAdjusters</code>类的静态工厂方法<code>ofDateAdjuster</code>，该方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster)</span><br></pre></td></tr></table></figure><p>接收一个<code>UnaryOperator</code>函数式接口，返回一个<code>TemporalAdjuster</code>对象。</p><p><code>UnaryOperator</code>函数式接口中方法签名如下，它总是返回它的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123;</span><br><span class="line">    return t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 日期调整器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testTemporalAdjuster() &#123;</span><br><span class="line">    LocalDate date1 &#x3D; LocalDate.of(2019,8,26);</span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</span><br><span class="line">    &#x2F;&#x2F; dayOfWeek表示星期几</span><br><span class="line">    &#x2F;&#x2F; 如果ordinal为0，则表示本日期所在的月的上一个月的最后一个星期几</span><br><span class="line">    &#x2F;&#x2F; 如果ordinal为正数，则以本日期所在的月从前向后数，第ordinal个星期几</span><br><span class="line">    &#x2F;&#x2F; 如果ordinal为负数，则以本日期所在的月从后往前数，第-ordinal个星期几</span><br><span class="line">    LocalDate date2 &#x3D; date1.with(TemporalAdjusters.dayOfWeekInMonth(1, DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(&quot;date2&#x3D;&quot; + date2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfMonth()：创建一个新的日期，它的值为当月的第一天</span><br><span class="line">    LocalDate date3 &#x3D; date1.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    System.out.println(&quot;date3&#x3D;&quot; + date3);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfNextMonth()：创建一个新的日期，它的值为下月的第一天</span><br><span class="line">    LocalDate date4 &#x3D; date1.with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">    System.out.println(&quot;date4&#x3D;&quot; + date4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfNextYear()：创建一个新的日期，它的值为明年的第一天</span><br><span class="line">    LocalDate date5 &#x3D; date1.with(TemporalAdjusters.firstDayOfNextYear());</span><br><span class="line">    System.out.println(&quot;date5&#x3D;&quot; + date5);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstDayOfYear()：创建一个新的日期，它的值为今年的第一天</span><br><span class="line">    LocalDate date6 &#x3D; date1.with(TemporalAdjusters.firstDayOfYear());</span><br><span class="line">    System.out.println(&quot;date6&#x3D;&quot; + date6);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)：创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的日期（这个月的第一个星期几）</span><br><span class="line">    LocalDate date7 &#x3D; date1.with(TemporalAdjusters.firstInMonth(DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(&quot;date7&#x3D;&quot; + date7);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster lastDayOfMonth()：创建一个新的日期，它的值为这个月的最后一天</span><br><span class="line">    LocalDate date8 &#x3D; date1.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    System.out.println(&quot;date8&#x3D;&quot; + date8);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster lastDayOfYear()：创建一个新的日期，它的值为今年的最后一天</span><br><span class="line">    LocalDate date9 &#x3D; date1.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    System.out.println(&quot;date9&#x3D;&quot; + date9);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)：创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的日期</span><br><span class="line">    LocalDate date10 &#x3D; date1.with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY));</span><br><span class="line">    System.out.println(&quot;date10&#x3D;&quot; + date10);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster next(DayOfWeek dayOfWeek)：创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期</span><br><span class="line">    LocalDate date11 &#x3D; date1.with(TemporalAdjusters.next(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date11&#x3D;&quot; + date11);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)：</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期；</span><br><span class="line">    &#x2F;&#x2F; 如果指定日期已符合要求，则直接返回该日期</span><br><span class="line">    LocalDate date12 &#x3D; date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date12&#x3D;&quot; + date12);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster previous(DayOfWeek dayOfWeek)：创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期</span><br><span class="line">    LocalDate date13&#x3D; date1.with(TemporalAdjusters.previous(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date13&#x3D;&quot; + date13);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)：</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期；</span><br><span class="line">    &#x2F;&#x2F; 如果指定日期已符合要求，则直接返回该日期</span><br><span class="line">    LocalDate date14 &#x3D; date1.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(&quot;date14&#x3D;&quot; + date14);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用Lambda表达式定制TemporalAdjuster对象，推荐使用TemporalAdjusters类的静态工厂方法ofDateAdjuster</span><br><span class="line">    &#x2F;&#x2F; TemporalAdjuster ofDateAdjuster(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster)</span><br><span class="line">    TemporalAdjuster nextWorkingDay &#x3D; TemporalAdjusters.ofDateAdjuster(temporal -&gt; &#123;</span><br><span class="line">        DayOfWeek dayOfWeek &#x3D; DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">        int dayToAdd &#x3D; 1;</span><br><span class="line">        if (dayOfWeek &#x3D;&#x3D; DayOfWeek.FRIDAY) dayToAdd &#x3D; 3;</span><br><span class="line">        else if (dayOfWeek &#x3D;&#x3D; DayOfWeek.SATURDAY) dayToAdd &#x3D; 2;</span><br><span class="line">        return temporal.plus(dayToAdd,ChronoUnit.DAYS);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定制TemporalAdjuster</span><br><span class="line"> *</span><br><span class="line"> * 计算下一个工作日</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NextWorkingDay implements TemporalAdjuster &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 周一到周五为工作日</span><br><span class="line">     * 如果是周日到周四，则返回下一天</span><br><span class="line">     * 如果是周五、周六、返回下周周一</span><br><span class="line">     * @param temporal</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Temporal adjustInto(Temporal temporal) &#123;</span><br><span class="line">        &#x2F;&#x2F; 得到今天星期几</span><br><span class="line">        DayOfWeek dayOfWeek &#x3D; DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">        int dayToAdd &#x3D; 1;</span><br><span class="line">        if (dayOfWeek &#x3D;&#x3D; DayOfWeek.FRIDAY) dayToAdd &#x3D; 3;</span><br><span class="line">        else if (dayOfWeek &#x3D;&#x3D; DayOfWeek.SATURDAY) dayToAdd &#x3D; 2;</span><br><span class="line">        return temporal.plus(dayToAdd,ChronoUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TemporalAdjusters</code>类中包含的工厂方法列表：</p><table><thead><tr><th align="left">方法签名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>TemporalAdjuster dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)</code></td><td align="left">dayOfWeek表示星期几<br />如果ordinal为0，则表示本日期所在的月的上一个月的最后一个星期几<br />如果ordinal为正数，则以本日期所在的月从前向后数，第ordinal个星期几<br /> 如果ordinal为负数，则以本日期所在的月从后往前数，第-ordinal个星期几</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfMonth()</code></td><td align="left">创建一个新的日期，它的值为当月的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfNextMonth()</code></td><td align="left">创建一个新的日期，它的值为下月的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfNextYear()</code></td><td align="left">创建一个新的日期，它的值为明年的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstDayOfYear()</code></td><td align="left">创建一个新的日期，它的值为今年的第一天</td></tr><tr><td align="left"><code>TemporalAdjuster firstInMonth(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的日期（这个月的第一个星期几）</td></tr><tr><td align="left"><code>TemporalAdjuster lastDayOfMonth()</code></td><td align="left">创建一个新的日期，它的值为这个月的最后一天</td></tr><tr><td align="left"><code>TemporalAdjuster lastDayOfYear()</code></td><td align="left">创建一个新的日期，它的值为今年的最后一天</td></tr><tr><td align="left"><code>TemporalAdjuster lastInMonth(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的日期</td></tr><tr><td align="left"><code>TemporalAdjuster next(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期</td></tr><tr><td align="left"><code>TemporalAdjuster nextOrSame(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之后第一个符合指定星期几的日期；如果指定日期已符合要求，则直接返回该日期</td></tr><tr><td align="left"><code>TemporalAdjuster previous(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期</td></tr><tr><td align="left"><code>TemporalAdjuster previousOrSame(DayOfWeek dayOfWeek)</code></td><td align="left">创建一个新的日期，并将其值设定为指定日期之前第一个符合指定星期几的日期；如果指定日期已符合要求，则直接返回该日期</td></tr></tbody></table><h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p>时区的处理是新版日期和时间API新增加的重要功能，使用新版日期和时间API时区的处理被极大地简化了。新的<code>java.time.ZoneId</code>类是老版<code>java.util.TimeZone</code>的替代品。它的设计目标就是要让你无需为时区处理的复杂和繁琐而操心，跟其他日期和时间类一 样，<code>ZoneId</code>类也是被<code>final</code>修饰而无法修改的。</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 带时区的日期时间API</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Test</span><br><span class="line">public void testZoneLocalDateTime() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查看所有支持的时区</span><br><span class="line">    Set&lt;String&gt; availableZoneIds &#x3D; ZoneId.getAvailableZoneIds();</span><br><span class="line">    for (String s: availableZoneIds) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 通过时区构建LocalDateTime对象</span><br><span class="line">    LocalDateTime localDateTimeNow &#x3D; LocalDateTime.now(ZoneId.of(&quot;Asia&#x2F;Shanghai&quot;));</span><br><span class="line">    &#x2F;&#x2F; 指定时区构建带时区的日期时间对象</span><br><span class="line">    ZonedDateTime zonedDateTime &#x3D; localDateTimeNow.atZone(ZoneId.of(&quot;Asia&#x2F;Shanghai&quot;));</span><br><span class="line">    System.out.println(localDateTimeNow); &#x2F;&#x2F; 2019-09-03T10:35:25.677</span><br><span class="line">    &#x2F;&#x2F; 2019-09-03T10:35:25.677+08:00[Asia&#x2F;Shanghai] 与UTC时间相差8小时</span><br><span class="line">    System.out.println(zonedDateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期时间API的部分UML图"><a href="#日期时间API的部分UML图" class="headerlink" title="日期时间API的部分UML图"></a>日期时间API的部分UML图</h4><p>以上介绍的新的日期时间API相关类的UML图如下：</p><p><img src="https://i.loli.net/2020/02/15/G5oUqew63xHfkup.png" alt="12-newDateTimeUML.png"></p><p>下面这张图能帮助我们更好的理解LocaleDate、 LocalTime、LocalDateTime以及ZoneId之间的差异。</p><p><img src="https://i.loli.net/2020/02/15/FbwNkXIJVrfBy2z.png" alt="12-ZonedDateTime组成.png"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java 8实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“煮熟的鸭子也会飞？”- 使用策略模式让你的“鸭子”飞起来</title>
      <link href="2019/12/12/design-patterns/gof/behavior/strategy/"/>
      <url>2019/12/12/design-patterns/gof/behavior/strategy/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟鸭子的问题"><a href="#模拟鸭子的问题" class="headerlink" title="模拟鸭子的问题"></a>模拟鸭子的问题</h2><p>问题描述：用代码模拟现实中的鸭子，鸭子有很多种类，会发出各种叫声，有的会游泳。</p><h2 id="传统设计方案"><a href="#传统设计方案" class="headerlink" title="传统设计方案"></a>传统设计方案</h2><p>传统方案：使用标准的面向对象设计。设计一个<code>Duck</code>超类，让不同种类的鸭子继承该超类。</p><p>传统方案的类图设计如下：<br><img src="https://i.loli.net/2020/02/15/YgU95kXfjRz7OoM.png" alt="traditionalDuckUML.png"></p><p>代码示例如下：</p><p><code>Duck</code>超类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 传统鸭子问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 其它鸭子都继承了Duck类，所以fly方法让所有的子类鸭子都会飞，但并不是所有鸭子都会飞。</span></span><br><span class="line"><span class="comment"> * 2. 实际上这是继承带来的问题，对父类的局部改动，会影响所有子类。称为溢出效应。</span></span><br><span class="line"><span class="comment"> * 3. 为了解决继承带来的问题，我们可以在子类中重写对应的方法来解决。</span></span><br><span class="line"><span class="comment"> * 4. 但是如果有一个玩具鸭类，它需要重写父类所有的方法，这样做的代价有点大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示鸭子信息的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子叫的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子嘎嘎叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子游泳的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子会游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子飞翔的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子会飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>野鸭<code>WildDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 野鸭：嘎嘎叫、会游泳和飞翔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一只野鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>北京鸭<code>PekingDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 北京鸭：不会飞翔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PekingDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一只北京鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;北京鸭不会飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>玩具鸭<code>ToyDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.traditional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 玩具鸭：不会嘎嘎叫、不会游泳和飞翔。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一只玩具鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩具鸭不能叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩具鸭不会游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩具鸭不会飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超类<code>Duck</code>中定义了3个实现方法，一个抽象方法。</p><p>子类野鸭WildDuck类会“嘎嘎叫”、“游泳”和“飞翔”。所以野鸭类只需实现抽象方法display即可。</p><p>子类北京鸭PekingDuck类不会飞翔，除了实现抽象方法之外还需重写父类的fly方法。</p><p>子类玩具鸭ToyDuck类不会叫、不会游泳也不会飞翔。所以玩具鸭类除了实现抽象方法，还要重写父类的三个方法。</p><p>这种继承的设计思路似乎没有任何问题。但事实上子类重写父类方法的代价是很高的，一旦出现一个新品种的鸭子，就要去继承<code>Duck</code>类，子类默认就有了父类定义好的行为，例如“嘎嘎叫”、“游泳”和“飞翔”。如果子类不满足这些行为就要去重写父类中对应的方法。同时，一旦对父类进行某些局部改动，所有子类都会受到影响。</p><p>我们知道Duck类内的fly()和quack()会随着鸭子的不同而改变。事实上每次继承都是在改动这两个方法。</p><p>不妨使用策略模式来改造<code>Duck</code>类。</p><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><p>策略模式中有以下三条设计原则：</p><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>多用组合，少用继承。</li></ul><h2 id="分离行为-—-让“煮熟的鸭子”飞起来"><a href="#分离行为-—-让“煮熟的鸭子”飞起来" class="headerlink" title="分离行为 — 让“煮熟的鸭子”飞起来"></a>分离行为 — 让“煮熟的鸭子”飞起来</h2><p>是时候将行为从Duck类中分离出来了。将鸭子的行为封装到新的类中，该类专门提供某行为的实现。这样，Duck类就不再需要知道行为的具体实现。</p><p>那么如何设计实现“飞翔”和“嘎嘎叫”的行为的类呢？我们希望“煮熟的鸭子飞起来”，鸭子需要经历从生到熟这个过程，我们要做的是在Duck类中增加设定行为的方法，这样就能在“运行时期”动态改变鸭子的行为。</p><p>使用了策略模式的类图设计如下：<br><img src="https://i.loli.net/2020/02/15/3hz8VipoP5ZYW9s.png" alt="strategyDuckUML.png"></p><p>代码示例如下：</p><p>“飞翔”行为接口<code>FlyBehavior</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 飞翔行为接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 飞翔的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随风飞翔的行为<code>FlyWithWings</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.FlyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 可以飞的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fly with wings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能飞的行为<code>FlyNoWay</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.FlyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 不能飞的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用火箭动力飞翔的行为<code>FlyRocketPowered</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.FlyBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 利用火箭动力的飞翔行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyRocketPowered</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fly with rocket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“叫”的行为接口<code>QuackBehavior</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 鸭子叫行为接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子叫的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘎嘎叫的行为<code>Quack</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.QuackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 嘎嘎叫的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack 嘎嘎叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吱吱叫的行为<code>Squeak</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.QuackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 吱吱叫的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Squeak 吱吱叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会叫的行为<code>MuteQuack</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.QuackBehavior;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 不会叫的行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">implements</span> <span class="title">QuackBehavior</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Silence 不会叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离行为后的<code>Duck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用策略模式的鸭子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 飞翔的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 叫的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置飞行行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flyBehavior 飞行行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置叫的行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quackBehavior 叫行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使鸭子飞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flyBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            flyBehavior.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使鸭子叫</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (quackBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            quackBehavior.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 鸭子游泳的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子会游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示鸭子信息的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>野鸭<code>WildDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyWithWings;</span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.Quack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 野鸭：具有可以飞的行为和嘎嘎叫的行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WildDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随风飞翔行为</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">        <span class="comment">// 嘎嘎叫行为</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一只使用策略模式的野鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>北京鸭<code>PekingDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyNoWay;</span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.Squeak;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 北京鸭：不能飞翔，吱吱叫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PekingDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PekingDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不能飞的行为</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        <span class="comment">// 吱吱叫的行为</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Squeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一只使用策略模式的北京鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>玩具鸭<code>ToyDuck</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyNoWay;</span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.MuteQuack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 玩具鸭：不会飞也不会叫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToyDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不会飞的行为</span></span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        <span class="comment">// 不会叫的行为</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> MuteQuack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一只使用策略模式的玩具鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切都准备就绪！让我们来见证“煮熟的鸭子”的飞翔吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.org.lilu.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.org.lilu.strategy.impl.FlyRocketPowered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Java成魔之路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/9/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: for test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生产一只北京鸭</span></span><br><span class="line">        Duck duck = <span class="keyword">new</span> PekingDuck();</span><br><span class="line">        <span class="comment">// 让鸭子飞</span></span><br><span class="line">        duck.performFly();</span><br><span class="line">        <span class="comment">// 让鸭子叫</span></span><br><span class="line">        duck.performQuack();</span><br><span class="line">        <span class="comment">// 生产一只玩具鸭</span></span><br><span class="line">        Duck toyDuck = <span class="keyword">new</span> ToyDuck();</span><br><span class="line">        <span class="comment">// 让鸭子飞：发现不能飞</span></span><br><span class="line">        toyDuck.performFly();</span><br><span class="line">        <span class="comment">// 动态改变行为：让“煮熟的鸭子”飞起来</span></span><br><span class="line">        toyDuck.setFlyBehavior(<span class="keyword">new</span> FlyRocketPowered());</span><br><span class="line">        toyDuck.performFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">can&#39;t fly</span><br><span class="line">Squeak 吱吱叫</span><br><span class="line">can&#39;t fly</span><br><span class="line">fly with rocket</span><br></pre></td></tr></table></figure><p>不管怎样，我们的玩具鸭飞起来了，这里玩具鸭和“煮熟的鸭子”性质上是一样的。</p><p>现在我们的<code>Duck</code>类不再担心出现新的鸭子种类了。一旦有一个不同行为的新种类鸭，只需要写一个新的行为接口的实现。而不需要对<code>Duck</code>类进行修改。这体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略即可，避免了使用多重转移语句(if-else…if-else)。同时策略模式的缺点也由此暴露，每添加一个策略就会产生一个新的类，当策略过多时，类的数量会随之过多。但这至少比使用继承时重写父类方法要好的多。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> GOF设计模式 </category>
          
          <category> 行为型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> GOF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
